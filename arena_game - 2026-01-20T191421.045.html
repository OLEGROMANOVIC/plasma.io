<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PLASMA - Arena Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        /* Mobile landscape mode zorunlu - Portrait uyarƒ±sƒ± */
        @media screen and (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: 'üì± TELEFONUNUZU YATAY √áEVƒ∞Rƒ∞N\AüîÑ ROTATE YOUR PHONE TO LANDSCAPE';
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.98);
                color: #00ff88;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
                white-space: pre-line;
                line-height: 2;
                text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            }
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }
        
        canvas {
            display: block;
            background: #0f0f1e;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
        }
        
        .stat {
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 5px;
            border-left: 4px solid #00ff88;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .stat:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: translateX(5px);
            border-left-width: 6px;
        }
        
        #healthBar {
            width: 200px;
            height: 25px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #333;
            position: relative;
            animation: glow 2s infinite;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        #healthFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        #weaponInfo {
            color: #ffd700;
            animation: pulse 2s infinite;
        }
        
        #score, #wave {
            display: inline-block;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: transform 0.2s;
        }
        
        /* Orta √ºst skor g√∂stergesi */
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
        }
        
        #scoreValue {
            font-size: 64px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 
                0 0 20px rgba(0, 255, 136, 0.8),
                0 0 40px rgba(0, 255, 136, 0.4),
                0 0 60px rgba(0, 255, 136, 0.2);
            font-family: 'Arial Black', sans-serif;
            letter-spacing: 3px;
            transition: all 0.3s ease;
        }
        
        #scoreLabel {
            font-size: 16px;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 4px;
            margin-top: -10px;
        }
        
        #scoreParticles {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        @keyframes scorePopUp {
            0% {
                transform: translateX(-50%) scale(1);
            }
            50% {
                transform: translateX(-50%) scale(1.3);
                filter: brightness(1.5);
            }
            100% {
                transform: translateX(-50%) scale(1);
            }
        }
        
        @keyframes scoreParticle {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }
        
        .score-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff88;
            animation: scoreParticle 1s ease-out forwards;
            pointer-events: none;
        }
        
        /* Level ilerleme barƒ± */
        #levelProgress {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #00ff88;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #levelProgressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffdd);
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        #levelProgressFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }
        
        #levelProgressText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            font-size: 14px;
        }
        
        @keyframes levelUp {
            0%, 100% {
                transform: translateX(-50%) scale(1);
                filter: brightness(1);
            }
            50% {
                transform: translateX(-50%) scale(1.2);
                filter: brightness(2);
            }
        }
        
        /* √ús kurulum ekranƒ± */
        #basePlacement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            z-index: 10;
            pointer-events: none;
        }
        
        #basePlacement.hidden {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        #basePlacementText {
            color: #00ff88;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
            animation: pulse 2s infinite;
        }
        
        #basePlacementHint {
            color: #ffffff;
            font-size: 16px;
            text-align: center;
            max-width: 500px;
            line-height: 1.5;
        }
        
        /* Dil deƒüi≈ütirme butonu */
        #languageToggle {
            position: absolute;
            top: 120px;
            right: 20px;
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: none;
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            z-index: 300;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transition: all 0.3s;
        }
        
        #languageToggle:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }
        
        /* Platform se√ßim ekranƒ± */
        #platformSelection, #biomeSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
        }
        
        /* MAIN MENU */
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0a0a1a 100%);
            display: flex;
            flex-direction: column;
            z-index: 500;
            overflow: hidden;
        }
        
        #mainMenu.hidden {
            display: none;
        }
        
        /* Animated Background Particles */
        .menu-bg-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .menu-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ffdd;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffdd;
            animation: floatParticle 20s infinite linear;
        }
        
        @keyframes floatParticle {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translate(100vw, -100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .menu-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ff88, transparent);
            animation: moveLine 15s infinite linear;
        }
        
        @keyframes moveLine {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            10% {
                opacity: 0.3;
            }
            90% {
                opacity: 0.3;
            }
            100% {
                transform: translateX(200%);
                opacity: 0;
            }
        }
        
        .main-menu-header {
            text-align: center;
            padding: 20px 0 10px 0;
        }
        
        .main-menu-version {
            color: #00ff88;
            font-size: 16px;
            margin-top: 5px;
            font-weight: bold;
        }
        
        .main-menu-content {
            display: grid;
            grid-template-columns: 380px 1fr 380px;
            gap: 20px;
            padding: 10px 30px;
            width: 100%;
            height: calc(100% - 120px);
            position: relative;
            z-index: 1;
            box-sizing: border-box;
        }
        
        /* Left Panel */
        .main-menu-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .player-card {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            font-size: 14px;
        }
        
        .player-card-header {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .player-avatar {
            font-size: 40px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player-info {
            flex: 1;
        }
        
        .player-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
        }
        
        .player-level {
            color: #00ff88;
            font-size: 13px;
            margin-top: 3px;
        }
        
        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .player-stat {
            display: flex;
            flex-direction: column;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-icon {
            font-size: 20px;
            margin-bottom: 3px;
        }
        
        .stat-text {
            color: #fff;
            font-size: 12px;
        }
        
        .stat-value {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
        }
        
        /* Center Panel */
        .main-menu-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 20px;
            padding: 20px 0;
            overflow-y: auto;
        }
        
        .play-button {
            width: 250px;
            height: 250px;
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.8);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .play-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: playButtonShine 3s infinite;
        }
        
        @keyframes playButtonShine {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes adPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 23, 68, 0.4);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 23, 68, 0.8);
            }
        }
        
        .play-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 80px rgba(0, 255, 136, 1);
        }
        
        .play-button-icon {
            font-size: 100px;
            color: #000;
            font-weight: bold;
        }
        
        .play-button-text {
            font-size: 40px;
            font-weight: 900;
            color: #000;
            letter-spacing: 6px;
        }
        
        .menu-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .menu-button {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 12px 25px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
        }
        
        .menu-button:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }
        
        .menu-button-icon {
            font-size: 20px;
        }
        
        /* Right Panel */
        .main-menu-right {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .menu-section {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 8px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        /* Challenges - Compact */
        .challenges-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto !important; /* Changed from scroll to auto - works better */
            flex: 1;
            height: 280px; /* Fixed height instead of max-height */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #00ff88 rgba(0, 0, 0, 0.5); /* Firefox: thumb track */
            padding-right: 4px; /* Space for scrollbar */
        }
        
        .challenges-list::-webkit-scrollbar {
            width: 8px; /* Increased from 6px for better visibility */
            display: block !important; /* Force visibility */
        }
        
        .challenges-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5); /* Darker for visibility */
            border-radius: 4px;
        }
        
        .challenges-list::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
            min-height: 40px; /* Ensure thumb is visible */
        }
        
        .challenges-list::-webkit-scrollbar-thumb:hover {
            background: #00ffdd;
        }
        
        .challenge-item {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 6px;
            padding: 8px;
        }
        
        .challenge-name {
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 2px;
        }
        
        .challenge-desc {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 6px;
        }
        
        .challenge-progress {
            margin-bottom: 4px;
        }
        
        .progress-bar {
            width: 100%;
            height: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 2px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffdd);
            transition: width 0.3s;
        }
        
        .progress-text {
            font-size: 10px;
            color: #00ff88;
            text-align: right;
        }
        
        .challenge-reward {
            font-size: 10px;
            color: #a78bfa;
            font-weight: bold;
        }
        
        /* Changelog - Compact */
        .changelog-content {
            overflow-y: auto;
            flex: 1;
            max-height: 250px;
        }
        
        .changelog-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .changelog-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        
        .changelog-content::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 3px;
        }
        
        .changelog-content::-webkit-scrollbar-thumb:hover {
            background: #00ffdd;
        }
        
        .changelog-entry {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
        }
        
        .changelog-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .changelog-version {
            font-size: 15px;
            font-weight: bold;
            color: #00ffdd;
            margin-bottom: 3px;
        }
        
        .changelog-date {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .changelog-list {
            list-style: none;
            padding: 0;
        }
        
        .changelog-list li {
            color: #fff;
            font-size: 12px;
            margin-bottom: 4px;
            padding-left: 8px;
        }
        
        /* Quick Stats - Compact */
        .quick-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .quick-stat-item {
            display: flex;
            justify-content: space-between;
            padding: 6px;
            background: rgba(0, 255, 136, 0.05);
            border-radius: 5px;
        }
        
        .quick-stat-label {
            color: #aaa;
            font-size: 12px;
        }
        
        .quick-stat-value {
            color: #00ff88;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* BATTLE PASS CARD (Main Menu) */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .battlepass-card {
            position: relative;
            margin: 10px 0;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(157, 78, 221, 0.15), rgba(138, 43, 226, 0.1));
            border: 2px solid #9d4edd;
            border-radius: 12px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s;
            box-shadow: 0 3px 15px rgba(157, 78, 221, 0.3);
        }
        
        .battlepass-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(157, 78, 221, 0.5);
            border-color: #c77dff;
        }
        
        .bp-card-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        
        .bp-particles {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .bp-particle {
            position: absolute;
            background: radial-gradient(circle, #9d4edd, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: bpFloat 6s infinite ease-in-out;
        }
        
        @keyframes bpFloat {
            0%, 100% {
                transform: translateY(0) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translateY(-20px) scale(1.2);
                opacity: 1;
            }
        }
        
        .bp-card-content {
            position: relative;
            z-index: 1;
        }
        
        .bp-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .bp-card-icon {
            font-size: 24px;
            animation: bpPulse 2s infinite;
        }
        
        @keyframes bpPulse {
            0%, 100% {
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(157, 78, 221, 0.5));
            }
            50% {
                transform: scale(1.1);
                filter: drop-shadow(0 0 15px rgba(157, 78, 221, 1));
            }
        }
        
        .bp-card-title {
            flex: 1;
            font-size: 14px;
            font-weight: bold;
            background: linear-gradient(90deg, #9d4edd, #c77dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        
        .bp-card-status {
            padding: 3px 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 6px;
            font-size: 10px;
            font-weight: bold;
            color: #999;
        }
        
        .bp-card-status.premium {
            border-color: #ffd700;
            color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .bp-card-tier {
            display: flex;
            align-items: baseline;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .bp-tier-label {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .bp-tier-number {
            font-size: 28px;
            font-weight: bold;
            color: #9d4edd;
            text-shadow: 0 0 12px rgba(157, 78, 221, 0.8);
            line-height: 1;
        }
        
        .bp-tier-max {
            font-size: 14px;
            color: #666;
        }
        
        .bp-card-xp {
            margin-bottom: 6px;
        }
        
        .bp-xp-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #9d4edd;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }
        
        .bp-xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #9d4edd, #c77dff);
            box-shadow: 0 0 10px rgba(157, 78, 221, 0.8);
            transition: width 0.5s ease;
            animation: bpXpGlow 2s infinite;
        }
        
        @keyframes bpXpGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(157, 78, 221, 0.8);
            }
            50% {
                box-shadow: 0 0 20px rgba(157, 78, 221, 1);
            }
        }
        
        .bp-xp-text {
            font-size: 10px;
            color: #aaa;
            text-align: center;
        }
        
        .bp-card-cta {
            font-size: 10px;
            color: #9d4edd;
            text-align: center;
            margin-top: 6px;
            font-weight: bold;
            opacity: 0.8;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* STORE MODAL */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .store-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 600;
        }
        
        .store-modal.hidden {
            display: none;
        }
        
        .store-container {
            width: 90%;
            max-width: 1200px;
            height: 85%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .store-header {
            background: linear-gradient(90deg, #1a1a2e, #2a2a3e);
            border-bottom: 2px solid #ffd700;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .store-title {
            font-size: 32px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .store-currency {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ff88;
        }
        
        .currency-icon {
            font-size: 24px;
        }
        
        .currency-amount {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
        }
        
        .currency-label {
            font-size: 14px;
            color: #aaa;
        }
        
        .store-close {
            width: 40px;
            height: 40px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .store-close:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1);
        }
        
        .store-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #00ff88;
        }
        
        .store-tab {
            flex: 1;
            padding: 15px;
            background: transparent;
            border: none;
            border-right: 1px solid rgba(0, 255, 136, 0.3);
            color: #aaa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .store-tab:last-child {
            border-right: none;
        }
        
        .store-tab.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            border-bottom: 3px solid #00ff88;
        }
        
        .store-tab:hover:not(.active) {
            background: rgba(0, 255, 136, 0.1);
            color: #fff;
        }
        
        .tab-icon {
            font-size: 20px;
        }
        
        .tab-text {
            font-size: 14px;
            font-weight: bold;
        }
        
        .store-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .store-content::-webkit-scrollbar {
            width: 10px;
        }
        
        .store-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .store-content::-webkit-scrollbar-thumb {
            background: #ffd700;
            border-radius: 5px;
        }
        
        .store-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .store-item {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }
        
        .store-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
            border-color: #ffd700;
        }
        
        .store-item.purchased {
            opacity: 0.6;
            border-color: #666;
        }
        
        .store-item.purchased .item-buy-button {
            background: #666;
            cursor: not-allowed;
        }
        
        .item-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .badge-new {
            background: #ff0066;
            color: #fff;
        }
        
        .badge-popular {
            background: #ffd700;
            color: #000;
        }
        
        .badge-sale {
            background: #ff4444;
            color: #fff;
        }
        
        .badge-premium {
            background: linear-gradient(135deg, #ffd700, #ffed4e, #ffd700);
            color: #000;
            font-size: 12px;
            font-weight: bold;
            padding: 6px 12px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            animation: premiumBadgePulse 2s infinite, premiumBadgeShine 3s infinite;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }
        
        @keyframes premiumBadgePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 25px rgba(255, 215, 0, 1);
            }
        }
        
        @keyframes premiumBadgeShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        /* PREMIUM ITEM CARD STYLING */
        .premium-item {
            position: relative;
            border: 3px solid #ffd700 !important;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2), 
                rgba(255, 237, 78, 0.15), 
                rgba(255, 215, 0, 0.2)
            ) !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), inset 0 0 30px rgba(255, 215, 0, 0.1);
            animation: premiumCardGlow 3s infinite;
        }
        
        .premium-item::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700, #ffed4e);
            background-size: 300% 300%;
            border-radius: 15px;
            z-index: -1;
            animation: premiumBorderFlow 4s linear infinite;
        }
        
        @keyframes premiumCardGlow {
            0%, 100% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.4), inset 0 0 30px rgba(255, 215, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 50px rgba(255, 215, 0, 0.6), inset 0 0 50px rgba(255, 215, 0, 0.2);
            }
        }
        
        @keyframes premiumBorderFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .premium-item:hover {
            transform: translateY(-8px) !important;
            box-shadow: 0 15px 40px rgba(255, 215, 0, 0.6), inset 0 0 50px rgba(255, 215, 0, 0.2) !important;
        }
        
        .badge-mythic {
            background: linear-gradient(135deg, #ff00ff, #ffd700, #00ffff);
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            padding: 6px 12px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            animation: mythicBadgePulse 2s infinite, mythicBadgeShine 3s infinite;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }
        
        @keyframes mythicBadgePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 25px rgba(255, 0, 255, 1);
            }
        }
        
        @keyframes mythicBadgeShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }
        
        /* MYTHIC ITEM CARD STYLING */
        .mythic-item {
            position: relative;
            border: 3px solid #ff00ff !important;
            background: linear-gradient(135deg, 
                rgba(255, 0, 255, 0.15), 
                rgba(138, 43, 226, 0.15), 
                rgba(255, 215, 0, 0.15)
            ) !important;
            box-shadow: 
                0 0 30px rgba(255, 0, 255, 0.6),
                0 0 60px rgba(255, 0, 255, 0.3),
                inset 0 0 30px rgba(255, 0, 255, 0.1) !important;
            animation: mythicCardPulse 3s infinite, mythicCardFloat 4s ease-in-out infinite;
            overflow: visible;
        }
        
        .mythic-item::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, 
                #ff00ff, 
                #ffd700, 
                #00ffff, 
                #ff00ff
            );
            background-size: 300% 300%;
            border-radius: 15px;
            z-index: -1;
            opacity: 0.5;
            animation: mythicBorderFlow 4s linear infinite;
            filter: blur(10px);
        }
        
        .mythic-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 70%
            );
            background-size: 200% 200%;
            animation: mythicShine 3s infinite;
            pointer-events: none;
            border-radius: 12px;
        }
        
        @keyframes mythicCardPulse {
            0%, 100% {
                box-shadow: 
                    0 0 30px rgba(255, 0, 255, 0.6),
                    0 0 60px rgba(255, 0, 255, 0.3),
                    inset 0 0 30px rgba(255, 0, 255, 0.1);
            }
            50% {
                box-shadow: 
                    0 0 50px rgba(255, 0, 255, 1),
                    0 0 100px rgba(255, 0, 255, 0.6),
                    inset 0 0 50px rgba(255, 0, 255, 0.2);
            }
        }
        
        @keyframes mythicCardFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        @keyframes mythicBorderFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes mythicShine {
            0% { background-position: -200% -200%; }
            100% { background-position: 200% 200%; }
        }
        
        .mythic-item:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 
                0 0 50px rgba(255, 0, 255, 1),
                0 0 100px rgba(255, 0, 255, 0.8),
                inset 0 0 50px rgba(255, 0, 255, 0.3) !important;
        }
        
        .mythic-item .item-icon {
            font-size: 80px !important;
            filter: drop-shadow(0 0 20px rgba(255, 0, 255, 0.8));
            animation: mythicIconPulse 2s infinite;
        }
        
        @keyframes mythicIconPulse {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 20px rgba(255, 0, 255, 0.8));
            }
            50% { 
                transform: scale(1.1);
                filter: drop-shadow(0 0 30px rgba(255, 0, 255, 1));
            }
        }
        
        .mythic-item .item-name {
            background: linear-gradient(135deg, #ff00ff, #ffd700, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 22px !important;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            animation: mythicTextShimmer 3s infinite;
        }
        
        @keyframes mythicTextShimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }
        
        .mythic-item .item-description {
            color: #ff88ff !important;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }
        
        .mythic-item .price-essence {
            background: linear-gradient(135deg, #ffd700, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 24px !important;
            font-weight: bold;
            animation: mythicPricePulse 2s infinite;
        }
        
        @keyframes mythicPricePulse {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
            }
            50% { 
                transform: scale(1.1);
                filter: drop-shadow(0 0 20px rgba(255, 215, 0, 1));
            }
        }
        
        /* Mythic particles effect */
        .mythic-item {
            background-image: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, #ffd700, transparent),
                radial-gradient(1px 1px at 50% 50%, #ff00ff, transparent),
                radial-gradient(1px 1px at 80% 10%, #00ffff, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, #ffd700, transparent),
                radial-gradient(1px 1px at 15% 90%, #ff00ff, transparent);
            background-size: 200% 200%;
            background-position: 50% 50%;
            animation: mythicStars 10s linear infinite;
        }
        
        @keyframes mythicStars {
            0%, 100% { background-position: 0% 0%; }
            25% { background-position: 100% 0%; }
            50% { background-position: 100% 100%; }
            75% { background-position: 0% 100%; }
        }
        
        .item-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        
        .item-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .item-description {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 15px;
            text-align: center;
            min-height: 40px;
        }
        
        .item-price {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .price-currency {
            color: #ffd700;
        }
        
        .price-essence {
            color: #00ff88;
        }
        
        .item-buy-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: none;
            border-radius: 10px;
            color: #000;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .item-buy-button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.6);
        }
        
        /* Ad Item Special Styling */
        .ad-item {
            border-color: #00ff88 !important;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 200, 100, 0.05)) !important;
            animation: adPulse 2s infinite;
        }
        
        @keyframes adPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            }
            50% {
                box-shadow: 0 0 40px rgba(0, 255, 136, 0.6);
            }
        }
        
        .ad-item:hover {
            transform: translateY(-8px);
            border-color: #00ffaa !important;
        }
        
        .price-ad {
            color: #00ff88;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .ad-button {
            background: linear-gradient(135deg, #00ff88, #00cc66) !important;
            color: #000 !important;
            font-weight: bold;
            animation: adButtonPulse 1.5s infinite;
        }
        
        @keyframes adButtonPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        .ad-button:hover {
            background: linear-gradient(135deg, #00ffaa, #00dd77) !important;
            box-shadow: 0 5px 25px rgba(0, 255, 136, 0.8) !important;
        }
        
        .badge-free {
            background: #00ff88;
            color: #000;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* WARDROBE MODAL */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .wardrobe-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 600;
        }
        
        .wardrobe-modal.hidden {
            display: none;
        }
        
        .wardrobe-container {
            width: 90%;
            max-width: 1200px;
            height: 85%;
            background: linear-gradient(135deg, #1a0a2e 0%, #2e1a3e 100%);
            border: 3px solid #ff69b4;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .wardrobe-header {
            background: linear-gradient(90deg, #2e1a3e, #3e2a4e);
            border-bottom: 2px solid #ff69b4;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        .wardrobe-title {
            font-size: 32px;
            font-weight: 900;
            color: #ff69b4;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.8);
        }
        
        .wardrobe-subtitle {
            position: absolute;
            bottom: 5px;
            left: 30px;
            font-size: 14px;
            color: #aaa;
        }
        
        .wardrobe-close {
            width: 40px;
            height: 40px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .wardrobe-close:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1);
        }
        
        .wardrobe-preview {
            display: flex;
            gap: 40px;
            justify-content: center;
            padding: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #ff69b4;
        }
        
        .preview-character {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .preview-icon {
            font-size: 80px;
            padding: 20px;
            background: rgba(255, 105, 180, 0.1);
            border: 3px solid #ff69b4;
            border-radius: 20px;
            min-width: 150px;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.3);
        }
        
        .preview-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .preview-name {
            font-size: 18px;
            color: #ff69b4;
            font-weight: bold;
        }
        
        .wardrobe-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #ff69b4;
        }
        
        .wardrobe-tab {
            flex: 1;
            padding: 15px;
            background: transparent;
            border: none;
            border-right: 1px solid rgba(255, 105, 180, 0.3);
            color: #aaa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .wardrobe-tab:last-child {
            border-right: none;
        }
        
        .wardrobe-tab.active {
            background: rgba(255, 105, 180, 0.2);
            color: #ff69b4;
            border-bottom: 3px solid #ff69b4;
        }
        
        .wardrobe-tab:hover:not(.active) {
            background: rgba(255, 105, 180, 0.1);
            color: #fff;
        }
        
        .wardrobe-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .wardrobe-content::-webkit-scrollbar {
            width: 10px;
        }
        
        .wardrobe-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .wardrobe-content::-webkit-scrollbar-thumb {
            background: #ff69b4;
            border-radius: 5px;
        }
        
        .wardrobe-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .wardrobe-item {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
        }
        
        .wardrobe-item.owned {
            border-color: #ff69b4;
        }
        
        .wardrobe-item.equipped {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        .wardrobe-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .wardrobe-item:hover:not(.locked) {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(255, 105, 180, 0.4);
        }
        
        .wardrobe-item-icon {
            font-size: 60px;
            margin-bottom: 10px;
        }
        
        .wardrobe-item-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .wardrobe-item-status {
            font-size: 12px;
            margin-top: 10px;
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .status-equipped {
            background: #00ff88;
            color: #000;
        }
        
        .status-owned {
            background: #ff69b4;
            color: #fff;
        }
        
        .status-locked {
            background: #666;
            color: #aaa;
        }
        
        .wardrobe-empty {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }
        
        .wardrobe-empty-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }
        
        .wardrobe-empty-text {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        .wardrobe-empty-hint {
            font-size: 14px;
            color: #666;
        }
        
        .perk-slots-info {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(157, 78, 221, 0.2);
            border: 2px solid #9d4edd;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            color: #9d4edd;
        }
        
        .wardrobe-item-desc {
            font-size: 11px;
            color: #888;
            text-align: center;
            margin: 5px 0;
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        /* BATTLE PASS MODAL */
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        .battlepass-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 600;
        }
        
        .battlepass-modal.hidden {
            display: none;
        }
        
        .battlepass-container {
            width: 95%;
            max-width: 1400px;
            height: 90%;
            background: linear-gradient(135deg, #1a0a2e 0%, #2e1a3e 50%, #1a0a2e 100%);
            border: 3px solid #9d4edd;
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(157, 78, 221, 0.6);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .battlepass-header {
            background: linear-gradient(90deg, #2e1a3e, #3e2a4e, #2e1a3e);
            border-bottom: 3px solid #9d4edd;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }
        
        .battlepass-title {
            font-size: 36px;
            font-weight: 900;
            background: linear-gradient(90deg, #9d4edd, #c77dff, #9d4edd);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(157, 78, 221, 0.8);
        }
        
        .battlepass-season-info {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .season-tier {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        
        .tier-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tier-number {
            font-size: 32px;
            font-weight: bold;
            color: #9d4edd;
            text-shadow: 0 0 15px rgba(157, 78, 221, 0.8);
        }
        
        .tier-max {
            font-size: 16px;
            color: #666;
        }
        
        .season-xp {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .xp-bar-container {
            width: 250px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #9d4edd;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .xp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #9d4edd, #c77dff);
            box-shadow: 0 0 15px rgba(157, 78, 221, 0.8);
            transition: width 0.5s ease;
        }
        
        .xp-text {
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }
        
        .season-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 10px;
        }
        
        .season-status.premium {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .status-icon {
            font-size: 20px;
        }
        
        .status-text {
            font-size: 14px;
            font-weight: bold;
            color: #999;
        }
        
        .season-status.premium .status-text {
            color: #ffd700;
        }
        
        .battlepass-close {
            width: 40px;
            height: 40px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 50%;
            color: #ff4444;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .battlepass-close:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1);
        }
        
        .premium-unlock-banner {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.15));
            border-bottom: 2px solid #ffd700;
            padding: 20px 30px;
            animation: premiumPulse 3s infinite;
        }
        
        @keyframes premiumPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
        }
        
        .premium-unlock-banner.hidden {
            display: none;
        }
        
        .premium-banner-content {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .premium-banner-icon {
            font-size: 48px;
            animation: rotate 4s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .premium-banner-text {
            flex: 1;
        }
        
        .premium-banner-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .premium-banner-desc {
            font-size: 14px;
            color: #ffb700;
        }
        
        .premium-unlock-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ffd700, #ffb700);
            border: 3px solid #ffaa00;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }
        
        .premium-unlock-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.8);
        }
        
        .premium-price {
            font-size: 28px;
            font-weight: bold;
            color: #000;
        }
        
        .premium-unlock-text {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .battlepass-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .battlepass-content::-webkit-scrollbar {
            width: 12px;
        }
        
        .battlepass-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .battlepass-content::-webkit-scrollbar-thumb {
            background: #9d4edd;
            border-radius: 6px;
        }
        
        .battlepass-tier {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
            position: relative;
        }
        
        .tier-number-label {
            font-size: 18px;
            font-weight: bold;
            color: #9d4edd;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .tier-rewards {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .tier-line {
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, transparent, #9d4edd, transparent);
        }
        
        .tier-reward {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
            position: relative;
            min-height: 180px;
        }
        
        .tier-reward.free {
            border-color: #00aaff;
        }
        
        .tier-reward.premium {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.05);
        }
        
        .tier-reward.mythic {
            border-color: #ff00ff;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(157, 78, 221, 0.2));
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
            animation: mythicGlow 2s infinite;
        }
        
        @keyframes mythicGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 255, 0.8); }
        }
        
        .tier-reward.unlocked {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .tier-reward.claimed {
            opacity: 0.5;
        }
        
        .tier-reward:hover:not(.locked) {
            transform: translateY(-5px);
        }
        
        .reward-track-label {
            position: absolute;
            top: -10px;
            left: 10px;
            padding: 3px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .reward-track-label.free {
            background: #00aaff;
            color: #000;
        }
        
        .reward-track-label.premium {
            background: #ffd700;
            color: #000;
        }
        
        .reward-track-label.mythic {
            background: linear-gradient(90deg, #ff00ff, #9d4edd);
            color: #fff;
            animation: mythicShine 2s infinite;
        }
        
        @keyframes mythicShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }
        
        .reward-icon {
            font-size: 64px;
            margin-bottom: 10px;
        }
        
        .reward-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .reward-desc {
            font-size: 12px;
            color: #aaa;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .reward-status {
            margin-top: auto;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .reward-status.locked {
            background: #444;
            color: #888;
        }
        
        .reward-status.unlocked {
            background: #00ff88;
            color: #000;
            cursor: pointer;
        }
        
        .reward-status.claimed {
            background: #666;
            color: #999;
        }
        
        .reward-lock-icon {
            font-size: 32px;
            color: #666;
            margin-bottom: 10px;
        }
        
        /* Platform se√ßim ekranƒ± */
        #platformSelection, #biomeSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
        }
        
        #platformSelection.hidden, #biomeSelection.hidden {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        .platform-title {
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }
        
        /* PLASMA Title - Futuristic Cyberpunk Design */
        .plasma-title {
            font-size: 120px;
            font-weight: 900;
            letter-spacing: 20px;
            background: linear-gradient(45deg, #00ffdd, #ff00ff, #00ffdd, #ff00ff);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: plasmaRainbow 4s ease infinite, plasmaFloat 3s ease-in-out infinite, plasmaGlitch 8s infinite;
            position: relative;
            display: inline-block;
            filter: drop-shadow(0 0 20px rgba(0, 255, 221, 0.6)) drop-shadow(0 0 40px rgba(255, 0, 255, 0.4));
        }
        
        .plasma-title::before {
            content: 'PLASMA';
            position: absolute;
            left: 2px;
            top: 2px;
            background: linear-gradient(45deg, #ff00ff, #00ffdd);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0.3;
            animation: plasmaRainbow 4s ease infinite reverse;
            z-index: -1;
        }
        
        .plasma-title::after {
            content: '';
            position: absolute;
            left: -150%;
            top: 0;
            width: 150%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.8), 
                transparent);
            animation: plasmaScan 6s infinite;
            pointer-events: none;
        }
        
        @keyframes plasmaRainbow {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }
        
        @keyframes plasmaRainbow {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }
        
        @keyframes plasmaGlow {
            0%, 100% {
                text-shadow: 
                    0 0 10px rgba(0, 255, 221, 0.8),
                    0 0 20px rgba(0, 255, 221, 0.6),
                    0 0 30px rgba(0, 255, 221, 0.4),
                    0 0 40px rgba(0, 255, 221, 0.2);
            }
            50% {
                text-shadow: 
                    0 0 20px rgba(0, 255, 221, 1),
                    0 0 30px rgba(0, 255, 221, 0.8),
                    0 0 40px rgba(0, 255, 221, 0.6),
                    0 0 60px rgba(0, 255, 221, 0.4),
                    0 0 80px rgba(0, 255, 221, 0.2);
            }
        }
        
        @keyframes plasmaFloat {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        @keyframes plasmaGlitch {
            0%, 90%, 100% {
                transform: translate(0, 0);
                opacity: 0.5;
            }
            92% {
                transform: translate(-2px, 2px);
                opacity: 0.8;
            }
            94% {
                transform: translate(2px, -2px);
                opacity: 0.3;
            }
            96% {
                transform: translate(-1px, 1px);
                opacity: 0.6;
            }
        }
        
        @keyframes plasmaScan {
            0% {
                left: -150%;
            }
            100% {
                left: 150%;
            }
        }
        
        .platform-subtitle {
            font-size: 20px;
            color: #fff;
            margin-bottom: 50px;
        }
        
        .platform-buttons {
            display: flex;
            gap: 40px;
        }
        
        /* Biome buttons */
        .biome-buttons {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .biome-button {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .biome-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
            border-color: #00ffdd;
        }
        
        .biome-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }
        
        .biome-name {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .biome-desc {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 15px;
        }
        
        .biome-features {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        .biome-feature {
            font-size: 12px;
            color: #00ff88;
            text-align: left;
            padding: 3px 0;
        }
        
        .platform-button {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #00ff88;
            border-radius: 20px;
            padding: 40px 60px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .platform-button:hover {
            transform: scale(1.05);
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.6);
        }
        
        .platform-icon {
            font-size: 80px;
        }
        
        .platform-name {
            font-size: 32px;
            font-weight: bold;
            color: #fff;
        }
        
        /* Mobile controls - COMPLETELY FIXED LAYOUT */
        #mobileControls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 150;
            display: none;
        }
        
        #mobileControls.active {
            display: block;
        }
        
        /* Sol alt k√∂≈üe - Hareket joystick */
        .joystick-container {
            position: fixed;
            bottom: 3vh;
            left: 3vh;
            width: 20vh;
            height: 20vh;
            max-width: 140px;
            max-height: 140px;
            pointer-events: all;
            z-index: 151;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(50, 50, 50, 0.7);
            border: 3px solid rgba(0, 255, 136, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        
        .joystick-stick {
            position: absolute;
            width: 50%;
            height: 50%;
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: 2px solid #fff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0, 255, 136, 1);
            transition: none;
        }
        
        /* Saƒü alt k√∂≈üe - Hedefleme joystick */
        .aim-joystick-container {
            position: fixed;
            bottom: 3vh;
            right: 3vh;
            width: 20vh;
            height: 20vh;
            max-width: 140px;
            max-height: 140px;
            pointer-events: all;
            z-index: 151;
        }
        
        .aim-joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(50, 50, 50, 0.7);
            border: 3px solid rgba(255, 68, 68, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
        }
        
        .aim-joystick-stick {
            position: absolute;
            width: 50%;
            height: 50%;
            background: linear-gradient(135deg, #ff4444, #ff6666);
            border: 2px solid #fff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 68, 68, 1);
            transition: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
        }
        
        /* Saƒü orta - Dash butonu */
        .dash-button {
            position: fixed;
            top: 50%;
            right: 3vh;
            transform: translateY(-50%);
            width: 12vh;
            height: 12vh;
            max-width: 90px;
            max-height: 90px;
            background: linear-gradient(135deg, #ffa500, #ffcc00);
            border: 3px solid #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: #fff;
            box-shadow: 0 0 25px rgba(255, 165, 0, 0.7);
            pointer-events: all;
            user-select: none;
            -webkit-user-select: none;
            z-index: 151;
        }
        
        .dash-button:active {
            transform: translateY(-50%) scale(0.9);
            box-shadow: 0 0 35px rgba(255, 165, 0, 1);
        }
        
        /* Dil butonu - Mobilde √ºst sol */
        @media screen and (max-width: 900px) and (orientation: landscape) {
            #languageToggle {
                position: fixed;
                top: 1.5vh;
                left: 1.5vh;
                right: auto;
                padding: 1vh 2vh;
                font-size: 14px;
                z-index: 200;
            }
            
            /* Silah aƒüacƒ± butonu - Mobilde √ºst saƒü */
            #weaponTreeButton {
                position: fixed;
                top: 1.5vh;
                right: 1.5vh;
                bottom: auto;
                padding: 1vh 2vh;
                font-size: 14px;
                z-index: 200;
            }
            
            /* Stats - √úst orta */
            #stats {
                position: fixed !important;
                top: 1.5vh !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                font-size: 14px !important;
                padding: 1vh 2vh !important;
                max-width: 50vw !important;
            }
            
            /* Build menu - K√º√ß√ºlt */
            #buildMenu {
                padding: 1.5vh 2vh !important;
                max-width: 80vw !important;
            }
            
            .build-option {
                padding: 1vh 1.5vh !important;
                font-size: 13px !important;
                margin: 0.5vh !important;
            }
            
            /* Notification - √ústte ortalanmƒ±≈ü */
            #notification {
                top: 8vh !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                max-width: 60vw !important;
                font-size: 14px !important;
                padding: 1.5vh 2vh !important;
            }
            
            /* Game Over ekranƒ± - Mobil i√ßin optimize */
            #gameOver {
                padding: 2vh !important;
            }
            
            .game-over-title {
                font-size: 32px !important;
                margin-bottom: 1.5vh !important;
            }
            
            .game-over-stats {
                padding: 1.5vh !important;
                max-width: 80vw !important;
            }
            
            .stat-item {
                font-size: 14px !important;
                padding: 0.8vh 0 !important;
            }
            
            .restart-button {
                padding: 1.5vh 3vh !important;
                font-size: 16px !important;
                margin-top: 2vh !important;
            }
            
            /* Platform se√ßimi */
            .platform-title {
                font-size: 32px !important;
            }
            
            .platform-subtitle {
                font-size: 16px !important;
            }
            
            .platform-button {
                padding: 2vh 3vh !important;
            }
            
            .platform-icon {
                font-size: 48px !important;
            }
            
            .platform-name {
                font-size: 20px !important;
            }
            
            /* Weapon selection - Mobil optimize */
            .weapon-selection-title {
                font-size: 28px !important;
            }
            
            .weapon-selection-subtitle {
                font-size: 14px !important;
            }
            
            .weapon-trees-container {
                flex-direction: column !important;
                gap: 2vh !important;
                max-height: 70vh !important;
                overflow-y: auto !important;
            }
            
            .weapon-tree {
                width: 70vw !important;
                padding: 2vh !important;
            }
            
            .weapon-tree-icon {
                font-size: 36px !important;
            }
            
            .weapon-tree-name {
                font-size: 18px !important;
            }
            
            .weapon-tree-description {
                font-size: 12px !important;
            }
            
            /* Base placement hint */
            #basePlacementText {
                font-size: 24px !important;
            }
            
            #basePlacementHint {
                font-size: 13px !important;
            }
        }
        
        /* Silah aƒüacƒ± g√∂sterici butonu */
        #weaponTreeButton {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 15px;
            padding: 15px 25px;
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            transition: all 0.3s;
        }
        
        #weaponTreeButton:hover {
            transform: scale(1.05);
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
        }
        
        /* Silah aƒüacƒ± modal */
        #weaponTreeModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 250;
            padding: 40px;
        }
        
        #weaponTreeModal.active {
            display: flex;
        }
        
        .weapon-tree-title {
            font-size: 42px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
        }
        
        .weapon-progression {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 800px;
            width: 100%;
        }
        
        .weapon-item {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px 20px;
            transition: all 0.3s;
        }
        
        .weapon-item.unlocked {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .weapon-item.current {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .weapon-item-icon {
            font-size: 32px;
            margin-right: 15px;
        }
        
        .weapon-item-info {
            flex: 1;
        }
        
        .weapon-item-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
        }
        
        .weapon-item-stats {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .weapon-item-requirement {
            font-size: 14px;
            color: #00ff88;
            font-weight: bold;
        }
        
        .weapon-item-requirement.locked {
            color: #ff4444;
        }
        
        .close-modal-button {
            margin-top: 30px;
            background: linear-gradient(135deg, #ff4444, #ff6666);
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            transition: all 0.3s;
        }
        
        .close-modal-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
        }
        
        /* Shop modal */
        #shopModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            padding: 20px;
        }
        
        #shopModal.active {
            display: flex;
        }
        
        .shop-title {
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }
        
        .shop-subtitle {
            font-size: 20px;
            color: #fff;
            margin-bottom: 30px;
        }
        
        .shop-gold {
            font-size: 32px;
            color: #ffd700;
            margin-bottom: 30px;
            font-weight: bold;
        }
        
        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            max-width: 900px;
            width: 100%;
            margin-bottom: 30px;
        }
        
        .shop-item {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .shop-item:hover {
            transform: scale(1.05);
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        
        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
        }
        
        .shop-item.disabled:hover {
            transform: none;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: none;
        }
        
        .shop-item-icon {
            font-size: 48px;
        }
        
        .shop-item-name {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            text-align: center;
        }
        
        .shop-item-price {
            font-size: 24px;
            color: #ffd700;
            font-weight: bold;
        }
        
        /* Power-up display */
        #powerUpDisplay {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 200;
        }
        
        .active-powerup {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .powerup-icon {
            font-size: 20px;
        }
        
        .powerup-timer {
            font-size: 12px;
            color: #00ff88;
            font-weight: bold;
        }
        
        /* Leaderboard modal */
        #leaderboardModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 350;
            padding: 20px;
        }
        
        #leaderboardModal.active {
            display: flex;
        }
        
        .leaderboard-title {
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }
        
        #leaderboardList {
            width: 100%;
            max-width: 600px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .leaderboard-item {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s;
        }
        
        .leaderboard-item:hover {
            transform: translateX(5px);
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .leaderboard-item.top-three {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .leaderboard-rank {
            font-size: 32px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .leaderboard-info {
            flex: 1;
        }
        
        .leaderboard-name {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .leaderboard-stats {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 3px;
        }
        
        .leaderboard-date {
            font-size: 12px;
            color: #666;
        }
        
        .leaderboard-buttons {
            display: flex;
            gap: 15px;
        }
        
        .leaderboard-button {
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .leaderboard-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }
        
        .leaderboard-button.danger {
            background: linear-gradient(135deg, #ff4444, #ff6666);
            color: #fff;
        }
        
        /* Base customization modal */
        #baseCustomizationModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 350;
            padding: 20px;
            overflow-y: auto;
        }
        
        #baseCustomizationModal.active {
            display: flex;
        }
        
        .base-custom-title {
            font-size: 48px;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.8);
        }
        
        .base-custom-subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 30px;
        }
        
        .base-custom-sections {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        
        .base-custom-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 15px;
            padding: 20px;
        }
        
        .base-custom-section-title {
            font-size: 24px;
            font-weight: bold;
            color: #3b82f6;
            margin-bottom: 15px;
        }
        
        .base-skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .base-skin-item {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid #444;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .base-skin-item:hover {
            transform: scale(1.05);
            border-color: #3b82f6;
        }
        
        .base-skin-item.selected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .base-skin-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .base-skin-preview {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            border: 3px solid currentColor;
        }
        
        .base-skin-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .base-skin-cost {
            font-size: 12px;
            color: #ffd700;
        }
        
        .base-upgrades-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }
        
        .base-upgrade-item {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid #444;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .base-upgrade-item:hover {
            transform: scale(1.05);
            border-color: #3b82f6;
        }
        
        .base-upgrade-item.owned {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        
        .base-upgrade-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .base-upgrade-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }
        
        .base-upgrade-name {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .base-upgrade-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        
        .base-upgrade-cost {
            font-size: 14px;
            color: #ffd700;
            font-weight: bold;
        }
        
        /* Boss Rush button */
        #bossRushButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff4444, #8b0000);
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            z-index: 100;
            transition: all 0.3s;
        }
        
        #bossRushButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
        }
        
        #bossRushButton.active {
            background: linear-gradient(135deg, #8b0000, #ff4444);
            animation: bossRushPulse 1s infinite;
        }
        
        @keyframes bossRushPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 68, 68, 1); }
        }
        
        @keyframes recordPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                text-shadow: 0 0 50px rgba(255, 215, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.1);
                text-shadow: 0 0 80px rgba(255, 215, 0, 1), 0 0 150px rgba(255, 215, 0, 1);
            }
        }
        
        @keyframes confettiFall {
            0% { 
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* Paused indicator */
        #pausedIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            z-index: 500;
            pointer-events: none;
            display: none;
        }
        
        /* Base customization button */
        #baseCustomButton {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            z-index: 100;
            display: none;
            transition: all 0.3s;
        }
        
        #baseCustomButton.visible {
            display: block;
        }
        
        #baseCustomButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8);
        }
        
        /* Leaderboard butonu - Oyun UI'da */
        
        /* Oyun sonu ekranƒ± */
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #gameOver.active {
            display: flex;
        }
        
        /* Silah se√ßim ekranƒ± */
        #weaponSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        
        #weaponSelection.hidden {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        .weapon-selection-title {
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
            margin-bottom: 20px;
        }
        
        .weapon-selection-subtitle {
            font-size: 20px;
            color: #ffffff;
            margin-bottom: 50px;
        }
        
        .weapon-trees-container {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
        }
        
        .weapon-tree {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            width: 280px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        .weapon-tree:hover {
            transform: scale(1.05);
            border-color: #00ffdd;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.6);
        }
        
        .weapon-tree-icon {
            font-size: 64px;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .weapon-tree-name {
            font-size: 28px;
            font-weight: bold;
            color: #00ff88;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .weapon-tree-description {
            font-size: 14px;
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .weapon-tree-progression {
            border-top: 2px solid #333;
            padding-top: 15px;
        }
        
        .weapon-tier {
            font-size: 13px;
            color: #888;
            margin: 8px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .weapon-tier-name {
            color: #00ff88;
            font-weight: bold;
        }
        
        .game-over-title {
            font-size: 72px;
            font-weight: bold;
            color: #ef4444;
            text-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }
        
        .game-over-subtitle {
            font-size: 24px;
            color: #fbbf24;
            margin-bottom: 40px;
        }
        
        .stats-container {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ff88;
            border-radius: 20px;
            padding: 40px 60px;
            margin-bottom: 40px;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.5);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 20px;
            color: #ffffff;
            min-width: 400px;
        }
        
        .stat-label {
            color: #00ff88;
            font-weight: bold;
        }
        
        .stat-value {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
        }
        
        .restart-button {
            background: linear-gradient(135deg, #00ff88, #00ffdd);
            border: none;
            border-radius: 15px;
            padding: 20px 60px;
            font-size: 24px;
            font-weight: bold;
            color: #000000;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            transition: all 0.3s;
        }
        
        .restart-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.9);
        }
        
        .continue-ad-button {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            border: 3px solid #ff8800;
            border-radius: 15px;
            padding: 20px 60px;
            font-size: 24px;
            font-weight: bold;
            color: #000000;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            transition: all 0.3s;
            margin-bottom: 15px;
            animation: continueButtonPulse 2s infinite;
        }
        
        @keyframes continueButtonPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 50px rgba(255, 215, 0, 1);
            }
        }
        
        .continue-ad-button:hover {
            transform: scale(1.1) !important;
            box-shadow: 0 0 60px rgba(255, 215, 0, 1) !important;
        }
        
        /* Spinning Icon Animation */
        .spinning-icon {
            display: inline-block;
            animation: spin 3s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Lucky Wheel Modal */
        .lucky-wheel-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        
        .lucky-wheel-modal.active {
            display: flex;
        }
        
        .lucky-wheel-modal:not(.hidden) {
            display: flex;
        }
        
        .lucky-wheel-container {
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            border: 3px solid #ff00ff;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
            position: relative;
        }
        
        .lucky-wheel-title {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin: 0 0 20px 0;
            background: linear-gradient(135deg, #ff00ff, #ffd700, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
            animation: titleShimmer 3s infinite;
        }
        
        @keyframes titleShimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .lucky-wheel-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: 2px solid #ff00ff;
            border-radius: 50%;
            background: rgba(255, 0, 255, 0.2);
            color: #ff00ff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }
        
        .lucky-wheel-close:hover {
            background: rgba(255, 0, 255, 0.4);
            transform: rotate(90deg) scale(1.1);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }
        
        .close-icon {
            display: block;
            line-height: 1;
        }
        
        .wheel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .wheel-info {
            text-align: center;
            width: 100%;
        }
        
        .spins-left {
            font-size: 18px;
            color: #ff00ff;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .daily-spins {
            font-size: 14px;
            color: #00ff88;
        }
        
        .wheel-wrapper {
            position: relative;
            margin: 20px 0;
        }
        
        .wheel-pointer {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            z-index: 10;
            animation: pointerBounce 1s infinite;
        }
        
        @keyframes pointerBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(5px); }
        }
        
        #luckyWheelCanvas {
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6);
        }
        
        /* Win Display Overlay */
        .wheel-win-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.7) 100%);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
        }
        
        .wheel-win-display.show {
            animation: winPopIn 0.5s ease-out forwards, winPulse 1s ease-in-out 0.5s infinite;
            opacity: 1;
        }
        
        @keyframes winPopIn {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(-180deg);
                opacity: 0;
            }
            60% {
                transform: translate(-50%, -50%) scale(1.1) rotate(10deg);
            }
            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        @keyframes winPulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
            }
        }
        
        .win-icon {
            font-size: 80px;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
            animation: iconBounce 0.6s ease-in-out infinite;
        }
        
        @keyframes iconBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .win-text {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 1);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        
        .win-amount {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            animation: amountGlow 1s ease-in-out infinite;
        }
        
        @keyframes amountGlow {
            0%, 100% {
                filter: brightness(1);
                text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }
            50% {
                filter: brightness(1.5);
                text-shadow: 0 0 50px rgba(255, 215, 0, 1);
            }
        }
        
        .wheel-buttons {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .wheel-spin-button {
            flex: 1;
            padding: 20px;
            border: 3px solid;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .wheel-spin-button .button-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        
        .wheel-spin-button .button-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .wheel-spin-button .button-subtitle {
            font-size: 12px;
            opacity: 0.7;
        }
        
        .free-spin {
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .free-spin:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
        }
        
        .ad-spin {
            border-color: #ffd700;
            color: #ffd700;
            animation: adSpinPulse 2s infinite;
        }
        
        @keyframes adSpinPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }
        
        .ad-spin:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255, 215, 0, 1) !important;
        }
        
        .wheel-spin-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .rewards-legend {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            width: 100%;
        }
        
        .legend-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .legend-item {
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 13px;
            border: 2px solid;
        }
        
        .legend-item.common {
            border-color: #888;
            color: #aaa;
        }
        
        .legend-item.uncommon {
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .legend-item.rare {
            border-color: #0099ff;
            color: #0099ff;
        }
        
        .legend-item.legendary {
            border-color: #ff00ff;
            color: #ff00ff;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2), rgba(255, 0, 255, 0.1));
            animation: legendaryGlow 2s infinite;
        }
        
        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 255, 1); }
        }
        
        /* Yapƒ± men√ºs√º */
        #buildMenu {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 15;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        #buildMenu.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .build-option {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            width: 150px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .build-option:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            border-color: #00ffdd;
        }
        
        .build-option.selected {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ffdd;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }
        
        .build-option-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        
        .build-option-name {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }
        
        .build-option-desc {
            font-size: 12px;
            color: #aaa;
        }
        
        /* Global Leaderboard Preview Scrollbar */
        #globalLeaderboardPreview::-webkit-scrollbar {
            width: 6px;
        }
        
        #globalLeaderboardPreview::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        
        #globalLeaderboardPreview::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            border-radius: 3px;
        }
        
        #globalLeaderboardPreview::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #f5576c, #f093fb);
        }
    </style>
    
    <!-- CrazyGames SDK -->
    <script src="https://sdk.crazygames.com/crazygames-sdk-v3.js"></script>
    
    <!-- Firebase SDK v9 (compat) - No module errors -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    
    <script>
        // Initialize Firebase (compat version) with error handling
        try {
            if (typeof firebase === 'undefined') {
                console.warn('‚ö†Ô∏è Firebase SDK not loaded - global leaderboard will not work');
                window.firebaseDB = null;
                window.firebaseApp = null;
            } else {
                const firebaseConfig = {
                    apiKey: "AIzaSyBrFQpnpiPqiFRs3N9DId7yQDszVStZng",
                    authDomain: "plasma---tower-defence.firebaseapp.com",
                    databaseURL: "https://plasma---tower-defence-default-rtdb.firebaseio.com",
                    projectId: "plasma---tower-defence",
                    storageBucket: "plasma---tower-defence.firebasestorage.app",
                    messagingSenderId: "644204779221",
                    appId: "1:644204779221:web:5fb3d4a12f344b72f2f45c"
                };
                
                // Initialize Firebase
                const firebaseApp = firebase.initializeApp(firebaseConfig);
                const firebaseDatabase = firebase.database();
                
                // Make Firebase available globally (compat API)
                window.firebaseDB = firebaseDatabase;
                window.firebaseApp = firebaseApp;
                
                console.log('üî• Firebase initialized successfully');
            }
        } catch (error) {
            console.error('‚ùå Firebase initialization failed:', error);
            window.firebaseDB = null;
            window.firebaseApp = null;
        }
    </script>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Biome se√ßim ekranƒ± -->
        <!-- MAIN MENU -->
        <div id="mainMenu">
            <!-- Animated Background -->
            <div class="menu-bg-particles" id="menuBgParticles"></div>
            
            <div class="main-menu-header">
                <div class="plasma-title">PLASMA</div>
                <div class="main-menu-version">v2.0 - Tower Defense</div>
            </div>
            
            <div class="main-menu-content">
                <!-- Left Panel: Player Info -->
                <div class="main-menu-left">
                    <div class="player-card">
                        <div class="player-card-header">
                            <div class="player-avatar">üë§</div>
                            <div class="player-info">
                                <div class="player-name" id="mainMenuPlayerName">Player</div>
                                <div class="player-level">Level: <span id="accountLevel">1</span></div>
                            </div>
                        </div>
                        <div class="player-stats">
                            <div class="player-stat">
                                <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                                    <span class="stat-icon">üèÜ</span>
                                    <span class="stat-text">Best</span>
                                    <span class="stat-value" id="menuBestScore">0</span>
                                </div>
                            </div>
                            <div class="player-stat">
                                <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                                    <span class="stat-icon">‚ú®</span>
                                    <span class="stat-text">Essence</span>
                                    <span class="stat-value" id="specialCurrency">0</span>
                                </div>
                            </div>
                            <div class="player-stat">
                                <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                                    <span class="stat-icon">‚öîÔ∏è</span>
                                    <span class="stat-text">Kills</span>
                                    <span class="stat-value" id="totalKillsMenu">0</span>
                                </div>
                            </div>
                            <div class="player-stat">
                                <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                                    <span class="stat-icon">üéÆ</span>
                                    <span class="stat-text">Games</span>
                                    <span class="stat-value" id="gamesPlayedCard">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Battle Pass Card -->
                    <div class="battlepass-card" onclick="showBattlePass()">
                        <div class="bp-card-background">
                            <div class="bp-particles" id="bpParticles"></div>
                        </div>
                        <div class="bp-card-content">
                            <div class="bp-card-header">
                                <div class="bp-card-icon">üèÜ</div>
                                <div class="bp-card-title">BATTLE PASS</div>
                                <div class="bp-card-status" id="bpCardStatus">üîí FREE</div>
                            </div>
                            <div class="bp-card-tier">
                                <div class="bp-tier-label">TIER</div>
                                <div class="bp-tier-number" id="bpCardTier">0</div>
                                <div class="bp-tier-max">/ 50</div>
                            </div>
                            <div class="bp-card-xp">
                                <div class="bp-xp-bar">
                                    <div class="bp-xp-fill" id="bpCardXPBar"></div>
                                </div>
                                <div class="bp-xp-text"><span id="bpCardXP">0</span> / <span id="bpCardMaxXP">1000</span> XP</div>
                            </div>
                            <div class="bp-card-cta">Click to view rewards ‚Üí</div>
                        </div>
                    </div>
                    
                    <!-- Weekly Challenges -->
                    <div class="menu-section">
                        <div class="section-title">üìÖ WEEKLY CHALLENGES</div>
                        <div class="challenges-list" id="weeklyChallengesList">
                            <div class="challenge-item">
                                <div class="challenge-name">üéØ Marksman</div>
                                <div class="challenge-desc">Kill 500 enemies</div>
                                <div class="challenge-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 45%"></div>
                                    </div>
                                    <div class="progress-text">225/500</div>
                                </div>
                                <div class="challenge-reward">Reward: 100 ‚ú®</div>
                            </div>
                            <div class="challenge-item">
                                <div class="challenge-name">üè∞ Architect</div>
                                <div class="challenge-desc">Build 50 structures</div>
                                <div class="challenge-progress">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 60%"></div>
                                    </div>
                                    <div class="progress-text">30/50</div>
                                </div>
                                <div class="challenge-reward">Reward: 75 ‚ú®</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Center: Play Button -->
                <div class="main-menu-center">
                    <button class="play-button" onclick="showBiomeSelection()">
                        <div class="play-button-icon">‚ñ∂</div>
                        <div class="play-button-text">PLAY</div>
                    </button>
                    
                    <!-- Global Leaderboard Preview Card -->
                    <div style="background: rgba(0, 0, 0, 0.6); border: 2px solid #f093fb; border-radius: 15px; padding: 15px; box-shadow: 0 0 20px rgba(240, 147, 251, 0.3); max-height: 200px; overflow: hidden; display: flex; flex-direction: column;">
                        <div style="font-size: 18px; font-weight: bold; color: #f093fb; text-shadow: 0 0 10px #f093fb; margin-bottom: 10px; text-align: center;">
                            üåç GLOBAL TOP 10
                        </div>
                        <div id="globalLeaderboardPreview" style="overflow-y: auto; flex: 1; padding-right: 5px;">
                            <div style="text-align: center; color: #aaa; padding: 20px; font-size: 14px;">
                                Loading...
                            </div>
                        </div>
                    </div>
                    
                    <!-- Menu Buttons -->
                    <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-top: 20px; padding: 0 20px;">
                        <button class="menu-button" style="border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); flex: 0 0 auto;" onclick="showStore()">
                            <span class="menu-button-icon">üè™</span>
                            <span class="menu-button-text">Store</span>
                        </button>
                        <button class="menu-button" style="border-color: #ff69b4; box-shadow: 0 0 15px rgba(255, 105, 180, 0.3); flex: 0 0 auto;" onclick="showWardrobe()">
                            <span class="menu-button-icon">üëî</span>
                            <span class="menu-button-text">Wardrobe</span>
                        </button>
                        <button class="menu-button lucky-wheel-button" style="border-color: #ff00ff; box-shadow: 0 0 15px rgba(255, 0, 255, 0.3); flex: 0 0 auto;" onclick="showLuckyWheel()">
                            <span class="menu-button-icon spinning-icon">üé°</span>
                            <span class="menu-button-text">Lucky Wheel</span>
                        </button>
                    </div>
                </div>
                
                <!-- Right Panel: Changelog -->
                <div class="main-menu-right">
                    <div class="menu-section">
                        <div class="section-title">üìã CHANGELOG</div>
                        <div class="changelog-content" id="changelogContent">
                            <div class="changelog-entry">
                                <div class="changelog-version">v2.1 - Visual Overhaul</div>
                                <div class="changelog-date">January 20, 2026</div>
                                <ul class="changelog-list">
                                    <li>‚ú® 9 Premium Weapon Skins</li>
                                    <li>üé® Futuristic Main Menu Design</li>
                                    <li>üåå Cyberpunk Background Animations</li>
                                    <li>‚ö° Enhanced PLASMA Title Effects</li>
                                    <li>üî´ Stroke-Based Weapon Rendering</li>
                                    <li>üí´ Animated Gradient Weapons</li>
                                    <li>üéØ Weapon Skin System Complete</li>
                                    <li>üñºÔ∏è UI/UX Improvements</li>
                                </ul>
                            </div>
                            <div class="changelog-entry">
                                <div class="changelog-version">v2.0 - Major Update</div>
                                <div class="changelog-date">January 17, 2026</div>
                                <ul class="changelog-list">
                                    <li>‚ú® Dynamic Shop System</li>
                                    <li>üëπ Mini-Boss System</li>
                                    <li>üí• Enhanced Damage</li>
                                    <li>üî• Combo System</li>
                                    <li>üèÜ Achievements</li>
                                    <li>‚öîÔ∏è Jedi Barracks</li>
                                </ul>
                            </div>
                            <div class="changelog-entry">
                                <div class="changelog-version">v1.5</div>
                                <div class="changelog-date">January 2026</div>
                                <ul class="changelog-list">
                                    <li>üåå 3 Biomes</li>
                                    <li>üå≥ Weapon Trees</li>
                                    <li>üé® Cosmetics</li>
                                    <li>üè∞ Base Custom</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quick Stats -->
                    <div class="menu-section">
                        <div class="section-title">üìä STATS</div>
                        <div class="quick-stats">
                            <div class="quick-stat-item">
                                <span class="quick-stat-label">Playtime:</span>
                                <span class="quick-stat-value" id="totalPlaytime">0h 0m</span>
                            </div>
                            <div class="quick-stat-item">
                                <span class="quick-stat-label">Highest Wave:</span>
                                <span class="quick-stat-value" id="highestWave">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- STORE MODAL -->
        <div id="storeModal" class="store-modal hidden">
            <div class="store-container">
                <!-- Header -->
                <div class="store-header">
                    <div class="store-title">üè™ PLASMA STORE</div>
                    <div class="store-currency">
                        <span class="currency-icon">‚ú®</span>
                        <span class="currency-amount" id="storeCurrencyDisplay">0</span>
                        <span class="currency-label">Essence</span>
                    </div>
                    <button class="store-close" onclick="closeStore()">‚úï</button>
                </div>
                
                <!-- Tabs -->
                <div class="store-tabs">
                    <button class="store-tab active" onclick="switchStoreTab('essence')">
                        <span class="tab-icon">‚ú®</span>
                        <span class="tab-text">Buy Essence</span>
                    </button>
                    <button class="store-tab" onclick="switchStoreTab('skins')">
                        <span class="tab-icon">üé®</span>
                        <span class="tab-text">Character Skins</span>
                    </button>
                    <button class="store-tab" onclick="switchStoreTab('weapons')">
                        <span class="tab-icon">‚öîÔ∏è</span>
                        <span class="tab-text">Weapon Skins</span>
                    </button>
                    <button class="store-tab" onclick="switchStoreTab('perks')">
                        <span class="tab-icon">‚ö°</span>
                        <span class="tab-text">Perks</span>
                    </button>
                </div>
                
                <!-- Content -->
                <div class="store-content" id="storeContent">
                    <!-- Items will be generated here -->
                </div>
            </div>
        </div>
        
        <!-- WARDROBE MODAL -->
        <div id="wardrobeModal" class="wardrobe-modal hidden">
            <div class="wardrobe-container">
                <!-- Header -->
                <div class="wardrobe-header">
                    <div class="wardrobe-title">üëî WARDROBE</div>
                    <div class="wardrobe-subtitle">Customize Your Look</div>
                    <button class="wardrobe-close" onclick="closeWardrobe()">‚úï</button>
                </div>
                
                <!-- Preview Section -->
                <div class="wardrobe-preview">
                    <div class="preview-character">
                        <div class="preview-icon" id="previewCharacterIcon">üë§</div>
                        <div class="preview-label">Character</div>
                        <div class="preview-name" id="previewCharacterName">Default</div>
                    </div>
                    <div class="preview-character">
                        <div class="preview-icon" id="previewWeaponIcon">üî´</div>
                        <div class="preview-label">Weapon</div>
                        <div class="preview-name" id="previewWeaponName">Default</div>
                    </div>
                </div>
                
                <!-- Tabs -->
                <div class="wardrobe-tabs">
                    <button class="wardrobe-tab active" onclick="switchWardrobeTab('skins')">
                        <span class="tab-icon">üé®</span>
                        <span class="tab-text">Character Skins</span>
                    </button>
                    <button class="wardrobe-tab" onclick="switchWardrobeTab('weapons')">
                        <span class="tab-icon">‚öîÔ∏è</span>
                        <span class="tab-text">Weapon Skins</span>
                    </button>
                    <button class="wardrobe-tab" onclick="switchWardrobeTab('perks')">
                        <span class="tab-icon">‚ö°</span>
                        <span class="tab-text">Perks</span>
                    </button>
                </div>
                
                <!-- Content -->
                <div class="wardrobe-content" id="wardrobeContent">
                    <!-- Items will be generated here -->
                </div>
            </div>
        </div>
        
        
        <!-- LUCKY WHEEL MODAL -->
        <div id="luckyWheelModal" class="lucky-wheel-modal hidden">
            <div class="lucky-wheel-container">
                <div class="modal-header">
                    <h2 class="lucky-wheel-title">üé° LUCKY WHEEL</h2>
                    <button class="lucky-wheel-close" onclick="closeLuckyWheel()">
                        <span class="close-icon">‚úï</span>
                    </button>
                </div>
                
                <div class="wheel-section">
                    <div class="wheel-info">
                        <div class="spins-left">
                            üì∫ Watch ad for 1 spin
                        </div>
                        <div class="daily-spins" id="dailySpinsInfo">
                            Free spins today: <span id="freeSpinsLeft">3</span>/3
                        </div>
                    </div>
                    
                    <!-- The Wheel -->
                    <div class="wheel-wrapper">
                        <div class="wheel-pointer">‚ñº</div>
                        <canvas id="luckyWheelCanvas" width="400" height="400"></canvas>
                        
                        <!-- Win Display Overlay -->
                        <div class="wheel-win-display" id="wheelWinDisplay">
                            <div class="win-icon" id="winIcon">üéÅ</div>
                            <div class="win-text" id="winText">YOU WON!</div>
                            <div class="win-amount" id="winAmount">+100‚ú®</div>
                        </div>
                    </div>
                    
                    <!-- Spin Buttons -->
                    <div class="wheel-buttons">
                        <button class="wheel-spin-button free-spin" id="freeSpinButton" onclick="spinWheel(false)">
                            <div class="button-icon">üéÅ</div>
                            <div class="button-text">FREE SPIN</div>
                            <div class="button-subtitle">3 per day</div>
                        </button>
                        <button class="wheel-spin-button ad-spin" onclick="spinWheel(true)">
                            <div class="button-icon">üì∫</div>
                            <div class="button-text">AD SPIN</div>
                            <div class="button-subtitle">Unlimited</div>
                        </button>
                    </div>
                    
                    <!-- Possible Rewards -->
                    <div class="rewards-legend">
                        <div class="legend-title">üéÅ POSSIBLE REWARDS</div>
                        <div class="legend-items">
                            <div class="legend-item common">50‚ú® (35%)</div>
                            <div class="legend-item common">100‚ú® (25%)</div>
                            <div class="legend-item uncommon">200‚ú® (15%)</div>
                            <div class="legend-item uncommon">Random Skin (10%)</div>
                            <div class="legend-item rare">500‚ú® (8%)</div>
                            <div class="legend-item rare">Random Perk (5%)</div>
                            <div class="legend-item legendary">1000‚ú® JACKPOT! (2%)</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- BATTLE PASS MODAL -->
        <div id="battlePassModal" class="battlepass-modal hidden">
            <div class="battlepass-container">
                <!-- Header -->
                <div class="battlepass-header">
                    <div class="battlepass-title">üèÜ SEASON 1 BATTLE PASS</div>
                    <div class="battlepass-season-info">
                        <div class="season-tier">
                            <span class="tier-label">YOUR TIER:</span>
                            <span class="tier-number" id="battlePassTier">0</span>
                            <span class="tier-max">/ 50</span>
                        </div>
                        <div class="season-xp">
                            <div class="xp-bar-container">
                                <div class="xp-bar-fill" id="battlePassXPBar"></div>
                            </div>
                            <div class="xp-text">
                                <span id="battlePassCurrentXP">0</span> / <span id="battlePassRequiredXP">1000</span> XP
                            </div>
                        </div>
                        <div class="season-status" id="battlePassStatus">
                            <span class="status-icon">üîí</span>
                            <span class="status-text">FREE TRACK</span>
                        </div>
                    </div>
                    <button class="battlepass-close" onclick="closeBattlePass()">‚úï</button>
                </div>
                
                <!-- Unlock Premium Button -->
                <div class="premium-unlock-banner" id="premiumBanner">
                    <div class="premium-banner-content">
                        <div class="premium-banner-icon">‚≠ê</div>
                        <div class="premium-banner-text">
                            <div class="premium-banner-title">Unlock Premium Battle Pass!</div>
                            <div class="premium-banner-desc">Get ALL rewards from both tracks + Dragon Soul + 3000‚ú® at Tier 50!</div>
                        </div>
                        <button class="premium-unlock-button" onclick="unlockPremiumBattlePass()">
                            <span class="premium-price" id="premiumAdProgress">üì∫ 0/10 Ads</span>
                            <span class="premium-unlock-text">WATCH AD</span>
                        </button>
                    </div>
                </div>
                
                <!-- Rewards Track -->
                <div class="battlepass-content" id="battlePassContent">
                    <!-- Tiers will be generated here -->
                </div>
            </div>
        </div>
        
        <div id="biomeSelection" class="hidden">
            <div class="platform-title">
                <div class="plasma-title">PLASMA</div>
            </div>
            <div class="platform-subtitle">Choose Your Battlefield</div>
            <div class="biome-buttons">
                <div class="biome-button" onclick="selectBiome('proxima')">
                    <div class="biome-icon">üåå</div>
                    <div class="biome-name">PROXIMA STATION</div>
                    <div class="biome-desc">Deep space outpost</div>
                    <div class="biome-features">
                        <div class="biome-feature">‚ö° Normal Speed</div>
                        <div class="biome-feature">‚öñÔ∏è Balanced</div>
                        <div class="biome-feature">üéÆ Neon Grids</div>
                    </div>
                </div>
                <div class="biome-button" onclick="selectBiome('kepler')">
                    <div class="biome-icon">üî•</div>
                    <div class="biome-name">KEPLER DESERT</div>
                    <div class="biome-desc">Scorched planet</div>
                    <div class="biome-features">
                        <div class="biome-feature">üêå -10% Enemy Speed</div>
                        <div class="biome-feature">üòå Easy Mode</div>
                        <div class="biome-feature">üå™Ô∏è Dust Storms</div>
                    </div>
                </div>
                <div class="biome-button" onclick="selectBiome('titan')">
                    <div class="biome-icon">‚ùÑÔ∏è</div>
                    <div class="biome-name">TITAN CRYO</div>
                    <div class="biome-desc">Frozen moon</div>
                    <div class="biome-features">
                        <div class="biome-feature">‚ö° +20% Enemy Speed</div>
                        <div class="biome-feature">üò∞ Hard Mode</div>
                        <div class="biome-feature">üßä Crystalline Ice</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Platform se√ßim ekranƒ± -->
        <div id="platformSelection" class="hidden">
            <div class="platform-title" id="platformTitle">
                <div class="plasma-title">PLASMA</div>
            </div>
            <div class="platform-subtitle" id="platformSubtitle">Choose your device type</div>
            <div class="platform-buttons">
                <div class="platform-button" onclick="selectPlatform('desktop')">
                    <div class="platform-icon">üñ•Ô∏è</div>
                    <div class="platform-name" id="desktopText">Desktop</div>
                </div>
                <div class="platform-button" onclick="selectPlatform('mobile')">
                    <div class="platform-icon">üì±</div>
                    <div class="platform-name" id="mobileText">Mobile</div>
                </div>
            </div>
        </div>
        
        <!-- Mobile kontroller -->
        <div id="mobileControls">
            <!-- Sol: Hareket joystick'i -->
            <div class="joystick-container" id="joystickContainer">
                <div class="joystick-base"></div>
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
            
            <!-- Saƒü: Hedefleme ve saldƒ±rƒ± joystick'i -->
            <div class="aim-joystick-container" id="aimJoystickContainer">
                <div class="aim-joystick-base"></div>
                <div class="aim-joystick-stick" id="aimJoystickStick">‚öîÔ∏è</div>
            </div>
            
            <!-- Dash butonu (yetenek a√ßƒ±lƒ±nca g√∂r√ºn√ºr) -->
            <div class="dash-button" id="dashButton" style="display: none;">üí®</div>
        </div>
        
        <!-- Dil deƒüi≈ütirme butonu -->
        <button id="languageToggle" onclick="toggleLanguage()">üåê EN</button>
        
        <!-- Silah aƒüacƒ± g√∂sterici -->
        <button id="weaponTreeButton" onclick="showWeaponTreeModal()" style="display: none;">
            üå≥ <span id="weaponTreeButtonText">Weapon Tree</span>
        </button>
        
        <!-- Silah aƒüacƒ± modal -->
        <div id="weaponTreeModal">
            <div class="weapon-tree-title" id="weaponTreeModalTitle">üå≥ YOUR WEAPON PROGRESSION</div>
            <div class="weapon-progression" id="weaponProgressionList"></div>
            <button class="close-modal-button" onclick="closeWeaponTreeModal()">
                <span id="closeModalText">Close</span>
            </button>
        </div>
        
        <!-- Shop modal -->
        <div id="shopModal">
            <div class="shop-title">üí∞ DYNAMIC SHOP</div>
            <div class="shop-subtitle">Random items each visit!</div>
            <div class="shop-gold">
                üí∞ <span id="shopGoldAmount">0</span> Gold
            </div>
            <div class="shop-items" id="shopList">
                <!-- Dynamic items generated here -->
            </div>
            <button class="close-modal-button" onclick="closeShop()">Close</button>
        </div>
        
        <!-- Leaderboard modal -->
        <div id="leaderboardModal">
            <div class="leaderboard-title" id="leaderboardTitleText">
                üèÜ LEADERBOARD üèÜ
            </div>
            
            <!-- Leaderboard Tabs -->
            <div style="display: flex; gap: 10px; margin: 0 20px 20px 20px; justify-content: center;">
                <button id="personalLeaderboardTab" class="leaderboard-tab active" onclick="switchLeaderboardTab('personal')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                    üìä PERSONAL
                </button>
                <button id="globalLeaderboardTab" class="leaderboard-tab" onclick="switchLeaderboardTab('global')" style="flex: 1; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 2px solid #667eea; border-radius: 10px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                    üåç GLOBAL TOP 100
                </button>
            </div>
            
            <div id="leaderboardList"></div>
            
            <div class="leaderboard-buttons">
                <button class="leaderboard-button" onclick="closeLeaderboard()">
                    <span id="closeLeaderboardText">Kapat</span>
                </button>
                <button class="leaderboard-button danger" onclick="clearLeaderboard()" id="clearLeaderboardBtn">
                    <span id="clearLeaderboardText">Tabloyu Temizle</span>
                </button>
            </div>
        </div>
        
        <!-- Base customization button -->
        <button id="baseCustomButton" onclick="showBaseCustomization()">
            üè∞ <span id="baseCustomButtonText">Customize Base</span>
        </button>
        
        <!-- Boss Rush button -->
        <button id="bossRushButton" onclick="toggleBossRush()">
            üëπ <span id="bossRushButtonText">Boss Rush Mode</span>
        </button>
        
        <!-- Base customization modal -->
        <div id="baseCustomizationModal">
            <div class="base-custom-title">üè∞ BASE CUSTOMIZATION üè∞</div>
            <div class="base-custom-subtitle" id="baseCustomSubtitle">Customize your base with skins and upgrades</div>
            
            <div class="base-custom-sections">
                <!-- Skins -->
                <div class="base-custom-section">
                    <div class="base-custom-section-title">üé® Base Skins</div>
                    <div class="base-skins-grid" id="baseSkinsGrid"></div>
                </div>
                
                <!-- Upgrades -->
                <div class="base-custom-section">
                    <div class="base-custom-section-title">‚ö° Base Upgrades</div>
                    <div class="base-upgrades-grid" id="baseUpgradesGrid"></div>
                </div>
            </div>
            
            <button class="close-modal-button" onclick="closeBaseCustomization()">
                <span id="closeBaseCustomText">Close</span>
            </button>
        </div>
        
        <!-- Power-up display -->
        <div id="powerUpDisplay"></div>
        
        <!-- Silah se√ßim ekranƒ± -->
        <div id="weaponSelection" class="hidden">
            <div class="weapon-selection-title" id="weaponSelectionTitle">‚öîÔ∏è SELECT WEAPON TREE ‚öîÔ∏è</div>
            <div class="weapon-selection-subtitle" id="weaponSelectionSubtitle">Choose your playstyle - Each tree unlocks different abilities</div>
            
            <div class="weapon-trees-container">
                <!-- Yakƒ±n Mesafe Aƒüacƒ± -->
                <div class="weapon-tree" onclick="selectWeaponTree('melee')">
                    <div class="weapon-tree-icon">‚öîÔ∏è</div>
                    <div class="weapon-tree-name" id="meleeTreeName">MELEE</div>
                    <div class="weapon-tree-description" id="meleeTreeDesc">
                        Powerful close combat weapons. High damage, fast attacks, special abilities.
                    </div>
                    <div class="weapon-tree-progression">
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Wooden Sword</span> ‚Üí Start
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Iron Sword</span> ‚Üí Power +
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Battle Axe</span> ‚Üí Area Damage
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Steel Sword</span> ‚Üí Speed Bonus
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Twin Blades</span> ‚Üí Double Strike
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">‚ö° Beam Sword</span> ‚Üí LEGENDARY
                        </div>
                    </div>
                </div>
                
                <!-- Uzak Mesafe Aƒüacƒ± -->
                <div class="weapon-tree" onclick="selectWeaponTree('ranged')">
                    <div class="weapon-tree-icon">üèπ</div>
                    <div class="weapon-tree-name" id="rangedTreeName">RANGED</div>
                    <div class="weapon-tree-description" id="rangedTreeDesc">
                        Long-range attacks. Safe distance, piercing arrows, explosive projectiles.
                    </div>
                    <div class="weapon-tree-progression">
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Hunting Bow</span> ‚Üí Start
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Steel Bow</span> ‚Üí Fast Shot
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Heavy Crossbow</span> ‚Üí High Damage
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Firearm</span> ‚Üí Fast Bullet
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Laser Rifle</span> ‚Üí Pierce Beam
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">üî´ Plasma Cannon</span> ‚Üí LEGENDARY
                        </div>
                    </div>
                </div>
                
                <!-- Hibrit Aƒüacƒ± -->
                <div class="weapon-tree" onclick="selectWeaponTree('hybrid')">
                    <div class="weapon-tree-icon">üî•</div>
                    <div class="weapon-tree-name" id="hybridTreeName">HYBRID</div>
                    <div class="weapon-tree-description" id="hybridTreeDesc">
                        Balanced approach. Medium range, dash ability, fire damage, versatile gameplay.
                    </div>
                    <div class="weapon-tree-progression">
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Torch</span> ‚Üí Start
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Flame Sword</span> ‚Üí Burn Damage
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Fire Axe</span> ‚Üí Dash Ability
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Burning Chain</span> ‚Üí Chain Attack
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">Meteor Hammer</span> ‚Üí Explosion
                        </div>
                        <div class="weapon-tier">
                            <span class="weapon-tier-name">üåü Solar Spear</span> ‚Üí LEGENDARY
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Oyun sonu ekranƒ± -->
        <div id="gameOver">
            <div class="game-over-title" id="gameOverTitle">GAME OVER</div>
            <div class="game-over-subtitle" id="gameOverReason"></div>
            <div class="stats-container">
                <div class="stat-row">
                    <span class="stat-label">üèÜ SKOR:</span>
                    <span class="stat-value" id="finalScore">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚öîÔ∏è ENEMIES KILLED:</span>
                    <span class="stat-value" id="finalKills">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üåä WAVE REACHED:</span>
                    <span class="stat-value" id="finalWave">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚≠ê CHARACTER LEVEL:</span>
                    <span class="stat-value" id="finalLevel">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üóº BUILDINGS BUILT:</span>
                    <span class="stat-value" id="finalBuildings">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚öîÔ∏è Sƒ∞LAH:</span>
                    <span class="stat-value" id="finalWeapon">-</span>
                </div>
            </div>
            <button class="continue-ad-button" id="continueAdButton" onclick="continueWithAd()" style="display: none;">
                üì∫ WATCH AD TO CONTINUE
                <div style="font-size: 12px; opacity: 0.8;">Revive with full health (1 time only)</div>
            </button>
            <button class="restart-button" onclick="location.reload()">üîÑ YENƒ∞DEN BA≈ûLA</button>
        </div>
        
        <!-- √ús kurulum ekranƒ± -->
        <div id="basePlacement" class="hidden">
            <div id="basePlacementText">PLACE YOUR BASE</div>
            <div id="basePlacementHint">
                Click on the map to place your base!<br>
                Enemies will attack it - Defend!
            </div>
        </div>
        
        <div id="ui">
            <div class="stat">
                <div id="healthLabel">Health:</div>
                <div id="healthBar">
                    <div id="healthFill" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat" style="color: #ffd700;">üë§ <span id="playerNameDisplay">Player</span></div>
            <div class="stat" style="color: #ff4444;">üèÜ <span id="bestLabel">Best:</span> <span id="highScoreDisplay">0</span></div>
            <div class="stat">üí∞ <span id="goldDisplay">0</span></div>
            <div class="stat"><span id="waveLabel">Wave:</span> <span id="wave">1</span></div>
            <div class="stat" id="weaponInfo">Weapon: Wooden Sword</div>
            <div class="stat"><span id="levelLabel">Level:</span> <span id="level">1</span></div>
            <div class="stat" style="font-size: 11px; color: #aaa; line-height: 1.3;" id="controlsHint">
                WASD - Move | Click/Space - Attack<br>
                TAB - Cycle Target | T - Threats | P - Pause
            </div>
        </div>
        
        <!-- Yapƒ± in≈üa men√ºs√º -->
        <div id="buildMenu">
            <div class="build-option" onclick="selectBuilding('tower')">
                <div class="build-option-icon">üóº</div>
                <div class="build-option-name">TOWER</div>
                <div class="build-option-desc">Shoots enemies</div>
            </div>
            <div class="build-option" onclick="selectBuilding('wall')">
                <div class="build-option-icon">üß±</div>
                <div class="build-option-name">WALL</div>
                <div class="build-option-desc">Blocks enemies</div>
            </div>
            <div class="build-option" onclick="selectBuilding('farm')">
                <div class="build-option-icon">üåæ</div>
                <div class="build-option-name">FARM</div>
                <div class="build-option-desc">Generates XP</div>
            </div>
            <div class="build-option" onclick="selectBuilding('barracks')" id="barracksButton" style="display: none;">
                <div class="build-option-icon">‚öîÔ∏è</div>
                <div class="build-option-name">BARRACKS</div>
                <div class="build-option-desc">Spawns Jedi ally</div>
            </div>
        </div>
        
        <!-- Orta √ºst skor -->
        <div id="scoreDisplay">
            <div id="scoreValue">0</div>
            <div id="scoreLabel">SCORE</div>
            <div id="scoreParticles"></div>
        </div>
        
        <!-- Level ilerleme barƒ± -->
        <div id="levelProgress">
            <div id="levelProgressFill"></div>
            <div id="levelProgressText">0 / 100 XP</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CRAZYGAMES SDK INTEGRATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let crazySDK = null;
        let sdkInitialized = false;
        let audioMuted = false;
        
        // Initialize SDK
        function initCrazyGamesSDK() {
            try {
                if (typeof window.CrazyGames !== 'undefined' && window.CrazyGames.CrazySDK) {
                    crazySDK = window.CrazyGames.CrazySDK;
                    sdkInitialized = true;
                    console.log('‚úÖ CrazyGames SDK initialized');
                    
                    // Game is ready
                    if (crazySDK.game && crazySDK.game.gameplayStart) {
                        crazySDK.game.gameplayStart();
                    }
                } else {
                    console.warn('‚ö†Ô∏è CrazyGames SDK not found - running in standalone mode');
                    sdkInitialized = false;
                }
            } catch (error) {
                console.error('‚ùå SDK initialization error:', error);
                sdkInitialized = false;
            }
        }
        
        // Mute/Unmute audio
        function muteGameAudio() {
            audioMuted = true;
            // Add your audio muting code here if you have sounds
            console.log('üîá Audio muted for ad');
        }
        
        function unmuteGameAudio() {
            audioMuted = false;
            // Add your audio unmuting code here if you have sounds
            console.log('üîä Audio unmuted');
        }
        
        // Pause game for ads
        function pauseGameForAd() {
            if (gameState === 'playing') {
                gameState = 'paused';
            }
            muteGameAudio();
            console.log('‚è∏Ô∏è Game paused for ad');
        }
        
        // Resume game after ads
        function resumeGameAfterAd() {
            if (gameState === 'paused') {
                gameState = 'playing';
            }
            unmuteGameAudio();
            console.log('‚ñ∂Ô∏è Game resumed after ad');
        }
        
        // Show Midgame Ad (Interstitial)
        function showCrazyGamesMidgameAd() {
            if (!sdkInitialized || !crazySDK) {
                console.log('‚ÑπÔ∏è SDK not available, skipping ad');
                return;
            }
            
            try {
                console.log('üì∫ Requesting midgame ad...');
                
                const callbacks = {
                    adFinished: () => {
                        console.log('‚úÖ Midgame ad finished');
                        resumeGameAfterAd();
                    },
                    adError: (error) => {
                        console.error('‚ùå Midgame ad error:', error);
                        resumeGameAfterAd(); // Resume even on error
                    },
                    adStarted: () => {
                        console.log('‚ñ∂Ô∏è Midgame ad started');
                        pauseGameForAd();
                    }
                };
                
                // Use correct SDK method
                if (crazySDK.ad && crazySDK.ad.requestAd) {
                    crazySDK.ad.requestAd('midgame', callbacks);
                } else {
                    console.warn('‚ö†Ô∏è SDK.ad.requestAd not available');
                    resumeGameAfterAd();
                }
            } catch (error) {
                console.error('‚ùå Error requesting midgame ad:', error);
                resumeGameAfterAd();
            }
        }
        
        // Show Rewarded Ad
        function showCrazyGamesRewardedAd(rewardCallback) {
            if (!sdkInitialized || !crazySDK) {
                console.log('‚ÑπÔ∏è SDK not available, granting reward anyway (dev mode)');
                // Still need to resume game and give reward
                setTimeout(() => {
                    if (rewardCallback) rewardCallback();
                    resumeGameAfterAd();
                }, 500); // Small delay to simulate ad
                return;
            }
            
            try {
                console.log('üì∫ Requesting rewarded ad...');
                
                const callbacks = {
                    adFinished: () => {
                        console.log('‚úÖ Rewarded ad finished - granting reward');
                        resumeGameAfterAd();
                        if (rewardCallback) rewardCallback();
                    },
                    adError: (error) => {
                        console.error('‚ùå Rewarded ad error:', error);
                        resumeGameAfterAd();
                        // Still grant reward on error (user-friendly)
                        if (rewardCallback) rewardCallback();
                        showNotification('‚ö†Ô∏è Ad failed to load\nReward granted anyway', 2000);
                    },
                    adStarted: () => {
                        console.log('‚ñ∂Ô∏è Rewarded ad started');
                    pauseGameForAd();
                }
            };
            
            // Use correct SDK method
            if (crazySDK.ad && crazySDK.ad.requestAd) {
                crazySDK.ad.requestAd('rewarded', callbacks);
            } else {
                console.warn('‚ö†Ô∏è SDK.ad.requestAd not available');
                resumeGameAfterAd();
                if (rewardCallback) rewardCallback();
                showNotification('‚ö†Ô∏è Ad system not ready\nReward granted anyway', 2000);
            }
        } catch (error) {
            console.error('‚ùå Error requesting rewarded ad:', error);
            resumeGameAfterAd();
            if (rewardCallback) rewardCallback();
            showNotification('‚ö†Ô∏è Ad error\nReward granted anyway', 2000);
        }
        }
        
        // Initialize SDK when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                initCrazyGamesSDK();
            }, 100);
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Canvas already initialized above with SDK
        
        canvas.width = 1400;
        canvas.height = 900;
        
        // Oyun deƒüi≈ükenleri
        const ARENA_SIZE = 3000;
        let camera = { x: 0, y: 0 };
        let score = 0;
        let wave = 1;
        let mutationLevel = 0; // Increases every 10 waves
        let enemyHPMultiplier = 1;
        let enemySpeedMultiplier = 1;
        let enemyDamageMultiplier = 1;
        let kills = 0;
        let gold = 0; // Para sistemi
        
        // Power-up sistemi
        let powerUps = [];
        const POWERUP_TYPES = {
            health: { icon: '‚ù§Ô∏è', color: '#ff4444', value: 50, duration: 0 },
            speed: { icon: '‚ö°', color: '#ffff00', multiplier: 2, duration: 10000 },
            damage: { icon: 'üí•', color: '#ff8800', multiplier: 2, duration: 10000 },
            shield: { icon: 'üõ°Ô∏è', color: '#4444ff', duration: 5000 },
            goldRush: { icon: 'üí∞', color: '#ffd700', multiplier: 3, duration: 20000 },
            fireRate: { icon: 'üî•', color: '#ff4500', multiplier: 1.5, duration: 10000 }
        };
        
        // Aktif power-up'lar
        let activePowerUps = {
            speed: 0,
            damage: 0,
            shield: 0,
            goldRush: 0,
            fireRate: 0
        };
        
        // Random event sistemi
        let currentEvent = null;
        let eventTimer = 0;
        const EVENTS = {
            lightning: {
                name: '‚ö° Lightning Storm',
                nameEn: '‚ö° Lightning Storm',
                nameTr: '‚ö° Yƒ±ldƒ±rƒ±m Fƒ±rtƒ±nasƒ±',
                duration: 300, // 5 saniye
                damagePerTick: 10,
                tickRate: 30 // Her 0.5 saniye
            },
            bloodMoon: {
                name: 'üåô Blood Moon',
                nameEn: 'üåô Blood Moon',
                nameTr: 'üåô Kanlƒ± Ay',
                duration: 0, // Dalga boyunca
                enemyMultiplier: 1.5,
                xpMultiplier: 2
            },
            goldRush: {
                name: 'üí∞ Gold Rush',
                nameEn: 'üí∞ Gold Rush',
                nameTr: 'üí∞ Altƒ±n √áƒ±lgƒ±nlƒ±ƒüƒ±',
                duration: 0, // Dalga boyunca
                goldMultiplier: 3
            },
            supplyDrop: {
                name: 'üéÅ Supply Drop',
                nameEn: 'üéÅ Supply Drop',
                nameTr: 'üéÅ ƒ∞kmal D√º≈ü√ºrme',
                instant: true,
                powerUpCount: 5
            },
            meteorShower: {
                name: '‚òÑÔ∏è Meteor Shower',
                nameEn: '‚òÑÔ∏è Meteor Shower',
                nameTr: '‚òÑÔ∏è Meteor Yaƒümuru',
                duration: 300,
                meteorInterval: 60
            }
        };
        
        // Player profil sistemi
        let playerProfile = {
            name: '',
            highScore: 0,
            highWave: 0,
            totalKills: 0,
            totalGamesPlayed: 0,
            bossesKilled: 0,
            totalGoldEarned: 0,
            favoriteWeapon: '',
            playtime: 0, // saniye
            lastPlayed: null
        };
        
        // Profil y√ºkle
        function loadPlayerProfile() {
            const saved = localStorage.getItem('plasmaGamePlayerProfile');
            if (saved) {
                try {
                    playerProfile = JSON.parse(saved);
                } catch (e) {
                    playerProfile = {
                        name: '',
                        highScore: 0,
                        highWave: 0,
                        totalKills: 0,
                        totalGamesPlayed: 0,
                        bossesKilled: 0,
                        totalGoldEarned: 0,
                        favoriteWeapon: '',
                        playtime: 0,
                        lastPlayed: null
                    };
                }
            }
            
            // ƒ∞lk kez a√ßƒ±yorsa isim sor
            if (!playerProfile.name) {
                setTimeout(() => {
                    const name = prompt('üéÆ Welcome to PLASMA!\n\nWhat\'s your name?', 'Player' + Math.floor(Math.random() * 1000));
                    if (name && name.trim()) {
                        playerProfile.name = name.trim();
                        savePlayerProfile();
                        showNotification(`‚ö° Welcome to PLASMA, ${playerProfile.name}!`, 3000);
                    }
                }, 500);
            }
        }
        
        // Profil kaydet
        function savePlayerProfile() {
            localStorage.setItem('plasmaGamePlayerProfile', JSON.stringify(playerProfile));
        }
        
        // Profil g√ºncelle (oyun bitince)
        function updatePlayerProfile() {
            playerProfile.totalGamesPlayed++;
            playerProfile.totalKills += kills;
            playerProfile.totalGoldEarned += gold;
            playerProfile.lastPlayed = new Date().toLocaleDateString();
            
            // High score
            if (score > playerProfile.highScore) {
                playerProfile.highScore = score;
                showNotification('üéâ NEW PERSONAL BEST! üéâ', 3000);
            }
            
            // High wave
            if (wave > playerProfile.highWave) {
                playerProfile.highWave = wave;
            }
            
            savePlayerProfile();
        }
        
        // Base customization sistemi
        let baseCustomization = {
            skin: 'default', // default, medieval, scifi, crystal, golden
            autoTurret: false,
            forceField: false,
            teslaTower: false,
            missileLauncher: false
        };
        
        const BASE_SKINS = {
            default: {
                name: 'Default',
                nameTr: 'Varsayƒ±lan',
                color: '#3b82f6',
                cost: 0,
                unlocked: true
            },
            medieval: {
                name: 'Medieval Castle',
                nameTr: 'Orta√ßaƒü Kalesi',
                color: '#78716c',
                cost: 500,
                unlocked: false
            },
            scifi: {
                name: 'Sci-Fi Reactor',
                nameTr: 'Bilim-Kurgu Reakt√∂r',
                color: '#06b6d4',
                cost: 1000,
                unlocked: false
            },
            crystal: {
                name: 'Crystal Core',
                nameTr: 'Kristal √áekirdek',
                color: '#a855f7',
                cost: 1500,
                unlocked: false
            },
            golden: {
                name: 'Golden Fortress',
                nameTr: 'Altƒ±n Kale',
                color: '#fbbf24',
                cost: 3000,
                unlocked: false
            }
        };
        
        const BASE_UPGRADES = {
            autoTurret: {
                name: 'Auto-Turret',
                nameTr: 'Otomatik Taret',
                description: 'Fires at nearby enemies',
                descriptionTr: 'Yakƒ±ndaki d√º≈ümanlara ate≈ü eder',
                cost: 800,
                damage: 20,
                range: 300,
                cooldown: 60
            },
            forceField: {
                name: 'Force Field',
                nameTr: 'G√º√ß Alanƒ±',
                description: 'Slows enemies in range',
                descriptionTr: 'Menzildeki d√º≈ümanlarƒ± yava≈ülatƒ±r',
                cost: 600,
                range: 200,
                slowAmount: 0.5
            },
            teslaTower: {
                name: 'Tesla Coil',
                nameTr: 'Tesla Bobini',
                description: 'Chain lightning to enemies',
                descriptionTr: 'D√º≈ümanlara zincir ≈üim≈üek',
                cost: 1000,
                damage: 15,
                range: 250,
                chainCount: 3
            },
            missileLauncher: {
                name: 'Missile Launcher',
                nameTr: 'F√ºze Fƒ±rlatƒ±cƒ±',
                description: 'Area damage explosions',
                descriptionTr: 'Alan hasarlƒ± patlamalar',
                cost: 1200,
                damage: 80,
                range: 400,
                cooldown: 180
            }
        };
        
        // Base customization y√ºkle
        function loadBaseCustomization() {
            const saved = localStorage.getItem('plasmaGameBaseCustomization');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    baseCustomization = loaded;
                } catch (e) {
                    baseCustomization = {
                        skin: 'default',
                        autoTurret: false,
                        forceField: false,
                        teslaTower: false,
                        missileLauncher: false
                    };
                }
            }
        }
        
        // Base customization kaydet
        function saveBaseCustomization() {
            localStorage.setItem('plasmaGameBaseCustomization', JSON.stringify(baseCustomization));
        }
        
        // Boss Rush Mode
        let bossRushMode = false;
        let bossRushWave = 0;
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BIOME Sƒ∞STEMƒ∞ - 3 UZAY B√ñLGESƒ∞
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let currentBiome = 'proxima'; // varsayƒ±lan
        
        const BIOMES = {
            proxima: {
                name: 'Proxima Station',
                nameTr: 'Proxima ƒ∞stasyonu',
                groundColor: '#0f0f1e', // Koyu uzay mavisi
                gridColor: '#1a1a2e', // Grid √ßizgileri
                skyColor: 'rgba(59, 130, 246, 0.1)', // Hafif mavi glow
                decorColors: ['#2d5016', '#8B4513', '#696969'],
                enemySpeedMult: 1.0,
                description: 'Deep space outpost with neon grids',
                descriptionTr: 'Neon ƒ±zgaralƒ± derin uzay √ºss√º',
                accentColor: '#3b82f6', // Neon mavi
                glowColor: 'rgba(59, 130, 246, 0.3)'
            },
            kepler: {
                name: 'Kepler Desert',
                nameTr: 'Kepler √á√∂l√º',
                groundColor: '#1a0f0a', // Koyu kƒ±zƒ±l
                gridColor: '#2d1810', // Kƒ±zƒ±l grid
                skyColor: 'rgba(249, 115, 22, 0.15)', // Turuncu hava
                decorColors: ['#8B4513', '#DEB887', '#CD853F'],
                enemySpeedMult: 0.9, // Kum fƒ±rtƒ±nasƒ±nda yava≈ü
                description: 'Scorched planet with dust storms',
                descriptionTr: 'Kum fƒ±rtƒ±nalƒ± kavrulan gezegen',
                accentColor: '#f97316', // Turuncu
                glowColor: 'rgba(249, 115, 22, 0.3)'
            },
            titan: {
                name: 'Titan Cryo',
                nameTr: 'Titan Donmu≈ü',
                groundColor: '#0a1420', // Daha koyu turkuaz-mavi
                gridColor: '#1a3a4a', // Turkuaz grid
                skyColor: 'rgba(0, 255, 221, 0.08)', // Hafif turkuaz hava
                decorColors: ['#00ffdd', '#40e0d0', '#48d1cc'],
                enemySpeedMult: 1.2, // Buzda kayarak hƒ±zlƒ±
                description: 'Frozen moon with crystalline ice',
                descriptionTr: 'Kristal buzlu donmu≈ü ay',
                accentColor: '#00ffdd', // Turkuaz accent
                glowColor: 'rgba(0, 255, 221, 0.4)'
            }
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MAIN MENU FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function showBiomeSelection() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('biomeSelection').classList.remove('hidden');
        }
        
        function returnToMainMenu() {
            document.getElementById('biomeSelection').classList.add('hidden');
            document.getElementById('platformSelection').classList.add('hidden');
            document.getElementById('weaponSelection').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }
        
        function updateMainMenuStats() {
            // Player name
            const nameEl = document.getElementById('mainMenuPlayerName');
            if (nameEl && playerProfile.name) {
                nameEl.textContent = playerProfile.name;
            }
            
            // Best score
            const bestScoreEl = document.getElementById('menuBestScore');
            if (bestScoreEl) {
                bestScoreEl.textContent = playerProfile.highScore;
            }
            
            // Special currency
            const specialCurrency = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0);
            const currencyEl = document.getElementById('specialCurrency');
            if (currencyEl) {
                currencyEl.textContent = specialCurrency;
            }
            
            // Total kills - PERSISTENT (not from challenges, they reset weekly)
            const totalKills = parseInt(localStorage.getItem('plasmaTotalKills') || 0);
            const killsEl = document.getElementById('totalKillsMenu');
            if (killsEl) {
                killsEl.textContent = totalKills;
            }
            
            // Account level (based on total kills)
            const accountLevel = Math.floor(totalKills / 100) + 1;
            const levelEl = document.getElementById('accountLevel');
            if (levelEl) {
                levelEl.textContent = accountLevel;
            }
            
            // Games played
            const gamesPlayed = parseInt(localStorage.getItem('plasmaGamesPlayed') || 0);
            const gamesEl = document.getElementById('gamesPlayed');
            if (gamesEl) {
                gamesEl.textContent = gamesPlayed;
            }
            
            const gamesCardEl = document.getElementById('gamesPlayedCard');
            if (gamesCardEl) {
                gamesCardEl.textContent = gamesPlayed;
            }
            
            // Highest wave
            const highestWave = parseInt(localStorage.getItem('plasmaHighestWave') || 0);
            const waveEl = document.getElementById('highestWave');
            if (waveEl) {
                waveEl.textContent = highestWave;
            }
            
            console.log('Main menu stats updated:', {
                essence: specialCurrency,
                kills: totalKills,
                level: accountLevel,
                games: gamesPlayed,
                highestWave: highestWave
            });
            
            // Update Battle Pass card
            updateBattlePassCard();
        }
        
        // Update Battle Pass card on main menu
        function updateBattlePassCard() {
            // Calculate XP required for current tier
            const xpRequired = getXPRequiredForTier(battlePassData.tier);
            
            // Update tier
            document.getElementById('bpCardTier').textContent = battlePassData.tier;
            
            // Update XP
            document.getElementById('bpCardXP').textContent = battlePassData.xp;
            document.getElementById('bpCardMaxXP').textContent = xpRequired;
            const xpPercent = (battlePassData.xp / xpRequired) * 100;
            document.getElementById('bpCardXPBar').style.width = xpPercent + '%';
            
            // Update status
            const statusEl = document.getElementById('bpCardStatus');
            if (battlePassData.premium) {
                statusEl.classList.add('premium');
                statusEl.textContent = '‚≠ê PREMIUM';
            } else {
                statusEl.classList.remove('premium');
                statusEl.textContent = 'üîí FREE';
            }
            
            // Generate particles if not exists
            const particleContainer = document.getElementById('bpParticles');
            if (particleContainer && particleContainer.children.length === 0) {
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'bp-particle';
                    particle.style.width = (5 + Math.random() * 10) + 'px';
                    particle.style.height = particle.style.width;
                    particle.style.left = (Math.random() * 100) + '%';
                    particle.style.top = (Math.random() * 100) + '%';
                    particle.style.animationDelay = (Math.random() * 3) + 's';
                    particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                    particleContainer.appendChild(particle);
                }
            }
        }
        
        // Generate animated background particles
        function generateMenuBackground() {
            const container = document.getElementById('menuBgParticles');
            if (!container) return;
            
            // Create glowing grid lines (cyberpunk style)
            for (let i = 0; i < 8; i++) {
                const gridLine = document.createElement('div');
                gridLine.style.cssText = `
                    position: absolute;
                    height: 2px;
                    width: 100%;
                    left: 0;
                    top: ${i * 12.5}%;
                    background: linear-gradient(90deg, transparent, rgba(0, 255, 221, 0.3), transparent);
                    animation: gridPulse ${4 + Math.random() * 3}s ease-in-out infinite;
                    animation-delay: ${Math.random() * 2}s;
                `;
                container.appendChild(gridLine);
            }
            
            // Create vertical scan lines
            for (let i = 0; i < 6; i++) {
                const scanLine = document.createElement('div');
                scanLine.style.cssText = `
                    position: absolute;
                    width: 2px;
                    height: 100%;
                    left: ${i * 16.66}%;
                    top: 0;
                    background: linear-gradient(180deg, transparent, rgba(255, 0, 255, 0.2), transparent);
                    animation: scanPulse ${5 + Math.random() * 3}s ease-in-out infinite;
                    animation-delay: ${Math.random() * 3}s;
                `;
                container.appendChild(scanLine);
            }
            
            // Create floating energy orbs
            for (let i = 0; i < 20; i++) {
                const orb = document.createElement('div');
                const size = 5 + Math.random() * 10;
                const color = i % 2 === 0 ? '0, 255, 221' : '255, 0, 255';
                orb.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size}px;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(${color}, 0.8), transparent);
                    box-shadow: 0 0 ${size * 2}px rgba(${color}, 0.6);
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    animation: floatOrb ${15 + Math.random() * 10}s linear infinite;
                    animation-delay: ${Math.random() * 10}s;
                    pointer-events: none;
                `;
                container.appendChild(orb);
            }
            
            // Create data streams
            for (let i = 0; i < 5; i++) {
                const stream = document.createElement('div');
                stream.style.cssText = `
                    position: absolute;
                    width: 2px;
                    height: 100px;
                    left: ${Math.random() * 100}%;
                    top: -100px;
                    background: linear-gradient(180deg, transparent, rgba(0, 255, 221, 0.8), transparent);
                    box-shadow: 0 0 10px rgba(0, 255, 221, 0.5);
                    animation: dataStream ${3 + Math.random() * 2}s linear infinite;
                    animation-delay: ${Math.random() * 5}s;
                `;
                container.appendChild(stream);
            }
            
            // Add CSS animations if not already present
            if (!document.getElementById('menuBgAnimations')) {
                const style = document.createElement('style');
                style.id = 'menuBgAnimations';
                style.textContent = `
                    @keyframes gridPulse {
                        0%, 100% { opacity: 0.3; }
                        50% { opacity: 0.8; }
                    }
                    @keyframes scanPulse {
                        0%, 100% { opacity: 0.2; }
                        50% { opacity: 0.6; }
                    }
                    @keyframes floatOrb {
                        0% {
                            transform: translate(0, 0) scale(1);
                            opacity: 0;
                        }
                        10% { opacity: 0.8; }
                        90% { opacity: 0.8; }
                        100% {
                            transform: translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px) scale(0.5);
                            opacity: 0;
                        }
                    }
                    @keyframes dataStream {
                        0% {
                            top: -100px;
                            opacity: 0;
                        }
                        10% { opacity: 1; }
                        90% { opacity: 1; }
                        100% {
                            top: 110%;
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        function toggleChangelog() {
            // Changelog already visible in main menu
            showNotification('üìã Changelog is displayed on the right panel!', 2000);
        }
        
        function showSettings() {
            showNotification('‚öôÔ∏è Settings coming soon!', 2000);
        }
        
        function resetProgress() {
            if (!confirm('‚ö†Ô∏è RESET ALL PROGRESS?\n\nThis will clear:\n- Weekly Challenges\n- Essence\n- Total Kills\n- Games Played\n- Highest Wave\n- Playtime\n\nHigh Score will be kept.\n\nContinue?')) {
                return;
            }
            
            // Clear all progress except high score
            localStorage.removeItem('plasmaSpecialCurrency');
            localStorage.removeItem('plasmaGamesPlayed');
            localStorage.removeItem('plasmaHighestWave');
            localStorage.removeItem('plasmaTotalPlaytime');
            localStorage.removeItem('plasmaTotalKills'); // Add this
            localStorage.removeItem('plasmaWeeklyChallenges');
            localStorage.removeItem('plasmaWeeklyChallengesReset');
            
            // Reinitialize
            weeklyChallenges = generateWeeklyChallenges();
            saveWeeklyChallenges();
            localStorage.setItem('plasmaWeeklyChallengesReset', Date.now());
            
            totalPlaytimeMinutes = 0;
            
            // Update displays
            updateMainMenuStats();
            updateWeeklyChallengesDisplay();
            updatePlaytimeDisplay();
            
            showNotification('‚úÖ Progress Reset!\nHigh Score Preserved.', 3000);
            
            console.log('Progress reset complete - all stats cleared except high score');
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STORE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let currentStoreTab = 'essence';
        let purchasedItems = {};
        let adWatchProgress = {}; // Track ads watched for unlock items {itemId: adsWatched}
        
        // Store items database
        const STORE_ITEMS = {
            essence: [
                { id: 'ad_essence_50', icon: 'üì∫', name: 'Watch Ad', desc: 'Watch ad for 50 Essence', price: 0, essence: 50, type: 'ad', badge: 'free' }
            ],
            skins: [
                { id: 'skin_cyborg', icon: 'ü§ñ', name: 'Cyborg Soldier', desc: 'Futuristic cybernetic warrior', price: 500, type: 'essence' },
                { id: 'skin_ninja', icon: 'ü•∑', name: 'Shadow Ninja', desc: 'Silent and deadly', price: 750, type: 'essence', badge: 'popular' },
                { id: 'skin_knight', icon: '‚öîÔ∏è', name: 'Plasma Knight', desc: 'Ancient warrior, future tech', price: 1000, type: 'essence' },
                { id: 'skin_space', icon: 'üëæ', name: 'Space Marine', desc: 'Elite cosmic defender', price: 1200, type: 'essence', badge: 'new' },
                { id: 'skin_ghost', icon: 'üëª', name: 'Phantom', desc: 'Ethereal fighter', price: 1500, type: 'essence' },
                { id: 'skin_demon', icon: 'üòà', name: 'Infernal', desc: 'Demonic power incarnate', price: 2000, type: 'essence', badge: 'popular' },
                { id: 'skin_angel', icon: 'üòá', name: 'Celestial', desc: 'Divine warrior', price: 2500, type: 'essence' },
                { id: 'skin_dragon', icon: 'üêâ', name: 'Dragon Soul', desc: 'Watch 12 ads to unlock', price: 12, type: 'ad_unlock', badge: 'premium' },
                { id: 'skin_voidwalker', icon: 'üåå', name: 'Voidwalker', desc: 'MYTHIC - Reality bender from beyond', price: 0, type: 'mythic', badge: 'mythic' },
                // MYTHIC TIER - 9000 Essence Each
                { id: 'skin_cosmic', icon: 'üå†', name: 'Cosmic Emperor', desc: 'MYTHIC - Master of galaxies and stars', price: 9000, type: 'essence', badge: 'mythic' },
                { id: 'skin_phoenix', icon: 'üî•ü¶Ö', name: 'Phoenix Ascendant', desc: 'MYTHIC - Reborn from eternal flames', price: 9000, type: 'essence', badge: 'mythic' },
                { id: 'skin_storm', icon: '‚ö°üëë', name: 'Storm Sovereign', desc: 'MYTHIC - Commands thunder and lightning', price: 9000, type: 'essence', badge: 'mythic' },
                { id: 'skin_shadow', icon: 'üåëüíÄ', name: 'Shadow Overlord', desc: 'MYTHIC - Darkness incarnate supreme', price: 9000, type: 'essence', badge: 'mythic' },
                { id: 'skin_prismatic', icon: 'üíéüåà', name: 'Prismatic God', desc: 'MYTHIC - Living spectrum of pure energy', price: 9000, type: 'essence', badge: 'mythic' }
            ],
            weapons: [
                { id: 'weapon_plasma', icon: 'üî´', name: 'Plasma Rifle', desc: 'Blue energy projectiles', price: 300, type: 'essence' },
                { id: 'weapon_laser', icon: 'üî¥', name: 'Red Laser', desc: 'Crimson death ray', price: 400, type: 'essence', badge: 'popular' },
                { id: 'weapon_lightning', icon: '‚ö°', name: 'Arc Cannon', desc: 'Electric devastation', price: 600, type: 'essence' },
                { id: 'weapon_frost', icon: '‚ùÑÔ∏è', name: 'Cryo Blaster', desc: 'Freezing projectiles', price: 800, type: 'essence', badge: 'new' },
                { id: 'weapon_flame', icon: 'üî•', name: 'Inferno Gun', desc: 'Burning ammunition', price: 1000, type: 'essence' },
                { id: 'weapon_void', icon: 'üåå', name: 'Void Cannon', desc: 'Reality-warping shots', price: 1500, type: 'essence', badge: 'popular' },
                { id: 'weapon_rainbow', icon: 'üåà', name: 'Prismatic Ray', desc: 'Watch 10 ads to unlock', price: 10, type: 'ad_unlock' },
                { id: 'weapon_celestial', icon: '‚ú®', name: 'Celestial Beam', desc: 'Watch 10 ads to unlock', price: 10, type: 'ad_unlock', badge: 'premium' },
                { id: 'weapon_shadow', icon: 'üåë', name: 'Shadow Reaper', desc: 'Watch 10 ads to unlock', price: 10, type: 'ad_unlock', badge: 'premium' }
            ],
            perks: [
                { id: 'perk_health', icon: '‚ù§Ô∏è', name: 'Extra Life', desc: '+50 Max HP permanently', price: 800, type: 'essence', badge: 'popular' },
                { id: 'perk_damage', icon: 'üí™', name: 'Power Boost', desc: '+10% Damage permanently', price: 1000, type: 'essence' },
                { id: 'perk_speed', icon: 'üèÉ', name: 'Swift Feet', desc: '+15% Speed permanently', price: 800, type: 'essence' },
                { id: 'perk_goldbonus', icon: 'üí∞', name: 'Wealth', desc: '+25% Gold earned', price: 1200, type: 'essence', badge: 'popular' },
                { id: 'perk_xpbonus', icon: '‚≠ê', name: 'Fast Learner', desc: '+30% XP earned', price: 1200, type: 'essence' },
                { id: 'perk_buildpoints', icon: 'üèóÔ∏è', name: 'Architect', desc: '+2 Starting buildings', price: 1500, type: 'essence' },
                { id: 'perk_startlevel', icon: 'üìà', name: 'Head Start', desc: 'Start at level 3', price: 2000, type: 'essence', badge: 'new' },
                { id: 'perk_revive', icon: 'üíö', name: 'Second Life', desc: 'Watch 15 ads to unlock', price: 15, type: 'ad_unlock', badge: 'premium' }
            ]
        };
        
        function loadPurchasedItems() {
            const saved = localStorage.getItem('plasmaPurchasedItems');
            purchasedItems = saved ? JSON.parse(saved) : {};
            
            const adSaved = localStorage.getItem('plasmaAdWatchProgress');
            adWatchProgress = adSaved ? JSON.parse(adSaved) : {};
        }
        
        function savePurchasedItems() {
            localStorage.setItem('plasmaPurchasedItems', JSON.stringify(purchasedItems));
            localStorage.setItem('plasmaAdWatchProgress', JSON.stringify(adWatchProgress));
        }
        
        function showStore() {
            document.getElementById('storeModal').classList.remove('hidden');
            updateStoreCurrency();
            loadPurchasedItems();
            switchStoreTab('essence');
        }
        
        function closeStore() {
            document.getElementById('storeModal').classList.add('hidden');
        }
        
        function updateStoreCurrency() {
            const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0);
            document.getElementById('storeCurrencyDisplay').textContent = essence;
        }
        
        function switchStoreTab(tab) {
            currentStoreTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.store-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate correct tab
            const tabs = document.querySelectorAll('.store-tab');
            tabs.forEach(btn => {
                if (btn.onclick.toString().includes(`'${tab}'`)) {
                    btn.classList.add('active');
                }
            });
            
            // Render items
            renderStoreItems(tab);
        }
        
        function renderStoreItems(tab) {
            const content = document.getElementById('storeContent');
            const items = STORE_ITEMS[tab];
            
            if (!items) return;
            
            let html = '<div class="store-items-grid">';
            
            items.forEach(item => {
                const isPurchased = purchasedItems[item.id];
                const purchasedClass = isPurchased ? 'purchased' : '';
                
                // Badge
                let badge = '';
                if (item.badge) {
                    badge = `<div class="item-badge badge-${item.badge}">${item.badge.toUpperCase()}</div>`;
                }
                
                // Price display
                let priceHTML = '';
                if (item.type === 'ad') {
                    // Rewarded Ad
                    priceHTML = `
                        <div class="item-price">
                            <span class="price-ad">üì∫ FREE</span>
                        </div>
                    `;
                } else if (tab === 'essence') {
                    priceHTML = `
                        <div class="item-price">
                            <span class="price-currency">$${item.price}</span>
                            <span style="color: #aaa;">‚Üí</span>
                            <span class="price-essence">${item.essence} ‚ú®</span>
                        </div>
                    `;
                } else if (item.type === 'ad_unlock') {
                    // Ad unlock item - show progress
                    const adsWatched = adWatchProgress[item.id] || 0;
                    priceHTML = `
                        <div class="item-price">
                            <span class="price-ad">üì∫ ${adsWatched}/${item.price} Ads</span>
                        </div>
                    `;
                } else if (item.type === 'essence') {
                    priceHTML = `
                        <div class="item-price">
                            <span class="price-essence">${item.price} ‚ú®</span>
                        </div>
                    `;
                } else if (item.type === 'currency') {
                    priceHTML = `
                        <div class="item-price">
                            <span class="price-currency">$${item.price}</span>
                        </div>
                    `;
                }
                
                // Button
                let buttonHTML = '';
                if (item.type === 'ad') {
                    // Rewarded ad - never shows as owned, always watchable
                    buttonHTML = `<button class="item-buy-button ad-button" onclick="watchRewardedAd('${item.id}', '${tab}')">WATCH AD</button>`;
                } else if (item.type === 'ad_unlock') {
                    // Ad unlock item
                    if (isPurchased) {
                        buttonHTML = '<button class="item-buy-button">‚úì OWNED</button>';
                    } else {
                        const adsWatched = adWatchProgress[item.id] || 0;
                        const adsRemaining = item.price - adsWatched;
                        buttonHTML = `<button class="item-buy-button ad-button" onclick="watchAdUnlock('${item.id}', '${tab}')">${adsRemaining > 0 ? 'WATCH AD' : 'UNLOCK'}</button>`;
                    }
                } else if (isPurchased) {
                    buttonHTML = '<button class="item-buy-button">‚úì OWNED</button>';
                } else {
                    buttonHTML = `<button class="item-buy-button" onclick="purchaseStoreItem('${item.id}', '${tab}')">BUY NOW</button>`;
                }
                
                // Special styling for ad item
                const adClass = (item.type === 'ad' || item.type === 'ad_unlock') ? 'ad-item' : '';
                const mythicClass = item.badge === 'mythic' ? 'mythic-item' : '';
                const premiumClass = item.badge === 'premium' ? 'premium-item' : '';
                
                html += `
                    <div class="store-item ${purchasedClass} ${adClass} ${mythicClass} ${premiumClass}">
                        ${badge}
                        <div class="item-icon">${item.icon}</div>
                        <div class="item-name">${item.name}</div>
                        <div class="item-description">${item.desc}</div>
                        ${priceHTML}
                        ${buttonHTML}
                    </div>
                `;
            });
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function watchRewardedAd(itemId, tab) {
            const items = STORE_ITEMS[tab];
            const item = items.find(i => i.id === itemId);
            
            if (!item) return;
            
            // Show loading notification
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: Essence
                const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + item.essence;
                localStorage.setItem('plasmaSpecialCurrency', essence);
                
                updateStoreCurrency();
                updateMainMenuStats();
                
                showNotification(`‚úÖ Ad watched!\n+${item.essence} ‚ú® Essence rewarded!`, 3000);
                
                console.log(`‚úÖ Rewarded ad watched: +${item.essence} essence`);
            });
        }
        
        function watchAdUnlock(itemId, tab) {
            const items = STORE_ITEMS[tab];
            const item = items.find(i => i.id === itemId);
            
            if (!item) return;
            if (purchasedItems[itemId]) {
                showNotification('‚úì You already own this!', 2000);
                return;
            }
            
            const adsRequired = item.price;
            const adsWatched = adWatchProgress[itemId] || 0;
            const adsRemaining = adsRequired - adsWatched;
            
            if (adsRemaining <= 0) {
                // Already watched enough, just unlock
                purchasedItems[itemId] = true;
                savePurchasedItems();
                showNotification(`‚úÖ ${item.name} UNLOCKED!`, 3000);
                renderStoreItems(tab);
                return;
            }
            
            // Show ad
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: Progress toward unlock
                adWatchProgress[itemId] = adsWatched + 1;
                const newRemaining = adsRequired - adWatchProgress[itemId];
                
                savePurchasedItems();
                
                if (newRemaining === 0) {
                    // Unlocked!
                    purchasedItems[itemId] = true;
                    savePurchasedItems();
                    showNotification(`üéâ ${item.name} UNLOCKED!\nAll ads watched!`, 4000);
                    screenShake = 20;
                } else {
                    showNotification(`üì∫ Ad watched!\n${newRemaining} more ads to unlock ${item.name}`, 3000);
                }
                
                renderStoreItems(tab);
                console.log(`‚úÖ Ad unlock progress: ${item.name} ${adWatchProgress[itemId]}/${adsRequired}`);
            });
        }
        
        function showInterstitialAd() {
            console.log('üì∫ Showing interstitial ad at wave', wave);
            
            // Show CrazyGames midgame ad
            showCrazyGamesMidgameAd();
        }
        
        // Continue with ad (revive)
        function continueWithAd() {
            if (continueUsed) {
                showNotification('‚ùå Already used continue!', 2000);
                return;
            }
            
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: Revive
                continueUsed = true;
                
                // Revive player
                player.health = player.maxHealth;
                base.health = base.maxHealth;
                
                // Clear enemies
                enemies = [];
                
                // RESET WAVE STATE - Critical fix!
                waveActive = false;
                waveTransition = false;
                waveStartDelay = 0;
                waveEnemiesRemaining = 0;
                
                // Hide game over
                document.getElementById('gameOver').classList.remove('active');
                const continueBtn = document.getElementById('continueAdButton');
                if (continueBtn) {
                    continueBtn.style.display = 'none';
                }
                
                // Resume game
                gameState = 'playing';
                
                showNotification('‚ö° REVIVED!\nYou have full health!', 3000);
                screenShake = 20;
                
                console.log('‚úÖ Player continued with ad reward');
            });
        }
        
        // Double rewards with ad (wave complete bonus)
        function doubleRewardsWithAd() {
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: Double rewards
                const waveGold = Math.floor(wave * 10);
                const waveXP = Math.floor(wave * 10);
                const waveEssence = Math.floor(wave * 0.5);
                
                gold += waveGold;
                player.xp += waveXP;
                
                const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + waveEssence;
                localStorage.setItem('plasmaSpecialCurrency', essence);
                
                document.getElementById('goldDisplay').textContent = gold;
                updateMainMenuStats();
                
                showNotification(`üéÅ 2X REWARDS!\n+${waveGold} Gold | +${waveXP} XP | +${waveEssence}‚ú®`, 3000);
                screenShake = 15;
                
                console.log('‚úÖ Double rewards granted from ad');
            });
        }
        
        // Instant building with ad
        function instantBuildingWithAd() {
            if (buildingPoints >= 3) {
                showNotification('‚ùå Already at max buildings!', 2000);
                return;
            }
            
            if (!confirm('Watch an ad to get +1 instant building?')) {
                return;
            }
            
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: Building point
                buildingPoints++;
                showNotification('üèóÔ∏è +1 BUILDING POINT!\nPlace a tower or wall!', 3000);
                screenShake = 10;
                
                console.log('‚úÖ Instant building granted, points:', buildingPoints);
            });
        }
        
        // Boost XP with ad (2x XP for next wave)
        let xpBoostActive = false;
        function activateXPBoostWithAd() {
            if (xpBoostActive) {
                showNotification('‚≠ê XP Boost already active!', 2000);
                return;
            }
            
            if (!confirm('Watch an ad for 2X XP next wave?')) {
                return;
            }
            
            showNotification('üì∫ Loading ad...', 1000);
            
            showCrazyGamesRewardedAd(() => {
                // Grant reward: XP boost
                xpBoostActive = true;
                showNotification('‚≠ê 2X XP ACTIVATED!\nDouble XP for next wave!', 3000);
                screenShake = 10;
                
                console.log('‚úÖ XP boost activated from ad');
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // LUCKY WHEEL SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let wheelSpinning = false;
        let wheelRotation = 0; // Start with segment 0 at pointer (top)

        let freeSpinsToday = 3;
        let lastSpinDate = localStorage.getItem('plasmaLastSpinDate') || '';
        
        // Wheel rewards (7 segments)
        const WHEEL_REWARDS = [
            { type: 'essence', amount: 50, label: '50‚ú®', color: '#888888', rarity: 'common', chance: 35 },
            { type: 'essence', amount: 100, label: '100‚ú®', color: '#00ff88', rarity: 'common', chance: 25 },
            { type: 'essence', amount: 200, label: '200‚ú®', color: '#0099ff', rarity: 'uncommon', chance: 15 },
            { type: 'skin', amount: 1, label: 'Random\nSkin', color: '#ff69b4', rarity: 'uncommon', chance: 10 },
            { type: 'essence', amount: 500, label: '500‚ú®', color: '#9d4edd', rarity: 'rare', chance: 8 },
            { type: 'perk', amount: 1, label: 'Random\nPerk', color: '#ffd700', rarity: 'rare', chance: 5 },
            { type: 'essence', amount: 1000, label: 'üé∞\n1000‚ú®', color: '#ff00ff', rarity: 'legendary', chance: 2 }
        ];
        
        // Debug function to verify wheel
        function verifyWheel() {
            console.log('=== WHEEL VERIFICATION ===');
            let totalChance = 0;
            WHEEL_REWARDS.forEach((r, i) => {
                totalChance += r.chance;
                console.log(`Segment ${i}: ${r.label} = ${r.amount}‚ú® (${r.chance}%)`);
            });
            console.log(`Total chance: ${totalChance}%`);
            console.log('========================');
        }
        
        function checkDailySpins() {
            const today = new Date().toDateString();
            if (lastSpinDate !== today) {
                freeSpinsToday = 3;
                lastSpinDate = today;
                localStorage.setItem('plasmaLastSpinDate', today);
                localStorage.setItem('plasmaFreeSpins', 3);
            } else {
                freeSpinsToday = parseInt(localStorage.getItem('plasmaFreeSpins') || 3);
            }
        }
        
        function showLuckyWheel() {
            checkDailySpins();
            verifyWheel(); // Debug verification
            document.getElementById('luckyWheelModal').classList.remove('hidden');
            updateWheelUI();
            drawWheel();
        }
        
        function closeLuckyWheel() {
            document.getElementById('luckyWheelModal').classList.add('hidden');
        }
        
        function updateWheelUI() {
            document.getElementById('freeSpinsLeft').textContent = freeSpinsToday;
            const freeButton = document.getElementById('freeSpinButton');
            if (freeSpinsToday <= 0) {
                freeButton.disabled = true;
                freeButton.style.opacity = '0.3';
            } else {
                freeButton.disabled = false;
                freeButton.style.opacity = '1';
            }
        }
        
        function drawWheel() {
            const canvas = document.getElementById('luckyWheelCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 180;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw segments
            const segmentAngle = (Math.PI * 2) / WHEEL_REWARDS.length;
            
            WHEEL_REWARDS.forEach((reward, index) => {
                // Offset so segment 0 is centered at pointer (top = -PI/2)
                const startAngle = (index * segmentAngle) + wheelRotation - (Math.PI / 2) - (segmentAngle / 2);
                const endAngle = startAngle + segmentAngle;
                
                // Segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                
                ctx.fillStyle = reward.color;
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                
                const lines = reward.label.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, radius * 0.65, (i - lines.length / 2 + 0.5) * 20);
                });
                
                ctx.restore();
            });
            
            // Center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Center text
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('SPIN', centerX, centerY);
        }
        
        function spinWheel(isAdSpin) {
            if (wheelSpinning) return;
            
            if (!isAdSpin && freeSpinsToday <= 0) {
                showNotification('‚ùå No free spins left!\nUse ad spin instead.', 2000);
                return;
            }
            
            if (isAdSpin) {
                showNotification('üì∫ Loading ad...', 1000);
                showCrazyGamesRewardedAd(() => {
                    // Grant reward: Wheel spin
                    performSpin();
                    console.log('‚úÖ Wheel spin granted from ad');
                });
            } else {
                performSpin();
                freeSpinsToday--;
                localStorage.setItem('plasmaFreeSpins', freeSpinsToday);
                updateWheelUI();
            }
        }
        
        function performSpin() {
            wheelSpinning = true;
            
            // Select reward based on chances
            const rand = Math.random() * 100;
            let cumulativeChance = 0;
            let selectedReward = WHEEL_REWARDS[0];
            let selectedIndex = 0;
            
            for (let i = 0; i < WHEEL_REWARDS.length; i++) {
                cumulativeChance += WHEEL_REWARDS[i].chance;
                if (rand <= cumulativeChance) {
                    selectedReward = WHEEL_REWARDS[i];
                    selectedIndex = i;
                    break;
                }
            }
            
            console.log('=== WHEEL SPIN ===');
            console.log('Random:', rand.toFixed(2));
            console.log('Selected index:', selectedIndex);
            console.log('Selected reward:', selectedReward.label, '=', selectedReward.amount, selectedReward.type);
            console.log('==================');
            
            // Calculate rotation to land on selected segment
            const segmentAngle = (Math.PI * 2) / WHEEL_REWARDS.length;
            
            // Wheel starts at -PI/2 (top, 12 o'clock)
            // Pointer is at top
            // Segments drawn clockwise starting from index 0
            // To land segment N at pointer: rotate wheel to position segment N at top
            const targetAngle = -(selectedIndex * segmentAngle) - (segmentAngle / 2);
            
            // Add extra spins for effect
            const extraSpins = 5 + Math.random() * 2; // 5-7 full rotations
            const totalRotation = (Math.PI * 2 * extraSpins) + targetAngle;
            
            const duration = 4000; // 4 seconds
            const startTime = Date.now();
            const startRotation = wheelRotation;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease out cubic for smooth deceleration
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                wheelRotation = startRotation + (totalRotation * easeProgress);
                drawWheel();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    wheelSpinning = false;
                    wheelRotation = wheelRotation % (Math.PI * 2);
                    grantWheelReward(selectedReward);
                }
            }
            
            animate();
        }
        
        function grantWheelReward(reward) {
            console.log('=== GRANTING REWARD ===');
            console.log('Reward type:', reward.type);
            console.log('Reward amount:', reward.amount);
            console.log('Reward label:', reward.label);
            console.log('=======================');
            
            screenShake = 20;
            
            // Show win animation
            const winDisplay = document.getElementById('wheelWinDisplay');
            const winIcon = document.getElementById('winIcon');
            const winText = document.getElementById('winText');
            const winAmount = document.getElementById('winAmount');
            
            let displayIcon = 'üéÅ';
            let displayText = 'YOU WON!';
            let displayAmount = '';
            
            if (reward.type === 'essence') {
                const oldEssence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0);
                const newEssence = oldEssence + reward.amount;
                localStorage.setItem('plasmaSpecialCurrency', newEssence);
                updateMainMenuStats();
                
                console.log(`Essence: ${oldEssence} + ${reward.amount} = ${newEssence}`);
                
                if (reward.rarity === 'legendary') {
                    displayIcon = 'üé∞';
                    displayText = 'JACKPOT!';
                    displayAmount = `+${reward.amount}‚ú®`;
                    screenShake = 50;
                } else {
                    displayIcon = '‚ú®';
                    displayText = 'YOU WON!';
                    displayAmount = `+${reward.amount}‚ú®`;
                }
            } else if (reward.type === 'skin') {
                // Grant random unowned skin
                const allSkins = STORE_ITEMS.skins.filter(s => !purchasedItems[s.id] && s.type === 'essence');
                if (allSkins.length > 0) {
                    const randomSkin = allSkins[Math.floor(Math.random() * allSkins.length)];
                    purchasedItems[randomSkin.id] = true;
                    savePurchasedItems();
                    
                    console.log('Lucky Wheel: Unlocked skin:', randomSkin.id, randomSkin.name);
                    console.log('Purchased items after unlock:', purchasedItems);
                    
                    displayIcon = randomSkin.icon;
                    displayText = 'NEW SKIN!';
                    displayAmount = randomSkin.name;
                } else {
                    // No skins left, give essence instead
                    const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + 300;
                    localStorage.setItem('plasmaSpecialCurrency', essence);
                    updateMainMenuStats();
                    
                    displayIcon = '‚ú®';
                    displayText = 'ALL SKINS OWNED!';
                    displayAmount = '+300‚ú®';
                }
            } else if (reward.type === 'perk') {
                // Grant random unowned perk
                const allPerks = STORE_ITEMS.perks.filter(p => !purchasedItems[p.id] && p.type === 'essence');
                if (allPerks.length > 0) {
                    const randomPerk = allPerks[Math.floor(Math.random() * allPerks.length)];
                    purchasedItems[randomPerk.id] = true;
                    savePurchasedItems();
                    
                    console.log('Lucky Wheel: Unlocked perk:', randomPerk.id, randomPerk.name);
                    console.log('Purchased items after unlock:', purchasedItems);
                    
                    displayIcon = randomPerk.icon;
                    displayText = 'NEW PERK!';
                    displayAmount = randomPerk.name;
                } else {
                    // No perks left, give essence instead
                    const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + 400;
                    localStorage.setItem('plasmaSpecialCurrency', essence);
                    updateMainMenuStats();
                    
                    displayIcon = '‚ú®';
                    displayText = 'ALL PERKS OWNED!';
                    displayAmount = '+400‚ú®';
                }
            }
            
            // Update and show win display
            winIcon.textContent = displayIcon;
            winText.textContent = displayText;
            winAmount.textContent = displayAmount;
            winDisplay.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(() => {
                winDisplay.classList.remove('show');
            }, 3000);
            
            console.log('Wheel reward:', reward);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PRIORITY TARGETING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function getPriorityEnemies() {
            // Sort enemies by threat level (1 = highest priority, 5 = lowest)
            return enemies
                .filter(e => e.health > 0)
                .sort((a, b) => {
                    // First by threat level
                    if (a.threatLevel !== b.threatLevel) {
                        return a.threatLevel - b.threatLevel;
                    }
                    // Then by distance to base (closer = higher priority)
                    const distA = Math.hypot(a.x - base.x, a.y - base.y);
                    const distB = Math.hypot(b.x - base.x, b.y - base.y);
                    return distA - distB;
                });
        }
        
        function cyclePriorityTarget() {
            const priorityEnemies = getPriorityEnemies();
            if (priorityEnemies.length === 0) {
                currentPriorityTarget = null;
                return;
            }
            
            priorityTargetIndex = (priorityTargetIndex + 1) % priorityEnemies.length;
            currentPriorityTarget = priorityEnemies[priorityTargetIndex];
            
            // Visual feedback
            showNotification(`üéØ Target: ${currentPriorityTarget.name}\nThreat: ${getThreatLevelName(currentPriorityTarget.threatLevel)}`, 1500);
            
            console.log('Priority target:', currentPriorityTarget.name, 'Threat:', currentPriorityTarget.threatLevel);
        }
        
        function getThreatLevelName(level) {
            const names = {
                1: 'üî¥ CRITICAL',
                2: 'üü† HIGH',
                3: 'üü° MEDIUM',
                4: 'üü¢ LOW',
                5: '‚ö™ MINIMAL'
            };
            return names[level] || 'UNKNOWN';
        }
        
        function getThreatColor(level) {
            const colors = {
                1: '#ff0000', // Red - Critical
                2: '#ff8800', // Orange - High
                3: '#ffff00', // Yellow - Medium
                4: '#00ff00', // Green - Low
                5: '#ffffff'  // White - Minimal
            };
            return colors[level] || '#ffffff';
        }
        
        function autoTargetPriority() {
            // Auto-target highest priority enemy when attacking
            const priorityEnemies = getPriorityEnemies();
            if (priorityEnemies.length > 0) {
                currentPriorityTarget = priorityEnemies[0];
                return currentPriorityTarget;
            }
            return null;
        }
        
        function clearPriorityTarget() {
            currentPriorityTarget = null;
            priorityTargetIndex = 0;
        }
        
        function purchaseStoreItem(itemId, tab) {
            const items = STORE_ITEMS[tab];
            const item = items.find(i => i.id === itemId);
            
            if (!item) return;
            if (purchasedItems[itemId]) {
                showNotification('‚úì You already own this item!', 2000);
                return;
            }
            
            if (tab === 'essence') {
                // REAL MONEY PURCHASE
                if (!confirm(`Purchase ${item.name} for $${item.price}?\n\n(In real app, this would open payment dialog)`)) {
                    return;
                }
                
                // TODO: Real IAP integration here
                // For now, simulate purchase
                const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + item.essence;
                localStorage.setItem('plasmaSpecialCurrency', essence);
                
                purchasedItems[itemId] = true;
                savePurchasedItems();
                
                showNotification(`‚ú® Purchased!\n+${item.essence} Essence`, 3000);
                screenShake = 20;
                
            } else if (item.type === 'essence') {
                // ESSENCE PURCHASE
                const currentEssence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0);
                
                if (currentEssence < item.price) {
                    showNotification(`‚ùå Not enough Essence!\nNeed: ${item.price} ‚ú®\nHave: ${currentEssence} ‚ú®`, 3000);
                    return;
                }
                
                if (!confirm(`Purchase ${item.name} for ${item.price} Essence?`)) {
                    return;
                }
                
                localStorage.setItem('plasmaSpecialCurrency', currentEssence - item.price);
                purchasedItems[itemId] = true;
                savePurchasedItems();
                
                showNotification(`‚úì ${item.name} Purchased!`, 3000);
                
            } else if (item.type === 'currency') {
                // REAL MONEY PURCHASE (special items)
                if (!confirm(`Purchase ${item.name} for $${item.price}?\n\n(In real app, this would open payment dialog)`)) {
                    return;
                }
                
                // TODO: Real IAP integration
                purchasedItems[itemId] = true;
                savePurchasedItems();
                
                showNotification(`‚úì ${item.name} Purchased!`, 3000);
                screenShake = 20;
            }
            
            // Update displays
            updateStoreCurrency();
            updateMainMenuStats();
            renderStoreItems(tab);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WARDROBE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let equippedItems = {
            skin: 'default',
            weapon: 'default',
            perks: [] // Max 3 active perks
        };
        
        function loadEquippedItems() {
            const saved = localStorage.getItem('plasmaEquippedItems');
            if (saved) {
                equippedItems = JSON.parse(saved);
                // Ensure perks array exists (for old saves)
                if (!equippedItems.perks) {
                    equippedItems.perks = [];
                }
            }
        }
        
        function saveEquippedItems() {
            localStorage.setItem('plasmaEquippedItems', JSON.stringify(equippedItems));
        }
        
        function showWardrobe() {
            document.getElementById('wardrobeModal').classList.remove('hidden');
            loadPurchasedItems();
            loadEquippedItems();
            updateWardrobePreview();
            switchWardrobeTab('skins');
        }
        
        function closeWardrobe() {
            document.getElementById('wardrobeModal').classList.add('hidden');
        }
        
        function updateWardrobePreview() {
            // Character preview
            const characterItem = equippedItems.skin === 'default' 
                ? { icon: 'üë§', name: 'Default' }
                : STORE_ITEMS.skins.find(i => i.id === equippedItems.skin);
            
            if (characterItem) {
                document.getElementById('previewCharacterIcon').textContent = characterItem.icon;
                document.getElementById('previewCharacterName').textContent = characterItem.name;
            }
            
            // Weapon preview
            const weaponItem = equippedItems.weapon === 'default'
                ? { icon: 'üî´', name: 'Default' }
                : STORE_ITEMS.weapons.find(i => i.id === equippedItems.weapon);
            
            if (weaponItem) {
                document.getElementById('previewWeaponIcon').textContent = weaponItem.icon;
                document.getElementById('previewWeaponName').textContent = weaponItem.name;
            }
        }
        
        function switchWardrobeTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.wardrobe-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate correct tab
            const tabs = document.querySelectorAll('.wardrobe-tab');
            tabs.forEach(btn => {
                if (btn.onclick.toString().includes(`'${tab}'`)) {
                    btn.classList.add('active');
                }
            });
            
            // Render items
            renderWardrobeItems(tab);
        }
        
        function renderWardrobeItems(tab) {
            const content = document.getElementById('wardrobeContent');
            const items = STORE_ITEMS[tab];
            
            if (!items) return;
            
            // Perks tab - special handling
            if (tab === 'perks') {
                const ownedPerks = items.filter(i => purchasedItems[i.id]);
                
                if (ownedPerks.length === 0) {
                    content.innerHTML = `
                        <div class="wardrobe-empty">
                            <div class="wardrobe-empty-icon">üîí</div>
                            <div class="wardrobe-empty-text">No perks unlocked yet!</div>
                            <div class="wardrobe-empty-hint">Visit the Store or Battle Pass to unlock perks</div>
                        </div>
                    `;
                    return;
                }
                
                let html = '<div class="perk-slots-info">‚ö° Select up to 3 active perks</div>';
                html += '<div class="wardrobe-items-grid">';
                
                ownedPerks.forEach(perk => {
                    const isEquipped = equippedItems.perks.includes(perk.id);
                    let statusHTML = '';
                    let itemClass = 'owned';
                    
                    if (isEquipped) {
                        statusHTML = '<div class="wardrobe-item-status status-equipped">‚úì ACTIVE</div>';
                        itemClass += ' equipped';
                    } else if (equippedItems.perks.length >= 3) {
                        statusHTML = '<div class="wardrobe-item-status status-locked">SLOTS FULL</div>';
                    } else {
                        statusHTML = '<div class="wardrobe-item-status status-owned">CLICK TO ACTIVATE</div>';
                    }
                    
                    html += `
                        <div class="wardrobe-item ${itemClass}" onclick="togglePerk('${perk.id}')">
                            <div class="wardrobe-item-icon">${perk.icon}</div>
                            <div class="wardrobe-item-name">${perk.name}</div>
                            <div class="wardrobe-item-desc">${perk.desc}</div>
                            ${statusHTML}
                        </div>
                    `;
                });
                
                html += '</div>';
                content.innerHTML = html;
                return;
            }
            
            // Skins/Weapons tab - existing code
            // Add default option
            const defaultItem = {
                id: 'default',
                icon: tab === 'skins' ? 'üë§' : 'üî´',
                name: 'Default',
                desc: 'Original look'
            };
            
            // Filter owned items
            const ownedItems = [defaultItem, ...items.filter(i => purchasedItems[i.id])];
            
            console.log(`Rendering ${tab}:`, {
                totalItems: items.length,
                ownedCount: ownedItems.length - 1,
                purchasedItems: purchasedItems,
                ownedIds: ownedItems.map(i => i.id)
            });
            
            if (ownedItems.length === 1) {
                // Only default, show empty state
                content.innerHTML = `
                    <div class="wardrobe-empty">
                        <div class="wardrobe-empty-icon">üîí</div>
                        <div class="wardrobe-empty-text">No ${tab} unlocked yet!</div>
                        <div class="wardrobe-empty-hint">Visit the Store to unlock new ${tab}</div>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="wardrobe-items-grid">';
            
            ownedItems.forEach(item => {
                const isEquipped = equippedItems[tab === 'skins' ? 'skin' : 'weapon'] === item.id;
                const isOwned = item.id === 'default' || purchasedItems[item.id];
                const isMythic = item.badge === 'mythic';
                const isPremium = item.badge === 'premium';
                
                let statusHTML = '';
                let itemClass = '';
                
                if (isEquipped) {
                    statusHTML = '<div class="wardrobe-item-status status-equipped">‚úì EQUIPPED</div>';
                    itemClass = 'equipped owned';
                } else if (isOwned) {
                    statusHTML = '<div class="wardrobe-item-status status-owned">CLICK TO EQUIP</div>';
                    itemClass = 'owned';
                }
                
                if (isMythic) {
                    itemClass += ' mythic-item';
                }
                if (isPremium) {
                    itemClass += ' premium-item';
                }
                
                html += `
                    <div class="wardrobe-item ${itemClass}" onclick="equipItem('${item.id}', '${tab}')">
                        <div class="wardrobe-item-icon">${item.icon}</div>
                        <div class="wardrobe-item-name">${item.name}</div>
                        ${statusHTML}
                    </div>
                `;
            });
            
            html += '</div>';
            content.innerHTML = html;
        }
        
        function togglePerk(perkId) {
            const index = equippedItems.perks.indexOf(perkId);
            
            if (index !== -1) {
                // Already equipped, remove it
                equippedItems.perks.splice(index, 1);
                showNotification('‚ö° Perk deactivated!', 2000);
            } else {
                // Not equipped, try to add
                if (equippedItems.perks.length >= 3) {
                    showNotification('‚ùå Max 3 perks active!\nDeactivate one first.', 2000);
                    return;
                }
                equippedItems.perks.push(perkId);
                const perk = STORE_ITEMS.perks.find(p => p.id === perkId);
                showNotification(`‚ö° ${perk ? perk.name : 'Perk'} activated!`, 2000);
            }
            
            saveEquippedItems();
            renderWardrobeItems('perks');
        }
        
        function equipItem(itemId, tab) {
            const type = tab === 'skins' ? 'skin' : 'weapon';
            
            // Check if already equipped
            if (equippedItems[type] === itemId) {
                showNotification('‚úì Already equipped!', 2000);
                return;
            }
            
            // Equip item
            equippedItems[type] = itemId;
            saveEquippedItems();
            
            // Update preview
            updateWardrobePreview();
            
            // Re-render items to update equipped status
            renderWardrobeItems(tab);
            
            // Get item name
            let itemName = 'Default';
            if (itemId !== 'default') {
                const item = STORE_ITEMS[tab].find(i => i.id === itemId);
                if (item) itemName = item.name;
            }
            
            showNotification(`‚úì ${itemName} Equipped!`, 2000);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BATTLE PASS SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let battlePassData = {
            tier: 0,
            xp: 0,
            premium: false,
            premiumAdsWatched: 0, // Track ads watched for premium unlock
            claimedRewards: []
        };
        
        // Battle Pass Rewards (50 tiers)
        const BATTLE_PASS_REWARDS = [
            // Tier 1-10 (Early rewards)
            { tier: 1, free: {type: 'essence', amount: 50, icon: '‚ú®', name: '50 Essence'}, premium: {type: 'essence', amount: 100, icon: 'üíé', name: '100 Essence'} },
            { tier: 2, free: {type: 'skin', id: 'weapon_plasma', icon: 'üî´', name: 'Plasma Rifle'}, premium: {type: 'essence', amount: 150, icon: 'üíé', name: '150 Essence'} },
            { tier: 3, free: {type: 'essence', amount: 75, icon: '‚ú®', name: '75 Essence'}, premium: {type: 'skin', id: 'skin_cyborg', icon: 'ü§ñ', name: 'Cyborg Soldier'} },
            { tier: 4, free: null, premium: {type: 'essence', amount: 200, icon: 'üíé', name: '200 Essence'} },
            { tier: 5, free: {type: 'essence', amount: 100, icon: '‚ú®', name: '100 Essence'}, premium: {type: 'skin', id: 'weapon_laser', icon: 'üî¥', name: 'Red Laser'} },
            { tier: 6, free: {type: 'perk', id: 'perk_speed', icon: 'üèÉ', name: 'Swift Feet'}, premium: {type: 'essence', amount: 250, icon: 'üíé', name: '250 Essence'} },
            { tier: 7, free: {type: 'essence', amount: 150, icon: '‚ú®', name: '150 Essence'}, premium: {type: 'skin', id: 'weapon_lightning', icon: '‚ö°', name: 'Arc Cannon'} },
            { tier: 8, free: null, premium: {type: 'essence', amount: 300, icon: 'üíé', name: '300 Essence'} },
            { tier: 9, free: {type: 'essence', amount: 200, icon: '‚ú®', name: '200 Essence'}, premium: {type: 'perk', id: 'perk_goldbonus', icon: 'üí∞', name: 'Wealth Perk'} },
            { tier: 10, free: {type: 'skin', id: 'weapon_frost', icon: '‚ùÑÔ∏è', name: 'Cryo Blaster'}, premium: {type: 'skin', id: 'skin_ninja', icon: 'ü•∑', name: 'Shadow Ninja'} },
            
            // Tier 11-20 (Mid rewards)
            { tier: 11, free: {type: 'essence', amount: 150, icon: '‚ú®', name: '150 Essence'}, premium: {type: 'essence', amount: 350, icon: 'üíé', name: '350 Essence'} },
            { tier: 12, free: null, premium: {type: 'skin', id: 'weapon_flame', icon: 'üî•', name: 'Inferno Gun'} },
            { tier: 13, free: {type: 'essence', amount: 200, icon: '‚ú®', name: '200 Essence'}, premium: {type: 'essence', amount: 400, icon: 'üíé', name: '400 Essence'} },
            { tier: 14, free: {type: 'perk', id: 'perk_health', icon: '‚ù§Ô∏è', name: 'Extra Life'}, premium: {type: 'essence', amount: 450, icon: 'üíé', name: '450 Essence'} },
            { tier: 15, free: {type: 'essence', amount: 250, icon: '‚ú®', name: '250 Essence'}, premium: {type: 'skin', id: 'skin_knight', icon: '‚öîÔ∏è', name: 'Plasma Knight'} },
            { tier: 16, free: null, premium: {type: 'essence', amount: 500, icon: 'üíé', name: '500 Essence'} },
            { tier: 17, free: {type: 'essence', amount: 300, icon: '‚ú®', name: '300 Essence'}, premium: {type: 'perk', id: 'perk_damage', icon: 'üí™', name: 'Power Boost'} },
            { tier: 18, free: {type: 'skin', id: 'weapon_void', icon: 'üåå', name: 'Void Cannon'}, premium: {type: 'essence', amount: 550, icon: 'üíé', name: '550 Essence'} },
            { tier: 19, free: {type: 'essence', amount: 350, icon: '‚ú®', name: '350 Essence'}, premium: {type: 'essence', amount: 600, icon: 'üíé', name: '600 Essence'} },
            { tier: 20, free: {type: 'essence', amount: 400, icon: '‚ú®', name: '400 Essence'}, premium: {type: 'skin', id: 'skin_space', icon: 'üëæ', name: 'Space Marine'} },
            
            // Tier 21-30 (Advanced rewards)
            { tier: 21, free: {type: 'essence', amount: 300, icon: '‚ú®', name: '300 Essence'}, premium: {type: 'essence', amount: 650, icon: 'üíé', name: '650 Essence'} },
            { tier: 22, free: null, premium: {type: 'perk', id: 'perk_xpbonus', icon: '‚≠ê', name: 'Fast Learner'} },
            { tier: 23, free: {type: 'essence', amount: 350, icon: '‚ú®', name: '350 Essence'}, premium: {type: 'essence', amount: 700, icon: 'üíé', name: '700 Essence'} },
            { tier: 24, free: {type: 'perk', id: 'perk_buildpoints', icon: 'üèóÔ∏è', name: 'Architect'}, premium: {type: 'essence', amount: 750, icon: 'üíé', name: '750 Essence'} },
            { tier: 25, free: {type: 'essence', amount: 500, icon: '‚ú®', name: '500 Essence'}, premium: {type: 'skin', id: 'skin_ghost', icon: 'üëª', name: 'Phantom'} },
            { tier: 26, free: null, premium: {type: 'essence', amount: 800, icon: 'üíé', name: '800 Essence'} },
            { tier: 27, free: {type: 'essence', amount: 400, icon: '‚ú®', name: '400 Essence'}, premium: {type: 'essence', amount: 850, icon: 'üíé', name: '850 Essence'} },
            { tier: 28, free: {type: 'essence', amount: 450, icon: '‚ú®', name: '450 Essence'}, premium: {type: 'perk', id: 'perk_startlevel', icon: 'üìà', name: 'Head Start'} },
            { tier: 29, free: {type: 'essence', amount: 500, icon: '‚ú®', name: '500 Essence'}, premium: {type: 'essence', amount: 900, icon: 'üíé', name: '900 Essence'} },
            { tier: 30, free: {type: 'skin', id: 'weapon_rainbow', icon: 'üåà', name: 'Prismatic Ray'}, premium: {type: 'skin', id: 'skin_demon', icon: 'üòà', name: 'Infernal'} },
            
            // Tier 31-40 (Elite rewards)
            { tier: 31, free: {type: 'essence', amount: 450, icon: '‚ú®', name: '450 Essence'}, premium: {type: 'essence', amount: 950, icon: 'üíé', name: '950 Essence'} },
            { tier: 32, free: null, premium: {type: 'essence', amount: 1000, icon: 'üíé', name: '1000 Essence'} },
            { tier: 33, free: {type: 'essence', amount: 500, icon: '‚ú®', name: '500 Essence'}, premium: {type: 'essence', amount: 1050, icon: 'üíé', name: '1050 Essence'} },
            { tier: 34, free: {type: 'essence', amount: 550, icon: '‚ú®', name: '550 Essence'}, premium: {type: 'essence', amount: 1100, icon: 'üíé', name: '1100 Essence'} },
            { tier: 35, free: {type: 'essence', amount: 600, icon: '‚ú®', name: '600 Essence'}, premium: {type: 'skin', id: 'skin_angel', icon: 'üòá', name: 'Celestial'} },
            { tier: 36, free: null, premium: {type: 'essence', amount: 1200, icon: 'üíé', name: '1200 Essence'} },
            { tier: 37, free: {type: 'essence', amount: 650, icon: '‚ú®', name: '650 Essence'}, premium: {type: 'essence', amount: 1300, icon: 'üíé', name: '1300 Essence'} },
            { tier: 38, free: {type: 'essence', amount: 700, icon: '‚ú®', name: '700 Essence'}, premium: {type: 'essence', amount: 1400, icon: 'üíé', name: '1400 Essence'} },
            { tier: 39, free: {type: 'essence', amount: 750, icon: '‚ú®', name: '750 Essence'}, premium: {type: 'essence', amount: 1500, icon: 'üíé', name: '1500 Essence'} },
            { tier: 40, free: {type: 'essence', amount: 1000, icon: '‚ú®', name: '1000 Essence'}, premium: {type: 'skin', id: 'skin_dragon', icon: 'üêâ', name: 'Dragon Soul'} },
            
            // Tier 41-49 (Legendary preparation)
            { tier: 41, free: {type: 'essence', amount: 800, icon: '‚ú®', name: '800 Essence'}, premium: {type: 'essence', amount: 1600, icon: 'üíé', name: '1600 Essence'} },
            { tier: 42, free: null, premium: {type: 'essence', amount: 1700, icon: 'üíé', name: '1700 Essence'} },
            { tier: 43, free: {type: 'essence', amount: 850, icon: '‚ú®', name: '850 Essence'}, premium: {type: 'essence', amount: 1800, icon: 'üíé', name: '1800 Essence'} },
            { tier: 44, free: {type: 'essence', amount: 900, icon: '‚ú®', name: '900 Essence'}, premium: {type: 'essence', amount: 1900, icon: 'üíé', name: '1900 Essence'} },
            { tier: 45, free: {type: 'essence', amount: 1000, icon: '‚ú®', name: '1000 Essence'}, premium: {type: 'essence', amount: 2000, icon: 'üíé', name: '2000 Essence'} },
            { tier: 46, free: null, premium: {type: 'essence', amount: 2100, icon: 'üíé', name: '2100 Essence'} },
            { tier: 47, free: {type: 'essence', amount: 1100, icon: '‚ú®', name: '1100 Essence'}, premium: {type: 'essence', amount: 2200, icon: 'üíé', name: '2200 Essence'} },
            { tier: 48, free: {type: 'essence', amount: 1200, icon: '‚ú®', name: '1200 Essence'}, premium: {type: 'essence', amount: 2300, icon: 'üíé', name: '2300 Essence'} },
            { tier: 49, free: {type: 'essence', amount: 1500, icon: '‚ú®', name: '1500 Essence'}, premium: {type: 'essence', amount: 2500, icon: 'üíé', name: '2500 Essence'} },
            
            // Tier 50 - MYTHIC REWARD
            { tier: 50, free: {type: 'skin', id: 'skin_voidwalker', icon: 'üåå', name: 'Voidwalker', mythic: true}, premium: {type: 'skin', id: 'skin_dragon', icon: 'üêâ', name: 'Dragon Soul + 3000‚ú®', essence: 3000} }
        ];
        
        function loadBattlePassData() {
            const saved = localStorage.getItem('plasmaBattlePass');
            if (saved) {
                battlePassData = JSON.parse(saved);
            }
        }
        
        function saveBattlePassData() {
            localStorage.setItem('plasmaBattlePass', JSON.stringify(battlePassData));
        }
        
        function addBattlePassXP(amount) {
            battlePassData.xp += amount;
            
            // Level up check with scaling XP requirements
            let xpRequired = getXPRequiredForTier(battlePassData.tier);
            
            while (battlePassData.xp >= xpRequired && battlePassData.tier < 50) {
                battlePassData.xp -= xpRequired;
                battlePassData.tier++;
                
                showNotification(`üèÜ BATTLE PASS TIER ${battlePassData.tier}!\nNew rewards unlocked!`, 3000);
                screenShake = 15;
                
                // Update XP requirement for next tier
                xpRequired = getXPRequiredForTier(battlePassData.tier);
            }
            
            // Cap at tier 50
            if (battlePassData.tier >= 50) {
                battlePassData.tier = 50;
                battlePassData.xp = 0;
            }
            
            saveBattlePassData();
        }
        
        // Calculate XP required for a specific tier (doubles every 10 tiers)
        function getXPRequiredForTier(tier) {
            const baseTier = Math.floor(tier / 10); // 0-9 = 0, 10-19 = 1, 20-29 = 2, etc.
            const baseXP = 1000;
            return baseXP * Math.pow(2, baseTier); // 1000, 2000, 4000, 8000, 16000
        }
        
        function showBattlePass() {
            document.getElementById('battlePassModal').classList.remove('hidden');
            loadBattlePassData();
            updateBattlePassUI();
        }
        
        function closeBattlePass() {
            document.getElementById('battlePassModal').classList.add('hidden');
        }
        
        function updateBattlePassUI() {
            // Calculate XP required for current tier
            const xpRequired = getXPRequiredForTier(battlePassData.tier);
            
            // Update header info
            document.getElementById('battlePassTier').textContent = battlePassData.tier;
            document.getElementById('battlePassCurrentXP').textContent = battlePassData.xp;
            document.getElementById('battlePassRequiredXP').textContent = xpRequired;
            
            // Update XP bar
            const xpPercent = (battlePassData.xp / xpRequired) * 100;
            document.getElementById('battlePassXPBar').style.width = xpPercent + '%';
            
            // Update status
            const statusEl = document.getElementById('battlePassStatus');
            if (battlePassData.premium) {
                statusEl.classList.add('premium');
                statusEl.innerHTML = '<span class="status-icon">‚≠ê</span><span class="status-text">PREMIUM</span>';
                document.getElementById('premiumBanner').classList.add('hidden');
            } else {
                statusEl.classList.remove('premium');
                statusEl.innerHTML = '<span class="status-icon">üîí</span><span class="status-text">FREE TRACK</span>';
                document.getElementById('premiumBanner').classList.remove('hidden');
                
                // Update ad progress
                const adsWatched = battlePassData.premiumAdsWatched || 0;
                const progressEl = document.getElementById('premiumAdProgress');
                if (progressEl) {
                    progressEl.textContent = `üì∫ ${adsWatched}/10 Ads`;
                }
            }
            
            // Render tiers
            renderBattlePassTiers();
        }
        
        function renderBattlePassTiers() {
            const content = document.getElementById('battlePassContent');
            let html = '';
            
            BATTLE_PASS_REWARDS.forEach((tierData, index) => {
                const tier = tierData.tier;
                const isUnlocked = battlePassData.tier >= tier;
                
                html += `
                    <div class="battlepass-tier">
                        <div class="tier-number-label">TIER ${tier}</div>
                        <div class="tier-rewards">
                            ${tier > 1 ? '<div class="tier-line"></div>' : ''}
                            
                            <!-- Free Reward -->
                            ${renderReward(tierData.free, 'free', tier, isUnlocked)}
                            
                            <!-- Premium Reward -->
                            ${renderReward(tierData.premium, 'premium', tier, isUnlocked)}
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }
        
        function renderReward(reward, track, tier, isUnlocked) {
            if (!reward) {
                return `
                    <div class="tier-reward locked ${track}">
                        <div class="reward-track-label ${track}">${track.toUpperCase()}</div>
                        <div class="reward-lock-icon">‚îÅ</div>
                        <div class="reward-name">No Reward</div>
                    </div>
                `;
            }
            
            const rewardId = `${track}_${tier}`;
            const isClaimed = battlePassData.claimedRewards.includes(rewardId);
            const canClaim = isUnlocked && (track === 'free' || battlePassData.premium) && !isClaimed;
            
            let statusHTML = '';
            let rewardClass = `tier-reward ${track}`;
            
            if (reward.mythic) {
                rewardClass += ' mythic';
            }
            
            if (isClaimed) {
                rewardClass += ' claimed';
                statusHTML = '<div class="reward-status claimed">‚úì CLAIMED</div>';
            } else if (canClaim) {
                rewardClass += ' unlocked';
                statusHTML = `<div class="reward-status unlocked" onclick="claimBattlePassReward(${tier}, '${track}')">CLAIM</div>`;
            } else if (!isUnlocked) {
                rewardClass += ' locked';
                statusHTML = '<div class="reward-status locked">üîí LOCKED</div>';
            } else if (track === 'premium' && !battlePassData.premium) {
                rewardClass += ' locked';
                statusHTML = '<div class="reward-status locked">‚≠ê PREMIUM</div>';
            }
            
            return `
                <div class="${rewardClass}">
                    <div class="reward-track-label ${track}${reward.mythic ? ' mythic' : ''}">${reward.mythic ? 'MYTHIC' : track.toUpperCase()}</div>
                    <div class="reward-icon">${reward.icon}</div>
                    <div class="reward-name">${reward.name}</div>
                    <div class="reward-desc">${reward.desc || ''}</div>
                    ${statusHTML}
                </div>
            `;
        }
        
        function claimBattlePassReward(tier, track) {
            const tierData = BATTLE_PASS_REWARDS.find(t => t.tier === tier);
            if (!tierData) return;
            
            const reward = track === 'free' ? tierData.free : tierData.premium;
            if (!reward) return;
            
            const rewardId = `${track}_${tier}`;
            if (battlePassData.claimedRewards.includes(rewardId)) return;
            
            // Grant reward
            if (reward.type === 'essence') {
                const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + reward.amount;
                localStorage.setItem('plasmaSpecialCurrency', essence);
                updateStoreCurrency();
                updateMainMenuStats();
                showNotification(`‚ú® Claimed ${reward.amount} Essence!`, 2000);
            } else if (reward.type === 'skin' || reward.type === 'perk') {
                purchasedItems[reward.id] = true;
                savePurchasedItems();
                
                // Grant bonus essence if reward has it
                if (reward.essence) {
                    const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + reward.essence;
                    localStorage.setItem('plasmaSpecialCurrency', essence);
                    updateStoreCurrency();
                    updateMainMenuStats();
                }
                
                if (reward.mythic) {
                    showNotification(`üåå MYTHIC UNLOCKED!\n${reward.name}\nYou are legendary!`, 5000);
                    screenShake = 40;
                } else {
                    const bonusText = reward.essence ? ` + ${reward.essence}‚ú®` : '';
                    showNotification(`‚úì Claimed ${reward.name}${bonusText}!`, 2000);
                }
            }
            
            // Mark as claimed
            battlePassData.claimedRewards.push(rewardId);
            saveBattlePassData();
            updateBattlePassUI();
        }
        
        function unlockPremiumBattlePass() {
            const adsRequired = 10;
            const adsWatched = battlePassData.premiumAdsWatched || 0;
            const adsRemaining = adsRequired - adsWatched;
            
            if (battlePassData.premium) {
                showNotification('‚≠ê You already have Premium!', 2000);
                return;
            }
            
            if (adsRemaining > 0) {
                if (!confirm(`Watch an ad to unlock Premium Battle Pass!\n\nüì∫ Progress: ${adsWatched}/${adsRequired} ads\n‚ú® ${adsRemaining} more ads to unlock\n\nüêâ Dragon Soul + 3000‚ú® at Tier 50\nüíé 2x More Essence & Exclusive Skins\n‚≠ê Premium Perks`)) {
                    return;
                }
                
                // Show ad
                showNotification('üì∫ Loading ad...', 1000);
                
                showCrazyGamesRewardedAd(() => {
                    // Grant reward: Premium progress
                    battlePassData.premiumAdsWatched++;
                    saveBattlePassData();
                    
                    const newRemaining = adsRequired - battlePassData.premiumAdsWatched;
                    
                    if (newRemaining === 0) {
                        // Unlocked!
                        battlePassData.premium = true;
                        saveBattlePassData();
                        showNotification('‚≠ê PREMIUM UNLOCKED!\nAll premium rewards are now available!', 4000);
                        screenShake = 30;
                    } else {
                        showNotification(`üì∫ Ad watched!\n${newRemaining} more ads to unlock Premium!`, 3000);
                    }
                    
                    updateBattlePassUI();
                    updateBattlePassCard(); // Update main menu card
                    
                    console.log(`‚úÖ Battle Pass Premium ad watched: ${battlePassData.premiumAdsWatched}/${adsRequired}`);
                });
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SKIN DRAWING SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function drawPlayerWithSkin(ctx, px, py, bodySize, idleFrame) {
            const currentSkin = equippedItems.skin || 'default';
            const breathe = Math.sin(idleFrame * 0.05) * 1.5;
            
            // Call appropriate skin function
            switch(currentSkin) {
                case 'skin_cyborg':
                    drawCyborgSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_ninja':
                    drawNinjaSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_knight':
                    drawKnightSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_space':
                    drawSpaceMarineSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_ghost':
                    drawPhantomSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_demon':
                    drawInfernalSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_angel':
                    drawCelestialSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_dragon':
                    drawDragonSoulSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_voidwalker':
                    drawVoidwalkerSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                // MYTHIC SKINS
                case 'skin_cosmic':
                    drawCosmicEmperorSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_phoenix':
                    drawPhoenixAscendantSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_storm':
                    drawStormSovereignSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_shadow':
                    drawShadowOverlordSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                case 'skin_prismatic':
                    drawPrismaticGodSkin(ctx, px, py, bodySize, idleFrame, breathe);
                    break;
                default:
                    drawDefaultSkin(ctx, px, py, bodySize, idleFrame, breathe);
            }
        }
        
        // Default Skin - Cyan soldier
        function drawDefaultSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            
            // Body
            const grad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            grad.addColorStop(0, '#4db8ff');
            grad.addColorStop(1, '#0088cc');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#0088cc';
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            const eyeGlow = 0.8 + Math.sin(idleFrame * 0.1) * 0.2;
            ctx.fillStyle = `rgba(0, 255, 255, ${eyeGlow})`;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 8;
            ctx.fillRect(px - 12, py - 10 + headBob, 24, 4);
            ctx.shadowBlur = 0;
        }
        
        // ü§ñ Cyborg - Futuristic with glowing parts
        function drawCyborgSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const pulse = Math.sin(idleFrame * 0.15) * 5;
            
            // Energy core (glowing)
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20 + pulse;
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Metal body
            const metalGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            metalGrad.addColorStop(0, '#8899aa');
            metalGrad.addColorStop(0.5, '#556677');
            metalGrad.addColorStop(1, '#334455');
            ctx.fillStyle = metalGrad;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            
            // Tech panels
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(px + Math.cos(angle) * (bodySize - 5), py + Math.sin(angle) * (bodySize - 5), 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Cyborg head (angular)
            ctx.fillStyle = '#667788';
            ctx.fillRect(px - 14, py - 22 + headBob, 28, 28);
            
            // Visor (glowing red scanner)
            const scannerPulse = 0.7 + Math.sin(idleFrame * 0.2) * 0.3;
            ctx.fillStyle = `rgba(255, 0, 0, ${scannerPulse})`;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillRect(px - 12, py - 12 + headBob, 24, 6);
            ctx.shadowBlur = 0;
            
            // Scanning line
            const scanLine = ((idleFrame * 2) % 24);
            ctx.fillStyle = '#ff3333';
            ctx.fillRect(px - 12 + scanLine, py - 12 + headBob, 2, 6);
            
            // Antenna
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py - 22 + headBob);
            ctx.lineTo(px, py - 30 + headBob);
            ctx.stroke();
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(px, py - 30 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ü•∑ Ninja - Dark with motion blur
        function drawNinjaSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            
            // Motion blur effect
            ctx.globalAlpha = 0.3;
            for(let i = 0; i < 3; i++) {
                const offset = (i - 1) * 3;
                ctx.fillStyle = '#1a0033';
                ctx.beginPath();
                ctx.arc(px + offset, py, bodySize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // Main body (dark purple)
            const ninjaGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            ninjaGrad.addColorStop(0, '#4a0080');
            ninjaGrad.addColorStop(1, '#1a0033');
            ctx.fillStyle = ninjaGrad;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            
            // Ninja mask wraps
            ctx.strokeStyle = '#2a0055';
            ctx.lineWidth = 3;
            for(let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(px, py, bodySize - (i * 5), 0, Math.PI);
                ctx.stroke();
            }
            
            // Head (wrapped)
            ctx.fillStyle = '#1a0033';
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes (glowing white)
            const eyeGlow = 0.9 + Math.sin(idleFrame * 0.15) * 0.1;
            ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(px - 5, py - 10 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 5, py - 10 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Smoke particles
            for(let i = 0; i < 3; i++) {
                const smokeOffset = (idleFrame + i * 20) % 60;
                ctx.globalAlpha = 0.3 - (smokeOffset / 60) * 0.3;
                ctx.fillStyle = '#4a0080';
                ctx.beginPath();
                ctx.arc(px + (Math.random() - 0.5) * 20, py + bodySize + smokeOffset, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        // ‚öîÔ∏è Knight - Medieval with shining armor
        function drawKnightSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const shine = Math.sin(idleFrame * 0.1) * 0.3;
            
            // Cape (flowing)
            const capeWave = Math.sin(idleFrame * 0.08) * 3;
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(px - bodySize, py - bodySize + 10);
            ctx.quadraticCurveTo(px - bodySize - 15, py + capeWave, px - bodySize - 10, py + bodySize);
            ctx.quadraticCurveTo(px, py + bodySize + 10, px + bodySize + 10, py + bodySize);
            ctx.quadraticCurveTo(px + bodySize + 15, py + capeWave, px + bodySize, py - bodySize + 10);
            ctx.fill();
            
            // Armor (silver with shine)
            const armorGrad = ctx.createRadialGradient(px - 5, py - 5, 0, px, py, bodySize);
            armorGrad.addColorStop(0, `rgba(220, 220, 240, ${1 + shine})`);
            armorGrad.addColorStop(0.5, '#b8b8d0');
            armorGrad.addColorStop(1, '#888899');
            ctx.fillStyle = armorGrad;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            
            // Armor plates
            ctx.strokeStyle = '#666677';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(px, py, bodySize - 3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Gold trim
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(px, py, bodySize + 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Helmet
            ctx.fillStyle = '#888899';
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 16, 0, Math.PI * 2);
            ctx.fill();
            
            // Helmet crest
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(px - 10, py - 20 + headBob);
            ctx.lineTo(px, py - 28 + headBob);
            ctx.lineTo(px + 10, py - 20 + headBob);
            ctx.fill();
            
            // Visor slit (glowing)
            ctx.fillStyle = '#ffaa00';
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 10;
            ctx.fillRect(px - 12, py - 10 + headBob, 24, 4);
            ctx.shadowBlur = 0;
            
            // Shield emblem (cross)
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.moveTo(px, py - 5);
            ctx.lineTo(px, py + 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px - 5, py + 2);
            ctx.lineTo(px + 5, py + 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        // üëæ Space Marine - Sci-fi with energy shields
        function drawSpaceMarineSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const shieldPulse = Math.sin(idleFrame * 0.12) * 5;
            
            // Energy shield (hexagonal)
            ctx.strokeStyle = `rgba(0, 150, 255, 0.5)`;
            ctx.lineWidth = 2;
            ctx.shadowColor = '#0096ff';
            ctx.shadowBlur = 15 + shieldPulse;
            ctx.beginPath();
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = px + Math.cos(angle) * (bodySize + 8);
                const y = py + Math.sin(angle) * (bodySize + 8);
                if(i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Power armor (dark blue)
            const armorGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            armorGrad.addColorStop(0, '#0066cc');
            armorGrad.addColorStop(1, '#003366');
            ctx.fillStyle = armorGrad;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            
            // Tech lines
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ccff';
            ctx.shadowBlur = 8;
            for(let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + Math.cos(angle) * bodySize, py + Math.sin(angle) * bodySize);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Helmet (angular)
            ctx.fillStyle = '#002244';
            const helmWidth = 18;
            const helmHeight = 20;
            ctx.fillRect(px - helmWidth/2, py - 20 + headBob, helmWidth, helmHeight);
            
            // Visor (HUD style)
            const hudPulse = 0.8 + Math.sin(idleFrame * 0.15) * 0.2;
            ctx.fillStyle = `rgba(0, 255, 100, ${hudPulse})`;
            ctx.shadowColor = '#00ff64';
            ctx.shadowBlur = 12;
            ctx.fillRect(px - 14, py - 14 + headBob, 28, 8);
            ctx.shadowBlur = 0;
            
            // HUD elements
            ctx.strokeStyle = '#00ff64';
            ctx.lineWidth = 1;
            ctx.strokeRect(px - 12, py - 12 + headBob, 10, 4);
            ctx.strokeRect(px + 2, py - 12 + headBob, 10, 4);
            
            // Shoulder lights
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(px - bodySize + 5, py - bodySize + 8, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + bodySize - 5, py - bodySize + 8, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üëª Phantom - Ethereal with transparency
        function drawPhantomSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const float = Math.sin(idleFrame * 0.05) * 8;
            const fadeWave = Math.sin(idleFrame * 0.08) * 0.2;
            
            // Ghostly trail
            ctx.globalAlpha = 0.2;
            for(let i = 0; i < 5; i++) {
                const trailY = py + (i * 5) + float;
                ctx.fillStyle = `rgba(180, 150, 255, ${0.3 - i * 0.05})`;
                ctx.beginPath();
                ctx.arc(px, trailY, bodySize - (i * 2), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            // Main ethereal body
            ctx.globalAlpha = 0.7 + fadeWave;
            const ghostGrad = ctx.createRadialGradient(px, py + float, 0, px, py + float, bodySize);
            ghostGrad.addColorStop(0, 'rgba(200, 180, 255, 0.9)');
            ghostGrad.addColorStop(0.5, 'rgba(150, 130, 200, 0.7)');
            ghostGrad.addColorStop(1, 'rgba(100, 80, 150, 0.3)');
            ctx.fillStyle = ghostGrad;
            ctx.shadowColor = '#b4a6ff';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(px, py + float, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Spectral wisps
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + idleFrame * 0.02;
                const wispDist = bodySize + 10 + Math.sin(idleFrame * 0.1 + i) * 5;
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#b4a6ff';
                ctx.shadowColor = '#b4a6ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(px + Math.cos(angle) * wispDist, py + float + Math.sin(angle) * wispDist, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Phantom face
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = 'rgba(180, 160, 220, 0.8)';
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob + float, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // Hollow eyes (glowing)
            const eyeGlow = 0.8 + Math.sin(idleFrame * 0.1) * 0.2;
            ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(px - 5, py - 10 + headBob + float, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 5, py - 10 + headBob + float, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }
        
        // üòà Infernal - Demonic with flames
        function drawInfernalSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const flamePulse = Math.sin(idleFrame * 0.15) * 8;
            
            // Flame aura
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + idleFrame * 0.05;
                const flameDist = bodySize + 10 + Math.sin(idleFrame * 0.2 + i) * 8;
                ctx.globalAlpha = 0.6;
                const flameSize = 8 + Math.random() * 4;
                const flameGrad = ctx.createRadialGradient(
                    px + Math.cos(angle) * flameDist, 
                    py + Math.sin(angle) * flameDist, 
                    0, 
                    px + Math.cos(angle) * flameDist, 
                    py + Math.sin(angle) * flameDist, 
                    flameSize
                );
                flameGrad.addColorStop(0, '#ffff00');
                flameGrad.addColorStop(0.5, '#ff6600');
                flameGrad.addColorStop(1, '#ff0000');
                ctx.fillStyle = flameGrad;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(px + Math.cos(angle) * flameDist, py + Math.sin(angle) * flameDist, flameSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Demonic body (dark red)
            const demonGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            demonGrad.addColorStop(0, '#cc0000');
            demonGrad.addColorStop(0.5, '#8b0000');
            demonGrad.addColorStop(1, '#440000');
            ctx.fillStyle = demonGrad;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15 + flamePulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Lava cracks
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 10;
            for(let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + Math.cos(angle) * bodySize, py + Math.sin(angle) * bodySize);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Horned head
            ctx.fillStyle = '#660000';
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 16, 0, Math.PI * 2);
            ctx.fill();
            
            // Horns
            ctx.fillStyle = '#220000';
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 8;
            // Left horn
            ctx.beginPath();
            ctx.moveTo(px - 12, py - 15 + headBob);
            ctx.quadraticCurveTo(px - 18, py - 25 + headBob, px - 15, py - 30 + headBob);
            ctx.lineTo(px - 14, py - 28 + headBob);
            ctx.quadraticCurveTo(px - 16, py - 23 + headBob, px - 11, py - 15 + headBob);
            ctx.fill();
            ctx.stroke();
            // Right horn
            ctx.beginPath();
            ctx.moveTo(px + 12, py - 15 + headBob);
            ctx.quadraticCurveTo(px + 18, py - 25 + headBob, px + 15, py - 30 + headBob);
            ctx.lineTo(px + 14, py - 28 + headBob);
            ctx.quadraticCurveTo(px + 16, py - 23 + headBob, px + 11, py - 15 + headBob);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Fiery eyes
            const eyeFire = 0.9 + Math.sin(idleFrame * 0.2) * 0.1;
            ctx.fillStyle = `rgba(255, 200, 0, ${eyeFire})`;
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(px - 6, py - 10 + headBob, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 6, py - 10 + headBob, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üòá Celestial - Divine with holy light
        function drawCelestialSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const holyPulse = Math.sin(idleFrame * 0.1) * 10;
            
            // Divine rays
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(idleFrame * 0.02);
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.globalAlpha = 0.3;
                const rayGrad = ctx.createLinearGradient(0, 0, Math.cos(angle) * (bodySize + 30), Math.sin(angle) * (bodySize + 30));
                rayGrad.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
                rayGrad.addColorStop(1, 'rgba(255, 255, 200, 0)');
                ctx.fillStyle = rayGrad;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle - 0.1) * (bodySize + 30), Math.sin(angle - 0.1) * (bodySize + 30));
                ctx.lineTo(Math.cos(angle + 0.1) * (bodySize + 30), Math.sin(angle + 0.1) * (bodySize + 30));
                ctx.fill();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            
            // Holy aura rings
            for(let i = 0; i < 3; i++) {
                ctx.globalAlpha = 0.3 - i * 0.1;
                ctx.strokeStyle = '#ffffcc';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffffcc';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(px, py, bodySize + 10 + i * 8 + holyPulse, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Angelic body (pure white/gold)
            const angelGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            angelGrad.addColorStop(0, '#ffffff');
            angelGrad.addColorStop(0.5, '#ffffdd');
            angelGrad.addColorStop(1, '#ffeeaa');
            ctx.fillStyle = angelGrad;
            ctx.shadowColor = '#ffffcc';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Wings (graceful)
            const wingBeat = Math.sin(idleFrame * 0.08) * 0.15;
            ctx.save();
            ctx.translate(px, py);
            
            // Left wing
            ctx.globalAlpha = 0.8;
            const leftWingGrad = ctx.createLinearGradient(-bodySize - 30, -10, -bodySize, 0);
            leftWingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            leftWingGrad.addColorStop(1, 'rgba(255, 255, 200, 0.6)');
            ctx.fillStyle = leftWingGrad;
            ctx.shadowColor = '#ffffcc';
            ctx.shadowBlur = 15;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-bodySize, 0);
                ctx.quadraticCurveTo(-bodySize - 25 + wingBeat * 10, -15 - i * 8, -bodySize - 20 + wingBeat * 15, -25 - i * 8);
                ctx.quadraticCurveTo(-bodySize - 30, -18 - i * 8, -bodySize - 8, 5);
                ctx.fill();
            }
            
            // Right wing
            const rightWingGrad = ctx.createLinearGradient(bodySize + 30, -10, bodySize, 0);
            rightWingGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            rightWingGrad.addColorStop(1, 'rgba(255, 255, 200, 0.6)');
            ctx.fillStyle = rightWingGrad;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(bodySize, 0);
                ctx.quadraticCurveTo(bodySize + 25 - wingBeat * 10, -15 - i * 8, bodySize + 20 - wingBeat * 15, -25 - i * 8);
                ctx.quadraticCurveTo(bodySize + 30, -18 - i * 8, bodySize + 8, 5);
                ctx.fill();
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Halo
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(px, py - 30 + headBob, 18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Holy head
            ctx.fillStyle = '#ffffee';
            ctx.shadowColor = '#ffffcc';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Serene eyes (golden glow)
            const eyeGlow = 0.9 + Math.sin(idleFrame * 0.08) * 0.1;
            ctx.fillStyle = `rgba(255, 215, 0, ${eyeGlow})`;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(px - 5, py - 10 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 5, py - 10 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üêâ Dragon Soul - PREMIUM with scales and fire
        function drawDragonSoulSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const dragonPulse = Math.sin(idleFrame * 0.12) * 10;
            
            // Dragon aura (swirling energy)
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(idleFrame * 0.03);
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const spiral = bodySize + 15 + Math.sin(idleFrame * 0.1 + i) * 10;
                ctx.globalAlpha = 0.4;
                const energyGrad = ctx.createRadialGradient(
                    Math.cos(angle) * spiral, 
                    Math.sin(angle) * spiral, 
                    0, 
                    Math.cos(angle) * spiral, 
                    Math.sin(angle) * spiral, 
                    12
                );
                energyGrad.addColorStop(0, '#ff6600');
                energyGrad.addColorStop(0.5, '#cc3300');
                energyGrad.addColorStop(1, 'rgba(200, 0, 0, 0)');
                ctx.fillStyle = energyGrad;
                ctx.shadowColor = '#ff3300';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * spiral, Math.sin(angle) * spiral, 12, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Dragon scales body
            const dragonGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            dragonGrad.addColorStop(0, '#cc3300');
            dragonGrad.addColorStop(0.3, '#aa1100');
            dragonGrad.addColorStop(0.7, '#880000');
            dragonGrad.addColorStop(1, '#440000');
            ctx.fillStyle = dragonGrad;
            ctx.shadowColor = '#ff3300';
            ctx.shadowBlur = 20 + dragonPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Scale patterns (hexagonal)
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 1.5;
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 5;
            for(let ring = 0; ring < 3; ring++) {
                const scaleCount = 6 + ring * 6;
                for(let i = 0; i < scaleCount; i++) {
                    const angle = (i / scaleCount) * Math.PI * 2;
                    const dist = (ring + 1) * 8;
                    const scaleSize = 4;
                    ctx.beginPath();
                    for(let j = 0; j < 6; j++) {
                        const scaleAngle = (j / 6) * Math.PI * 2;
                        const sx = px + Math.cos(angle) * dist + Math.cos(scaleAngle) * scaleSize;
                        const sy = py + Math.sin(angle) * dist + Math.sin(scaleAngle) * scaleSize;
                        if(j === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            ctx.shadowBlur = 0;
            
            // Draconic wings (majestic)
            const wingFlap = Math.sin(idleFrame * 0.1) * 0.2;
            ctx.save();
            ctx.translate(px, py);
            
            // Left wing (leathery with membrane)
            ctx.globalAlpha = 0.9;
            const leftWingGrad = ctx.createLinearGradient(-bodySize - 40, -20, -bodySize, 0);
            leftWingGrad.addColorStop(0, 'rgba(136, 0, 0, 0.9)');
            leftWingGrad.addColorStop(0.5, 'rgba(200, 50, 0, 0.7)');
            leftWingGrad.addColorStop(1, 'rgba(136, 0, 0, 0.5)');
            ctx.fillStyle = leftWingGrad;
            ctx.shadowColor = '#ff3300';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(-bodySize, -5);
            ctx.quadraticCurveTo(-bodySize - 35 + wingFlap * 15, -25, -bodySize - 40 + wingFlap * 20, -35);
            ctx.quadraticCurveTo(-bodySize - 45 + wingFlap * 20, -20, -bodySize - 35, -10);
            ctx.quadraticCurveTo(-bodySize - 40, 5, -bodySize - 20, 10);
            ctx.quadraticCurveTo(-bodySize - 10, 15, -bodySize, 10);
            ctx.fill();
            
            // Wing bones/spines
            ctx.strokeStyle = '#220000';
            ctx.lineWidth = 3;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(-bodySize, -5);
                ctx.lineTo(-bodySize - 30 - i * 5 + wingFlap * 15, -30 + i * 8);
                ctx.stroke();
            }
            
            // Right wing
            const rightWingGrad = ctx.createLinearGradient(bodySize + 40, -20, bodySize, 0);
            rightWingGrad.addColorStop(0, 'rgba(136, 0, 0, 0.9)');
            rightWingGrad.addColorStop(0.5, 'rgba(200, 50, 0, 0.7)');
            rightWingGrad.addColorStop(1, 'rgba(136, 0, 0, 0.5)');
            ctx.fillStyle = rightWingGrad;
            ctx.beginPath();
            ctx.moveTo(bodySize, -5);
            ctx.quadraticCurveTo(bodySize + 35 - wingFlap * 15, -25, bodySize + 40 - wingFlap * 20, -35);
            ctx.quadraticCurveTo(bodySize + 45 - wingFlap * 20, -20, bodySize + 35, -10);
            ctx.quadraticCurveTo(bodySize + 40, 5, bodySize + 20, 10);
            ctx.quadraticCurveTo(bodySize + 10, 15, bodySize, 10);
            ctx.fill();
            
            // Wing bones
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(bodySize, -5);
                ctx.lineTo(bodySize + 30 + i * 5 - wingFlap * 15, -30 + i * 8);
                ctx.stroke();
            }
            
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Dragon head (fierce)
            ctx.fillStyle = '#990000';
            ctx.shadowColor = '#ff3300';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 17, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Horns (curved)
            ctx.fillStyle = '#330000';
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;
            // Left horn
            ctx.beginPath();
            ctx.moveTo(px - 14, py - 16 + headBob);
            ctx.quadraticCurveTo(px - 22, py - 30 + headBob, px - 18, py - 35 + headBob);
            ctx.lineTo(px - 17, py - 33 + headBob);
            ctx.quadraticCurveTo(px - 20, py - 28 + headBob, px - 13, py - 16 + headBob);
            ctx.fill();
            ctx.stroke();
            // Right horn
            ctx.beginPath();
            ctx.moveTo(px + 14, py - 16 + headBob);
            ctx.quadraticCurveTo(px + 22, py - 30 + headBob, px + 18, py - 35 + headBob);
            ctx.lineTo(px + 17, py - 33 + headBob);
            ctx.quadraticCurveTo(px + 20, py - 28 + headBob, px + 13, py - 16 + headBob);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Dragon eyes (fierce glow)
            const dragonEyeGlow = 0.9 + Math.sin(idleFrame * 0.15) * 0.1;
            ctx.fillStyle = `rgba(255, 100, 0, ${dragonEyeGlow})`;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            // Cat-like slitted pupils
            ctx.fillRect(px - 7, py - 12 + headBob, 2, 8);
            ctx.fillRect(px + 5, py - 12 + headBob, 2, 8);
            // Outer glow
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(px - 6, py - 8 + headBob, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 6, py - 8 + headBob, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Fire breath particles (emanating)
            for(let i = 0; i < 5; i++) {
                const breathOffset = ((idleFrame + i * 10) % 40);
                ctx.globalAlpha = 0.6 - (breathOffset / 40) * 0.6;
                const particleSize = 3 + (breathOffset / 40) * 5;
                const breathGrad = ctx.createRadialGradient(
                    px + breathOffset - 20, 
                    py - 5 + headBob + (Math.random() - 0.5) * 5, 
                    0, 
                    px + breathOffset - 20, 
                    py - 5 + headBob + (Math.random() - 0.5) * 5, 
                    particleSize
                );
                breathGrad.addColorStop(0, '#ffff00');
                breathGrad.addColorStop(0.5, '#ff6600');
                breathGrad.addColorStop(1, '#ff0000');
                ctx.fillStyle = breathGrad;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(px + breathOffset - 20, py - 5 + headBob + (Math.random() - 0.5) * 5, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        // üåå Voidwalker - MYTHIC reality bender
        function drawVoidwalkerSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const voidPulse = Math.sin(idleFrame * 0.08) * 15;
            const realityShift = Math.sin(idleFrame * 0.05) * 3;
            
            // Reality distortion field (warping space)
            ctx.save();
            ctx.translate(px, py);
            
            // Outer void rings (expanding/contracting)
            for(let i = 0; i < 5; i++) {
                const ringSize = bodySize + 20 + i * 15 + voidPulse;
                const ringAlpha = 0.3 - i * 0.05;
                ctx.globalAlpha = ringAlpha;
                const voidGrad = ctx.createRadialGradient(0, 0, ringSize - 10, 0, 0, ringSize);
                voidGrad.addColorStop(0, 'rgba(138, 43, 226, 0)');
                voidGrad.addColorStop(0.7, `rgba(75, 0, 130, ${ringAlpha})`);
                voidGrad.addColorStop(1, 'rgba(148, 0, 211, 0)');
                ctx.fillStyle = voidGrad;
                ctx.shadowColor = '#8a2be2';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Void particles (reality fragments)
            for(let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2 + idleFrame * 0.02;
                const orbit = bodySize + 25 + Math.sin(idleFrame * 0.1 + i) * 15;
                const particleSize = 2 + Math.random() * 3;
                ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                
                // Glitch effect - random color shifts
                const glitchColors = ['#8a2be2', '#4b0082', '#9400d3', '#00ffff', '#ff00ff'];
                const color = glitchColors[Math.floor(Math.random() * glitchColors.length)];
                
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(
                    px + Math.cos(angle) * orbit, 
                    py + Math.sin(angle) * orbit + realityShift, 
                    particleSize, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Cosmic void body (swirling galaxy)
            const voidBodyGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            voidBodyGrad.addColorStop(0, '#000000');
            voidBodyGrad.addColorStop(0.3, '#1a0033');
            voidBodyGrad.addColorStop(0.6, '#4b0082');
            voidBodyGrad.addColorStop(0.8, '#8a2be2');
            voidBodyGrad.addColorStop(1, '#000000');
            ctx.fillStyle = voidBodyGrad;
            ctx.shadowColor = '#8a2be2';
            ctx.shadowBlur = 40 + voidPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Void cracks (reality tears)
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(idleFrame * 0.01);
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * bodySize, Math.sin(angle) * bodySize);
                ctx.stroke();
                
                // Void energy at crack endpoints
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * bodySize, Math.sin(angle) * bodySize, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Galaxy spiral (swirling matter)
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(idleFrame * 0.03);
            for(let arm = 0; arm < 3; arm++) {
                const armAngle = (arm / 3) * Math.PI * 2;
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#8a2be2';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                for(let t = 0; t < 1; t += 0.05) {
                    const spiralAngle = armAngle + t * Math.PI * 2;
                    const spiralRadius = t * bodySize * 0.8;
                    const x = Math.cos(spiralAngle) * spiralRadius;
                    const y = Math.sin(spiralAngle) * spiralRadius;
                    if(t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Void tendrils (reality warpers)
            const tendrilCount = 6;
            for(let i = 0; i < tendrilCount; i++) {
                const angle = (i / tendrilCount) * Math.PI * 2 + idleFrame * 0.02;
                const wave = Math.sin(idleFrame * 0.1 + i) * 10;
                
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.6)';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#8a2be2';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(px + Math.cos(angle) * bodySize, py + Math.sin(angle) * bodySize);
                ctx.quadraticCurveTo(
                    px + Math.cos(angle) * (bodySize + 20) + wave,
                    py + Math.sin(angle) * (bodySize + 20),
                    px + Math.cos(angle) * (bodySize + 35),
                    py + Math.sin(angle) * (bodySize + 35) - wave
                );
                ctx.stroke();
                
                // Tendril tips (void energy)
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(
                    px + Math.cos(angle) * (bodySize + 35),
                    py + Math.sin(angle) * (bodySize + 35) - wave,
                    3,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // Void head (faceless cosmic entity)
            ctx.globalAlpha = 0.9;
            const headGrad = ctx.createRadialGradient(px, py - 8 + headBob, 0, px, py - 8 + headBob, 20);
            headGrad.addColorStop(0, '#000000');
            headGrad.addColorStop(0.5, '#1a0033');
            headGrad.addColorStop(1, '#4b0082');
            ctx.fillStyle = headGrad;
            ctx.shadowColor = '#8a2be2';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(px, py - 8 + headBob, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Void crown (reality shards)
            for(let i = 0; i < 7; i++) {
                const crownAngle = (i / 7) * Math.PI - Math.PI;
                const crownHeight = 15 + (i === 3 ? 10 : 0); // Middle shard taller
                const crownPulse = Math.sin(idleFrame * 0.15 + i * 0.5) * 3;
                
                ctx.fillStyle = '#00ffff';
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                ctx.moveTo(px + Math.cos(crownAngle) * 15, py - 20 + headBob);
                ctx.lineTo(px + Math.cos(crownAngle) * 10, py - 20 - crownHeight + headBob + crownPulse);
                ctx.lineTo(px + Math.cos(crownAngle) * 5, py - 20 + headBob);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Eyes (void portals - windows to other dimensions)
            const eyeGlitch = Math.random() > 0.95; // Random glitch effect
            const eyeSize = eyeGlitch ? 6 : 5;
            const eyeColor = eyeGlitch ? '#ff00ff' : '#00ffff';
            
            ctx.globalAlpha = 0.9 + Math.sin(idleFrame * 0.12) * 0.1;
            
            // Left eye
            const leftEyeGrad = ctx.createRadialGradient(px - 7, py - 10 + headBob, 0, px - 7, py - 10 + headBob, eyeSize);
            leftEyeGrad.addColorStop(0, eyeColor);
            leftEyeGrad.addColorStop(0.5, '#8a2be2');
            leftEyeGrad.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            ctx.fillStyle = leftEyeGrad;
            ctx.shadowColor = eyeColor;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(px - 7, py - 10 + headBob, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye void spiral
            ctx.save();
            ctx.translate(px - 7, py - 10 + headBob);
            ctx.rotate(idleFrame * 0.1);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for(let t = 0; t < 1; t += 0.1) {
                const spiralR = t * eyeSize;
                const spiralA = t * Math.PI * 4;
                const x = Math.cos(spiralA) * spiralR;
                const y = Math.sin(spiralA) * spiralR;
                if(t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
            
            // Right eye
            const rightEyeGrad = ctx.createRadialGradient(px + 7, py - 10 + headBob, 0, px + 7, py - 10 + headBob, eyeSize);
            rightEyeGrad.addColorStop(0, eyeColor);
            rightEyeGrad.addColorStop(0.5, '#8a2be2');
            rightEyeGrad.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            ctx.fillStyle = rightEyeGrad;
            ctx.shadowColor = eyeColor;
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(px + 7, py - 10 + headBob, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye void spiral
            ctx.save();
            ctx.translate(px + 7, py - 10 + headBob);
            ctx.rotate(-idleFrame * 0.1);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for(let t = 0; t < 1; t += 0.1) {
                const spiralR = t * eyeSize;
                const spiralA = t * Math.PI * 4;
                const x = Math.cos(spiralA) * spiralR;
                const y = Math.sin(spiralA) * spiralR;
                if(t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Void aura text (mysterious runes)
            const runes = ['‚ó¨', '‚óÆ', '‚ó≠', '‚óØ', '‚ó∞'];
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            for(let i = 0; i < 5; i++) {
                const runeAngle = (i / 5) * Math.PI * 2 + idleFrame * 0.03;
                const runeDist = bodySize + 40;
                const runeAlpha = 0.4 + Math.sin(idleFrame * 0.1 + i) * 0.3;
                ctx.globalAlpha = runeAlpha;
                ctx.fillStyle = '#8a2be2';
                ctx.shadowColor = '#8a2be2';
                ctx.shadowBlur = 15;
                ctx.fillText(
                    runes[i],
                    px + Math.cos(runeAngle) * runeDist,
                    py + Math.sin(runeAngle) * runeDist
                );
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Reality glitch effect (random screen tear)
            if(Math.random() > 0.98) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(px - 30, py + Math.random() * 40 - 20, 60, 2);
                ctx.globalAlpha = 1;
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MYTHIC SKINS (9000 Essence Each)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // üå† COSMIC EMPEROR - Master of galaxies
        function drawCosmicEmperorSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const cosmicPulse = Math.sin(idleFrame * 0.1) * 20;
            
            // Outer galaxy rings (rotating)
            for(let ring = 0; ring < 4; ring++) {
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(idleFrame * 0.01 * (ring % 2 === 0 ? 1 : -1));
                
                const ringSize = bodySize + 30 + ring * 20;
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.4 - ring * 0.08})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 25;
                
                for(let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringSize, angle, angle + 0.3);
                    ctx.stroke();
                }
                ctx.restore();
            }
            ctx.shadowBlur = 0;
            
            // Orbiting stars (24 points)
            for(let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2 + idleFrame * 0.03;
                const orbit = bodySize + 40 + Math.sin(idleFrame * 0.05 + i) * 20;
                const starSize = 3 + Math.sin(idleFrame * 0.2 + i) * 2;
                
                ctx.fillStyle = i % 3 === 0 ? '#ffffff' : '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(px + Math.cos(angle) * orbit, py + Math.sin(angle) * orbit, starSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // Main cosmic body (gold/purple nebula)
            const cosmicGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            cosmicGrad.addColorStop(0, '#ffffff');
            cosmicGrad.addColorStop(0.2, '#ffd700');
            cosmicGrad.addColorStop(0.5, '#ff6b00');
            cosmicGrad.addColorStop(0.7, '#8b00ff');
            cosmicGrad.addColorStop(1, '#000033');
            ctx.fillStyle = cosmicGrad;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 40 + cosmicPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Crown of stars
            ctx.save();
            ctx.translate(px, py - 30 + headBob);
            for(let i = 0; i < 7; i++) {
                const crownAngle = (i / 7) * Math.PI - Math.PI / 2;
                const crownDist = 20;
                const crownX = Math.cos(crownAngle) * crownDist;
                const crownY = Math.sin(crownAngle) * crownDist;
                
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                for(let s = 0; s < 5; s++) {
                    const starAngle = (s / 5) * Math.PI * 2 - Math.PI / 2;
                    const starRadius = s % 2 === 0 ? 8 : 4;
                    const sx = crownX + Math.cos(starAngle) * starRadius;
                    const sy = crownY + Math.sin(starAngle) * starRadius;
                    if(s === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Glowing eyes
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(px - 8, py - 5 + headBob, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 8, py - 5 + headBob, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üî•ü¶Ö PHOENIX ASCENDANT - Reborn from flames
        function drawPhoenixAscendantSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const flamePulse = Math.sin(idleFrame * 0.15) * 10;
            
            // Rising flames trail
            for(let i = 0; i < 30; i++) {
                const trailY = py + i * 8;
                const trailX = px + Math.sin(idleFrame * 0.1 + i * 0.3) * 15;
                const alpha = 1 - (i / 30);
                const size = 8 - (i * 0.2);
                
                const flameGrad = ctx.createRadialGradient(trailX, trailY, 0, trailX, trailY, size);
                flameGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                flameGrad.addColorStop(0.3, `rgba(255, 200, 0, ${alpha * 0.8})`);
                flameGrad.addColorStop(0.6, `rgba(255, 100, 0, ${alpha * 0.6})`);
                flameGrad.addColorStop(1, `rgba(255, 0, 0, 0)`);
                
                ctx.fillStyle = flameGrad;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // Wings (flame shaped)
            for(let wing = 0; wing < 2; wing++) {
                const wingX = wing === 0 ? -1 : 1;
                const wingBeat = Math.sin(idleFrame * 0.1 + wing * Math.PI) * 0.3;
                
                ctx.save();
                ctx.translate(px, py);
                ctx.scale(wingX, 1);
                
                for(let layer = 0; layer < 5; layer++) {
                    const layerAngle = 0.3 + layer * 0.2 + wingBeat;
                    const layerLength = 40 - layer * 5;
                    
                    const wingGrad = ctx.createLinearGradient(0, 0, layerLength, 0);
                    wingGrad.addColorStop(0, 'rgba(255, 200, 0, 0.9)');
                    wingGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.7)');
                    wingGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = wingGrad;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 20;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(layerLength * 0.5, -20 * Math.sin(layerAngle), layerLength, -15);
                    ctx.lineTo(layerLength, 15);
                    ctx.quadraticCurveTo(layerLength * 0.5, 20 * Math.sin(layerAngle), 0, 0);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            }
            ctx.shadowBlur = 0;
            
            // Blazing body
            const phoenixGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            phoenixGrad.addColorStop(0, '#ffffff');
            phoenixGrad.addColorStop(0.3, '#ffff00');
            phoenixGrad.addColorStop(0.6, '#ff6600');
            phoenixGrad.addColorStop(0.8, '#ff0000');
            phoenixGrad.addColorStop(1, '#cc0000');
            ctx.fillStyle = phoenixGrad;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 50 + flamePulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Phoenix crest
            ctx.save();
            ctx.translate(px, py - 20 + headBob);
            for(let i = 0; i < 5; i++) {
                const crestAngle = (i / 5) * Math.PI * 0.8 - Math.PI * 0.4;
                const crestLength = 15 + i * 3;
                
                ctx.strokeStyle = i % 2 === 0 ? '#ffff00' : '#ff6600';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.sin(crestAngle) * crestLength, -Math.cos(crestAngle) * crestLength);
                ctx.stroke();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Blazing eyes
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 30;
            ctx.fillRect(px - 10, py - 5 + headBob, 20, 4);
            ctx.shadowBlur = 0;
        }
        
        // ‚ö°üëë STORM SOVEREIGN - Thunder lord
        function drawStormSovereignSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const stormPulse = Math.sin(idleFrame * 0.2) * 15;
            
            // Storm clouds
            for(let i = 0; i < 8; i++) {
                const cloudAngle = (i / 8) * Math.PI * 2 + idleFrame * 0.03;
                const cloudDist = bodySize + 35 + Math.sin(idleFrame * 0.1 + i) * 10;
                const cloudX = px + Math.cos(cloudAngle) * cloudDist;
                const cloudY = py + Math.sin(cloudAngle) * cloudDist;
                
                ctx.fillStyle = 'rgba(100, 100, 130, 0.6)';
                ctx.shadowColor = '#6666aa';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.ellipse(cloudX, cloudY, 12, 8, cloudAngle, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // Lightning bolts
            if(idleFrame % 20 < 3) {
                for(let i = 0; i < 5; i++) {
                    const boltAngle = (i / 5) * Math.PI * 2;
                    const boltLength = 50;
                    
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 25;
                    
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    let currentX = px;
                    let currentY = py;
                    
                    for(let j = 0; j < 4; j++) {
                        const segmentLength = boltLength / 4;
                        const randomOffset = (Math.random() - 0.5) * 20;
                        const nextX = currentX + Math.cos(boltAngle) * segmentLength + randomOffset;
                        const nextY = currentY + Math.sin(boltAngle) * segmentLength + randomOffset;
                        ctx.lineTo(nextX, nextY);
                        currentX = nextX;
                        currentY = nextY;
                    }
                    ctx.stroke();
                }
            }
            ctx.shadowBlur = 0;
            
            // Electrified body
            const stormGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            stormGrad.addColorStop(0, '#ffffff');
            stormGrad.addColorStop(0.3, '#00ffff');
            stormGrad.addColorStop(0.6, '#0088ff');
            stormGrad.addColorStop(0.8, '#0044aa');
            stormGrad.addColorStop(1, '#001133');
            ctx.fillStyle = stormGrad;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 45 + stormPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Electric arcs
            for(let i = 0; i < 6; i++) {
                const arcAngle = (i / 6) * Math.PI * 2 + idleFrame * 0.1;
                const arcRadius = bodySize + 5;
                
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.arc(px, py, arcRadius, arcAngle, arcAngle + 0.5);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Lightning crown
            ctx.save();
            ctx.translate(px, py - 25 + headBob);
            for(let i = 0; i < 3; i++) {
                const crownX = (i - 1) * 15;
                
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.moveTo(crownX, 0);
                ctx.lineTo(crownX - 5, -10);
                ctx.lineTo(crownX + 5, -10);
                ctx.lineTo(crownX, -20);
                ctx.stroke();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Electric eyes
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(px - 7, py - 5 + headBob, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 7, py - 5 + headBob, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üåëüíÄ SHADOW OVERLORD - Ultimate darkness
        function drawShadowOverlordSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const shadowPulse = Math.sin(idleFrame * 0.08) * 20;
            
            // Darkness expanding
            for(let i = 0; i < 6; i++) {
                const darkRadius = bodySize + 20 + i * 15 + shadowPulse;
                const darkAlpha = 0.4 - i * 0.06;
                
                ctx.fillStyle = `rgba(0, 0, 0, ${darkAlpha})`;
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 40;
                ctx.beginPath();
                ctx.arc(px, py, darkRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // Shadow tendrils
            for(let i = 0; i < 12; i++) {
                const tendrilAngle = (i / 12) * Math.PI * 2 + idleFrame * 0.02;
                const tendrilLength = 60 + Math.sin(idleFrame * 0.1 + i) * 20;
                
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(tendrilAngle);
                
                const tendrilGrad = ctx.createLinearGradient(0, 0, tendrilLength, 0);
                tendrilGrad.addColorStop(0, 'rgba(60, 0, 60, 0.9)');
                tendrilGrad.addColorStop(0.5, 'rgba(30, 0, 30, 0.6)');
                tendrilGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.strokeStyle = tendrilGrad;
                ctx.lineWidth = 5;
                ctx.shadowColor = '#3c003c';
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.moveTo(bodySize, 0);
                ctx.quadraticCurveTo(bodySize + tendrilLength / 2, Math.sin(idleFrame * 0.15 + i) * 20, bodySize + tendrilLength, 0);
                ctx.stroke();
                ctx.restore();
            }
            ctx.shadowBlur = 0;
            
            // Dark matter body
            const shadowGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            shadowGrad.addColorStop(0, '#3c003c');
            shadowGrad.addColorStop(0.3, '#1a001a');
            shadowGrad.addColorStop(0.6, '#0d000d');
            shadowGrad.addColorStop(0.9, '#000000');
            shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
            ctx.fillStyle = shadowGrad;
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 50 + shadowPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Purple void cracks
            for(let i = 0; i < 8; i++) {
                const crackAngle = (i / 8) * Math.PI * 2 + idleFrame * 0.05;
                
                ctx.strokeStyle = '#9900ff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#9900ff';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + Math.cos(crackAngle) * bodySize * 0.7, py + Math.sin(crackAngle) * bodySize * 0.7);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Skull crown horns
            ctx.save();
            ctx.translate(px, py - 30 + headBob);
            
            for(let horn = 0; horn < 2; horn++) {
                const hornX = horn === 0 ? -15 : 15;
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 6;
                ctx.shadowColor = '#9900ff';
                ctx.shadowBlur = 15;
                
                ctx.beginPath();
                ctx.moveTo(hornX, 0);
                ctx.quadraticCurveTo(hornX * 1.5, -15, hornX * 1.3, -25);
                ctx.stroke();
            }
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Purple void eyes
            ctx.fillStyle = '#9900ff';
            ctx.shadowColor = '#9900ff';
            ctx.shadowBlur = 35;
            ctx.beginPath();
            ctx.arc(px - 8, py - 5 + headBob, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 8, py - 5 + headBob, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(px - 8, py - 5 + headBob, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 8, py - 5 + headBob, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // üíéüåà PRISMATIC GOD - Living rainbow
        function drawPrismaticGodSkin(ctx, px, py, bodySize, idleFrame, breathe) {
            const headBob = Math.sin(idleFrame * 0.06) * 1;
            const prismPulse = Math.sin(idleFrame * 0.12) * 18;
            
            const colors = [
                { color: '#ff0000', offset: 0 },
                { color: '#ff7700', offset: 1 },
                { color: '#ffff00', offset: 2 },
                { color: '#00ff00', offset: 3 },
                { color: '#0088ff', offset: 4 },
                { color: '#4400ff', offset: 5 },
                { color: '#ff00ff', offset: 6 }
            ];
            
            // Rainbow rings
            for(let ring = 0; ring < colors.length; ring++) {
                const color = colors[ring];
                const ringSize = bodySize + 25 + ring * 8 + prismPulse;
                const rotation = idleFrame * 0.02 + color.offset * 0.3;
                
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(rotation);
                
                ctx.strokeStyle = color.color;
                ctx.lineWidth = 4;
                ctx.shadowColor = color.color;
                ctx.shadowBlur = 25;
                
                for(let i = 0; i < 6; i++) {
                    const segmentAngle = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringSize, segmentAngle, segmentAngle + 0.4);
                    ctx.stroke();
                }
                ctx.restore();
            }
            ctx.shadowBlur = 0;
            
            // Rainbow sparkles
            for(let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2 + idleFrame * 0.05;
                const orbit = bodySize + 40 + Math.sin(idleFrame * 0.08 + i) * 25;
                const particleSize = 2 + Math.sin(idleFrame * 0.1 + i) * 2;
                const colorIndex = i % colors.length;
                
                ctx.fillStyle = colors[colorIndex].color;
                ctx.shadowColor = colors[colorIndex].color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(px + Math.cos(angle) * orbit, py + Math.sin(angle) * orbit, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // White light core
            const prismGrad = ctx.createRadialGradient(px, py, 0, px, py, bodySize);
            prismGrad.addColorStop(0, '#ffffff');
            prismGrad.addColorStop(0.2, '#ffeeee');
            prismGrad.addColorStop(0.4, '#eeffee');
            prismGrad.addColorStop(0.6, '#eeeeff');
            prismGrad.addColorStop(0.8, '#ffccff');
            prismGrad.addColorStop(1, '#ccffcc');
            ctx.fillStyle = prismGrad;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 60 + prismPulse;
            ctx.beginPath();
            ctx.arc(px, py, bodySize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Rainbow beams
            for(let i = 0; i < 7; i++) {
                const beamAngle = (i / 7) * Math.PI * 2 + idleFrame * 0.03;
                const beamLength = 50 + Math.sin(idleFrame * 0.15 + i) * 15;
                const color = colors[i];
                
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(beamAngle);
                
                const beamGrad = ctx.createLinearGradient(bodySize, 0, bodySize + beamLength, 0);
                beamGrad.addColorStop(0, color.color);
                beamGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = beamGrad;
                ctx.shadowColor = color.color;
                ctx.shadowBlur = 25;
                
                ctx.beginPath();
                ctx.moveTo(bodySize, -5);
                ctx.lineTo(bodySize + beamLength, -2);
                ctx.lineTo(bodySize + beamLength, 2);
                ctx.lineTo(bodySize, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            ctx.shadowBlur = 0;
            
            // Crystal crown
            ctx.save();
            ctx.translate(px, py - 35 + headBob);
            
            const crownGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            crownGrad.addColorStop(0, '#ffffff');
            crownGrad.addColorStop(0.5, '#88ffff');
            crownGrad.addColorStop(1, '#ff88ff');
            
            ctx.fillStyle = crownGrad;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 30;
            
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, -5);
            ctx.lineTo(0, 10);
            ctx.lineTo(15, -5);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(0, 10);
            ctx.moveTo(-15, -5);
            ctx.lineTo(15, -5);
            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Rainbow cycling eyes
            const eyeColorIndex = Math.floor(idleFrame * 0.1) % colors.length;
            const eyeColor = colors[eyeColorIndex].color;
            
            ctx.fillStyle = eyeColor;
            ctx.shadowColor = eyeColor;
            ctx.shadowBlur = 35;
            ctx.beginPath();
            ctx.arc(px - 8, py - 5 + headBob, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 8, py - 5 + headBob, 7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(px - 8, py - 5 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 8, py - 5 + headBob, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function selectBiome(biome) {
            console.log('selectBiome called:', biome);
            currentBiome = biome;
            document.getElementById('biomeSelection').classList.add('hidden');
            console.log('biomeSelection hidden');
            
            // Platform se√ßime ge√ß
            setTimeout(() => {
                console.log('showing platformSelection');
                document.getElementById('platformSelection').classList.remove('hidden');
            }, 300);
        }
        
        function getBiomeEnemySpeed(baseSpeed) {
            const biome = BIOMES[currentBiome] || BIOMES['proxima'];
            return baseSpeed * biome.enemySpeedMult;
        }
        
        // Leaderboard sistemi - BIOME-SPECIFIC
        let biomeBests = {
            proxima: [],
            kepler: [],
            titan: []
        };
        const MAX_PERSONAL_RECORDS = 10;
        
        // Biome-specific leaderboard y√ºkle
        function loadLeaderboard() {
            const saved = localStorage.getItem('plasmaGameBiomeBests');
            if (saved) {
                try {
                    biomeBests = JSON.parse(saved);
                    // Yeni biome'lar i√ßin bo≈ü array ekle
                    if (!biomeBests.proxima) biomeBests.proxima = [];
                    if (!biomeBests.kepler) biomeBests.kepler = [];
                    if (!biomeBests.titan) biomeBests.titan = [];
                } catch (e) {
                    biomeBests = { proxima: [], kepler: [], titan: [] };
                }
            }
        }
        
        // Biome-specific leaderboard kaydet
        function saveLeaderboard() {
            localStorage.setItem('plasmaGameBiomeBests', JSON.stringify(biomeBests));
        }
        
        // Skoru biome-specific leaderboard'a ekle
        function addToLeaderboard(playerName, score, wave, kills) {
            const entry = {
                score: score,
                wave: wave,
                kills: kills,
                date: new Date().toLocaleDateString(),
                timestamp: Date.now()
            };
            
            // Current biome'un array'ine ekle
            if (!biomeBests[currentBiome]) {
                biomeBests[currentBiome] = [];
            }
            biomeBests[currentBiome].push(entry);
            
            // Sƒ±ralama: Sadece score'a g√∂re (en y√ºksek en √ºstte)
            biomeBests[currentBiome].sort((a, b) => b.score - a.score);
            
            // En fazla 10 entry tut
            biomeBests[currentBiome] = biomeBests[currentBiome].slice(0, MAX_PERSONAL_RECORDS);
            
            saveLeaderboard();
            
            // Rank'i bul (1 = en iyi)
            const rank = biomeBests[currentBiome].findIndex(e => 
                e.score === score && 
                e.timestamp === entry.timestamp
            ) + 1;
            
            return rank;
        }
        
        // Leaderboard g√∂ster
        // Player profil sistemi
        let leaderboard = [];
        const MAX_LEADERBOARD_ENTRIES = 10;
        
        // Leaderboard y√ºkle
        function loadLeaderboard() {
            const saved = localStorage.getItem('arenaGameLeaderboard');
            if (saved) {
                try {
                    leaderboard = JSON.parse(saved);
                } catch (e) {
                    leaderboard = [];
                }
            }
        }
        
        // Leaderboard kaydet
        function saveLeaderboard() {
            localStorage.setItem('arenaGameLeaderboard', JSON.stringify(leaderboard));
        }
        
        // Skoru leaderboard'a ekle
        function addToLeaderboard(playerName, score, wave, kills) {
            const entry = {
                name: playerName,
                score: score,
                wave: wave,
                kills: kills,
                date: new Date().toLocaleDateString(),
                timestamp: Date.now()
            };
            
            leaderboard.push(entry);
            
            // Sƒ±ralama: √ñnce score, sonra wave, sonra kills
            leaderboard.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.wave !== a.wave) return b.wave - a.wave;
                return b.kills - a.kills;
            });
            
            // En fazla 10 entry tut
            leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            
            saveLeaderboard();
            
            // Rank'i bul
            const rank = leaderboard.findIndex(e => 
                e.name === playerName && 
                e.score === score && 
                e.timestamp === entry.timestamp
            ) + 1;
            
            // GLOBAL LEADERBOARD'A DA G√ñNDER
            submitToGlobalLeaderboard(playerName, score, wave, kills);
            
            return rank;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GLOBAL LEADERBOARD SYSTEM (Firebase + CrazyGames)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let globalLeaderboard = [];
        let globalLeaderboardLoaded = false;
        let currentUserGlobalRank = null;
        
        // Submit score to global leaderboard
        async function submitToGlobalLeaderboard(playerName, score, wave, kills) {
            console.log('üéØ submitToGlobalLeaderboard called:', { playerName, score, wave, kills });
            
            try {
                // Get CrazyGames user
                let userId = 'guest_' + Date.now();
                let username = playerName;
                
                console.log('üë§ Getting CrazyGames user...');
                if (typeof crazySDK !== 'undefined' && crazySDK && crazySDK.user) {
                    try {
                        const user = await crazySDK.user.getUser();
                        if (user && user.userId) {
                            userId = user.userId;
                            username = user.username || playerName;
                            console.log('‚úÖ CrazyGames user found:', userId, username);
                        } else {
                            console.log('‚ö†Ô∏è CrazyGames user object empty, using guest ID');
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è CrazyGames user error:', e.message);
                        console.log('   Using guest ID instead');
                    }
                } else {
                    console.log('‚ö†Ô∏è CrazyGames SDK not fully available');
                    console.log('   SDK exists:', typeof crazySDK !== 'undefined');
                    console.log('   SDK.user exists:', crazySDK && crazySDK.user ? 'yes' : 'no');
                    console.log('   Using guest ID');
                }
                
                console.log('üìù Using userId:', userId, 'username:', username);
                
                console.log('üî• Checking Firebase availability...');
                // Check Firebase availability
                if (!window.firebaseDB || typeof window.firebaseDB === 'undefined' || window.firebaseDB === null) {
                    console.error('‚ùå Firebase not initialized, skipping global leaderboard');
                    console.log('   Firebase DB:', window.firebaseDB);
                    console.log('   Firebase available:', typeof firebase !== 'undefined' ? 'Yes' : 'No');
                    return;
                }
                console.log('‚úÖ Firebase available');
                
                console.log('üìä Checking existing score for user:', userId);
                // Get current user's best score (compat API)
                const userRef = window.firebaseDB.ref('leaderboard/' + userId);
                const snapshot = await userRef.once('value');
                
                let shouldUpdate = true;
                if (snapshot.exists()) {
                    const currentBest = snapshot.val();
                    console.log('üìà Current best score:', currentBest.score, 'New score:', score);
                    // Only update if new score is better
                    if (currentBest.score > score) {
                        shouldUpdate = false;
                        console.log('Current score not better than existing, skipping update');
                    }
                }
                
                if (shouldUpdate) {
                    console.log('üíæ Submitting to Firebase...', { userId, username, score, wave, kills });
                    // Submit to Firebase (compat API)
                    await userRef.set({
                        username: username,
                        score: score,
                        wave: wave,
                        kills: kills,
                        timestamp: Date.now(),
                        date: new Date().toISOString()
                    });
                    
                    console.log('‚úÖ Score submitted to global leaderboard successfully!', score);
                    showNotification('üåç Score submitted to Global Leaderboard!', 2000);
                    
                    // Reload global leaderboard
                    console.log('üîÑ Reloading global leaderboard...');
                    await loadGlobalLeaderboard();
                } else {
                    console.log('‚è≠Ô∏è Score not better than existing, skipping update');
                }
                
            } catch (error) {
                console.error('‚ùå Error submitting to global leaderboard:', error);
            }
        }
        
        // Load global leaderboard (top 100)
        async function loadGlobalLeaderboard() {
            try {
                if (!window.firebaseDB || typeof window.firebaseDB === 'undefined' || window.firebaseDB === null) {
                    console.log('Firebase not initialized - skipping load');
                    globalLeaderboardLoaded = true;
                    updateGlobalLeaderboardPreview();
                    return;
                }
                
                // Query with compat API
                const leaderboardRef = window.firebaseDB.ref('leaderboard');
                const topQuery = leaderboardRef.orderByChild('score').limitToLast(100);
                
                const snapshot = await topQuery.once('value');
                
                if (snapshot.exists()) {
                    const data = [];
                    snapshot.forEach((child) => {
                        data.push({
                            userId: child.key,
                            ...child.val()
                        });
                    });
                    
                    // Sort descending by score
                    data.sort((a, b) => {
                        if (b.score !== a.score) return b.score - a.score;
                        if (b.wave !== a.wave) return b.wave - a.wave;
                        return b.kills - a.kills;
                    });
                    
                    globalLeaderboard = data;
                    globalLeaderboardLoaded = true;
                    
                    console.log(`üåç Global leaderboard loaded: ${data.length} players`);
                    
                    // Update main menu preview
                    updateGlobalLeaderboardPreview();
                } else {
                    globalLeaderboard = [];
                    globalLeaderboardLoaded = true;
                    console.log('üåç Global leaderboard is empty');
                    
                    // Update main menu preview even when empty
                    updateGlobalLeaderboardPreview();
                }
                
                // Update display if modal is open
                const leaderboardModal = document.getElementById('leaderboardModal');
                if (leaderboardModal && leaderboardModal.classList.contains('active')) {
                    updateLeaderboardDisplay();
                }
                
            } catch (error) {
                console.error('‚ùå Error loading global leaderboard:', error);
            }
        }
        
        // Get current user's global rank
        async function getCurrentUserGlobalRank() {
            try {
                if (typeof crazySDK === 'undefined' || !crazySDK.user) {
                    return null;
                }
                
                const user = await crazySDK.user.getUser();
                if (!user || !user.userId) {
                    return null;
                }
                
                const rank = globalLeaderboard.findIndex(entry => entry.userId === user.userId);
                return rank >= 0 ? rank + 1 : null;
                
            } catch (error) {
                console.error('Error getting user rank:', error);
                return null;
            }
        }
        
        // Setup real-time leaderboard updates
        function setupRealtimeLeaderboard() {
            try {
                if (!window.firebaseDB || typeof window.firebaseDB === 'undefined' || window.firebaseDB === null) {
                    console.log('Firebase not available - skipping real-time setup');
                    return;
                }
                
                // Setup real-time listener with compat API
                const leaderboardRef = window.firebaseDB.ref('leaderboard');
                const topQuery = leaderboardRef.orderByChild('score').limitToLast(100);
                
                // Listen for changes
                topQuery.on('value', (snapshot) => {
                    if (snapshot.exists()) {
                        const data = [];
                        snapshot.forEach((child) => {
                            data.push({
                                userId: child.key,
                                ...child.val()
                            });
                        });
                        
                        // Sort descending
                        data.sort((a, b) => {
                            if (b.score !== a.score) return b.score - a.score;
                            if (b.wave !== a.wave) return b.wave - a.wave;
                            return b.kills - a.kills;
                        });
                        
                        globalLeaderboard = data;
                        globalLeaderboardLoaded = true;
                        
                        // Update display if modal is open
                        const leaderboardModal = document.getElementById('leaderboardModal');
                        if (leaderboardModal && leaderboardModal.classList.contains('active')) {
                            updateLeaderboardDisplay();
                        }
                        
                        // Update main menu preview
                        updateGlobalLeaderboardPreview();
                    }
                });
                
                console.log('üîÑ Real-time leaderboard updates enabled');
                
            } catch (error) {
                console.error('Error setting up real-time updates:', error);
            }
        }
        
        // Update global leaderboard preview in main menu
        function updateGlobalLeaderboardPreview() {
            const previewDiv = document.getElementById('globalLeaderboardPreview');
            if (!previewDiv) return;
            
            if (!globalLeaderboardLoaded) {
                previewDiv.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px; font-size: 14px;">Loading...</div>';
                return;
            }
            
            if (globalLeaderboard.length === 0) {
                previewDiv.innerHTML = '<div style="text-align: center; color: #666; padding: 20px; font-size: 14px;">No scores yet.<br>Be the first!</div>';
                return;
            }
            
            // Show top 10
            const top10 = globalLeaderboard.slice(0, 10);
            let html = '';
            
            top10.forEach((entry, index) => {
                const rank = index + 1;
                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                const rankColor = rank === 1 ? '#ffd700' : rank === 2 ? '#c0c0c0' : rank === 3 ? '#cd7f32' : '#fff';
                
                html += `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; margin-bottom: 6px; border-left: 3px solid ${rankColor};">
                        <div style="font-size: 16px; min-width: 30px; text-align: center;">${rankEmoji}</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 13px; font-weight: bold; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${entry.username || 'Anonymous'}</div>
                            <div style="font-size: 11px; color: #aaa;">üí∞ ${entry.score} | üåä ${entry.wave}</div>
                        </div>
                    </div>
                `;
            });
            
            previewDiv.innerHTML = html;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let currentLeaderboardTab = 'personal'; // 'personal' or 'global'
        
        // Switch leaderboard tab
        function switchLeaderboardTab(tab) {
            currentLeaderboardTab = tab;
            
            // Update tab buttons
            document.getElementById('personalLeaderboardTab').classList.toggle('active', tab === 'personal');
            document.getElementById('globalLeaderboardTab').classList.toggle('active', tab === 'global');
            
            // Update tab button styles
            const personalTab = document.getElementById('personalLeaderboardTab');
            const globalTab = document.getElementById('globalLeaderboardTab');
            
            if (tab === 'personal') {
                personalTab.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                personalTab.style.border = 'none';
                globalTab.style.background = 'rgba(255, 255, 255, 0.1)';
                globalTab.style.border = '2px solid #667eea';
            } else {
                globalTab.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                globalTab.style.border = 'none';
                personalTab.style.background = 'rgba(255, 255, 255, 0.1)';
                personalTab.style.border = '2px solid #667eea';
            }
            
            // Show/hide clear button (only for personal)
            const clearBtn = document.getElementById('clearLeaderboardBtn');
            if (clearBtn) {
                clearBtn.style.display = tab === 'personal' ? 'block' : 'none';
            }
            
            // Update display
            updateLeaderboardDisplay();
        }
        
        // Leaderboard g√∂ster
        // Leaderboard g√∂ster
        function showLeaderboard() {
            // Sadece main menu'de veya game over'da a√ßƒ±labilir
            if (gameState === 'playing') {
                console.log('‚ö†Ô∏è Cannot open leaderboard during gameplay');
                return;
            }
            
            // Oyunu pause et (diƒüer durumlarda)
            if (gameState !== 'menu' && gameState !== 'gameover') {
                previousGameState = gameState;
                gameState = 'paused';
            }
            
            document.getElementById('leaderboardModal').classList.add('active');
            
            updateLeaderboardDisplay();
        }
        
        // Leaderboard kapat
        function closeLeaderboard() {
            document.getElementById('leaderboardModal').classList.remove('active');
            
            // Oyunu resume et
            if (previousGameState === 'playing') {
                gameState = 'playing';
            }
        }
        
        // Leaderboard display g√ºncelle - BIOME-SPECIFIC
        function updateLeaderboardDisplay() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            
            if (currentLeaderboardTab === 'global') {
                // GLOBAL LEADERBOARD DISPLAY
                if (!globalLeaderboardLoaded) {
                    const loading = document.createElement('div');
                    loading.style.cssText = 'text-align: center; color: #fff; padding: 40px; font-size: 18px;';
                    loading.innerHTML = 'üåç Loading global leaderboard...<br><span style="font-size: 14px; color: #aaa;">Please wait</span>';
                    list.appendChild(loading);
                    
                    // Load global leaderboard
                    loadGlobalLeaderboard();
                    return;
                }
                
                if (globalLeaderboard.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.cssText = 'text-align: center; color: #666; padding: 40px; font-size: 16px;';
                    empty.textContent = 'No scores yet. Be the first!';
                    list.appendChild(empty);
                    return;
                }
                
                // Display global top 100
                globalLeaderboard.forEach((entry, index) => {
                    const rank = index + 1;
                    const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                    
                    const item = document.createElement('div');
                    item.className = 'leaderboard-item';
                    if (rank <= 3) item.classList.add('top-three');
                    
                    // Highlight current user
                    let isCurrentUser = false;
                    if (typeof crazySDK !== 'undefined' && crazySDK.user) {
                        try {
                            crazySDK.user.getUser().then(user => {
                                if (user && user.userId === entry.userId) {
                                    item.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2))';
                                    item.style.border = '2px solid #ffd700';
                                }
                            });
                        } catch (e) {}
                    }
                    
                    const dateStr = entry.date ? new Date(entry.date).toLocaleDateString() : 'Unknown';
                    
                    item.innerHTML = `
                        <div class="leaderboard-rank">${rankEmoji}</div>
                        <div class="leaderboard-info">
                            <div class="leaderboard-name">${entry.username || 'Anonymous'}</div>
                            <div class="leaderboard-stats">
                                üí∞ ${entry.score} | üåä Wave ${entry.wave} | üíÄ ${entry.kills} kills
                            </div>
                            <div class="leaderboard-date">${dateStr}</div>
                        </div>
                    `;
                    
                    list.appendChild(item);
                });
                
            } else {
                // PERSONAL LEADERBOARD DISPLAY (original code)
                // Her biome i√ßin section olu≈ütur
                ['proxima', 'kepler', 'titan'].forEach(biome => {
                    const biomeData = BIOMES[biome];
                    const biomeName = currentLanguage === 'en' ? biomeData.name : biomeData.nameTr;
                    const records = biomeBests[biome] || [];
                    
                    // Biome ba≈ülƒ±ƒüƒ±
                    const biomeSection = document.createElement('div');
                    biomeSection.className = 'biome-leaderboard-section';
                    biomeSection.style.marginBottom = '30px';
                    
                    const biomeTitle = document.createElement('div');
                    biomeTitle.style.cssText = `
                        font-size: 22px;
                        font-weight: bold;
                        color: ${biomeData.accentColor};
                        text-shadow: 0 0 10px ${biomeData.accentColor};
                        margin-bottom: 15px;
                        padding: 10px;
                        background: rgba(0, 0, 0, 0.3);
                        border-left: 4px solid ${biomeData.accentColor};
                    `;
                    biomeTitle.textContent = biomeName;
                    biomeSection.appendChild(biomeTitle);
                    
                    if (records.length === 0) {
                        const emptyMsg = document.createElement('div');
                        emptyMsg.style.cssText = 'text-align: center; color: #666; padding: 20px; font-size: 14px;';
                        emptyMsg.textContent = 'No records yet in this biome';
                        biomeSection.appendChild(emptyMsg);
                    } else {
                        records.forEach((entry, index) => {
                            const rank = index + 1;
                            const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                            
                            const item = document.createElement('div');
                            item.className = 'leaderboard-item';
                            if (rank <= 3) item.classList.add('top-three');
                            
                            const label = rank === 1 ? '#1 PERSONAL BEST' : `Attempt #${rank}`;
                            
                            item.innerHTML = `
                                <div class="leaderboard-rank">${rankEmoji}</div>
                                <div class="leaderboard-info">
                                    <div class="leaderboard-name">${label}</div>
                                    <div class="leaderboard-stats">
                                        üí∞ ${entry.score} | üåä Wave ${entry.wave} | üíÄ ${entry.kills} kills
                                    </div>
                                    <div class="leaderboard-date">${entry.date}</div>
                                </div>
                            `;
                            
                            biomeSection.appendChild(item);
                        });
                    }
                    
                    list.appendChild(biomeSection);
                });
            }
        }
        
        // Leaderboard temizle (admin)
        function clearLeaderboard() {
            if (confirm('Are you sure you want to clear all leaderboard data?')) {
                leaderboard = [];
                saveLeaderboard();
                updateLeaderboardDisplay();
                showNotification('üóëÔ∏è Leaderboard cleared!', 2000);
            }
        }
        
        // Platform ve kontrol sistemi
        let platform = null; // 'desktop' veya 'mobile'
        let joystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0
        };
        let aimJoystick = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            deltaX: 0,
            deltaY: 0,
            angle: 0 // Karakter bu a√ßƒ±ya bakacak
        };
        let mobileAttacking = false;
        let mobileDashing = false;
        
        // Platform se√ßimi
        function selectPlatform(selectedPlatform) {
            console.log('selectPlatform called:', selectedPlatform);
            platform = selectedPlatform;
            document.getElementById('platformSelection').classList.add('hidden');
            console.log('platformSelection hidden');
            
            // Weapon selection'ƒ± g√∂ster
            setTimeout(() => {
                console.log('showing weaponSelection');
                document.getElementById('weaponSelection').classList.remove('hidden');
            }, 300);
            
            if (platform === 'mobile') {
                // Mobile i√ßin ekran ayarlarƒ±
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.height = '100%';
                
                // Mobile kontrolleri g√∂ster
                document.getElementById('mobileControls').classList.add('active');
                
                // Canvas boyutunu mobil i√ßin ayarla
                resizeCanvas();
                
                // Joystick event listeners
                setupJoystick();
                setupAimJoystick();
                
                // Dash button
                const dashBtn = document.getElementById('dashButton');
                dashBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileDashing = true;
                });
                dashBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileDashing = false;
                });
            } else {
                // Desktop i√ßin normal ayarlar
                resizeCanvas();
            }
        }
        
        // Joystick kurulumu
        function setupJoystick() {
            const container = document.getElementById('joystickContainer');
            const stick = document.getElementById('joystickStick');
            
            container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = container.getBoundingClientRect();
                joystick.active = true;
                joystick.startX = rect.left + rect.width / 2;
                joystick.startY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystick.active) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });
            
            container.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystick.active = false;
                joystick.deltaX = 0;
                joystick.deltaY = 0;
                stick.style.transform = 'translate(-50%, -50%)';
            });
        }
        
        function updateJoystick(touchX, touchY) {
            const stick = document.getElementById('joystickStick');
            const container = document.getElementById('joystickContainer');
            const containerSize = container.offsetWidth;
            const maxDistance = containerSize * 0.27; // %27 of container size
            
            let deltaX = touchX - joystick.startX;
            let deltaY = touchY - joystick.startY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxDistance;
                deltaY = Math.sin(angle) * maxDistance;
            }
            
            joystick.currentX = joystick.startX + deltaX;
            joystick.currentY = joystick.startY + deltaY;
            joystick.deltaX = deltaX / maxDistance;
            joystick.deltaY = deltaY / maxDistance;
            
            stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        }
        
        // Hedefleme joystick kurulumu
        function setupAimJoystick() {
            const container = document.getElementById('aimJoystickContainer');
            const stick = document.getElementById('aimJoystickStick');
            
            container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = container.getBoundingClientRect();
                aimJoystick.active = true;
                aimJoystick.startX = rect.left + rect.width / 2;
                aimJoystick.startY = rect.top + rect.height / 2;
                mobileAttacking = true;
                updateAimJoystick(touch.clientX, touch.clientY);
            });
            
            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (aimJoystick.active) {
                    const touch = e.touches[0];
                    updateAimJoystick(touch.clientX, touch.clientY);
                }
            });
            
            container.addEventListener('touchend', (e) => {
                e.preventDefault();
                aimJoystick.active = false;
                aimJoystick.deltaX = 0;
                aimJoystick.deltaY = 0;
                mobileAttacking = false;
                stick.style.transform = 'translate(-50%, -50%)';
            });
        }
        
        function updateAimJoystick(touchX, touchY) {
            const stick = document.getElementById('aimJoystickStick');
            const container = document.getElementById('aimJoystickContainer');
            const containerSize = container.offsetWidth;
            const maxDistance = containerSize * 0.27; // %27 of container size
            
            let deltaX = touchX - aimJoystick.startX;
            let deltaY = touchY - aimJoystick.startY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxDistance;
                deltaY = Math.sin(angle) * maxDistance;
            }
            
            aimJoystick.currentX = aimJoystick.startX + deltaX;
            aimJoystick.currentY = aimJoystick.startY + deltaY;
            aimJoystick.deltaX = deltaX / maxDistance;
            aimJoystick.deltaY = deltaY / maxDistance;
            
            // Hedefleme a√ßƒ±sƒ±nƒ± hesapla
            if (distance > 5) {
                aimJoystick.angle = Math.atan2(deltaY, deltaX);
            }
            
            stick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        }
        
        // Canvas boyutlandƒ±rma
        function resizeCanvas() {
            if (platform === 'mobile') {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        
        // Dil sistemi
        let currentLanguage = 'en'; // Varsayƒ±lan dil: ƒ∞ngilizce
        let previousGameState = 'playing'; // Modal a√ßƒ±lmadan √∂nceki state
        const translations = {
            tr: {
                platformTitle: 'üéÆ PLATFORM SE√á üéÆ',
                platformSubtitle: 'Cihaz tipini se√ß',
                desktop: 'Masa√ºst√º',
                mobile: 'Mobil',
                weaponTreeButton: 'Silah Aƒüacƒ±',
                weaponTreeTitle: 'üå≥ Sƒ∞LAH GELƒ∞≈ûƒ∞M AƒûACIN',
                close: 'Kapat',
                unlocked: 'A√ßƒ±ldƒ±',
                locked: 'Kilitli',
                current: 'Mevcut',
                kills: '√ñld√ºrme',
                required: 'Gerekli',
                selectWeaponTree: '‚öîÔ∏è Sƒ∞LAH AƒûACINI SE√á ‚öîÔ∏è',
                selectSubtitle: 'Oyun tarzƒ±nƒ± belirle - Her aƒüa√ß farklƒ± yetenekler a√ßar',
                melee: 'YAKIN MESAFE',
                meleeDesc: 'G√º√ßl√º yakƒ±n d√∂v√º≈ü silahlarƒ±. Y√ºksek hasar, hƒ±zlƒ± saldƒ±rƒ±, √∂zel yetenekler.',
                ranged: 'UZAK MESAFE',
                rangedDesc: 'Menzilli saldƒ±rƒ±lar. Mesafeden g√ºvenli, delici oklar, patlayƒ±cƒ± mermiler.',
                hybrid: 'Hƒ∞BRƒ∞T',
                hybridDesc: 'Dengeli yakla≈üƒ±m. Orta menzil, dash, ate≈ü hasarƒ±, √ßok y√∂nl√º oyun.',
                placeBase: 'üè∞ √úSS√úN√ú KUR',
                placeBaseHint: 'Haritaya tƒ±kla ve √ºss√ºn√º yerle≈ütir!<br>D√º≈ümanlar √ºsse saldƒ±racak - Savun!',
                gameOver: 'OYUN Bƒ∞TTƒ∞',
                baseDestroyed: 'üè∞ BASE DESTROYED!',
                playerDied: 'üíÄ YOU DIED!',
                restart: 'üîÑ RESTART',
                score: 'SCORE',
                enemiesKilled: 'ENEMIES KILLED',
                waveReached: 'WAVE REACHED',
                playerLevel: 'CHARACTER LEVEL',
                buildingsBuilt: 'BUILDINGS BUILT',
                weapon: 'WEAPON',
                waveStart: '‚öîÔ∏è WAVE {0} STARTED! {1} Enemies',
                waveCleared: '‚úÖ WAVE {0} CLEARED! üí∞ Bonus XP: +{1}',
                weaponUnlocked: '{0} UNLOCKED!',
                treeSelected: '{0} TREE SELECTED!\nStarting with {1}',
                gold: 'Gold',
                shop: 'SHOP',
                shopSubtitle: 'Upgrades and Potions',
                buyHealth: 'Saƒülƒ±k ƒ∞ksiri (+100 HP)',
                buyDamage: 'Hasar Y√ºkseltme (+20%)',
                buySpeed: 'Hƒ±z Y√ºkseltme (+15%)',
                buyTower: 'Ek Kule ƒ∞n≈üaatƒ±',
                buyWall: 'Ek Duvar ƒ∞n≈üaatƒ±',
                closeShop: 'Kapat',
                notEnoughGold: 'üí∞ Yeterli altƒ±n yok!',
                purchased: '‚úÖ Satƒ±n alƒ±ndƒ±!',
                eventActive: 'üé™ {0} AKTƒ∞F!',
                powerUpCollected: '‚ö° {0} Toplandƒ±!',
                leaderboard: 'Lƒ∞DER TABLOSU',
                leaderboardTitle: 'üèÜ Lƒ∞DER TABLOSU üèÜ',
                rank: 'Sƒ±ralama',
                enterName: 'ƒ∞sminizi girin:',
                yourRank: 'Sƒ±ralamanƒ±z: #{0}',
                newRecord: 'üéâ YENƒ∞ REKOR! üéâ',
                clearLeaderboard: 'Tabloyu Temizle'
            },
            en: {
                platformTitle: 'üéÆ SELECT PLATFORM üéÆ',
                platformSubtitle: 'Choose your device type',
                desktop: 'Desktop',
                mobile: 'Mobile',
                weaponTreeButton: 'Weapon Tree',
                weaponTreeTitle: 'üå≥ YOUR WEAPON PROGRESSION',
                close: 'Close',
                unlocked: 'Unlocked',
                locked: 'Locked',
                current: 'Current',
                kills: 'Kills',
                required: 'Required',
                selectWeaponTree: '‚öîÔ∏è SELECT WEAPON TREE ‚öîÔ∏è',
                selectSubtitle: 'Choose your playstyle - Each tree unlocks different abilities',
                melee: 'MELEE',
                meleeDesc: 'Powerful close combat weapons. High damage, fast attacks, special abilities.',
                ranged: 'RANGED',
                rangedDesc: 'Long-range attacks. Safe distance, piercing arrows, explosive rounds.',
                hybrid: 'HYBRID',
                hybridDesc: 'Balanced approach. Medium range, dash ability, fire damage, versatile play.',
                placeBase: 'üè∞ PLACE YOUR BASE',
                placeBaseHint: 'Click on the map to place your base!<br>Enemies will attack it - Defend!',
                gameOver: 'GAME OVER',
                baseDestroyed: 'üè∞ BASE DESTROYED!',
                playerDied: 'üíÄ YOU DIED!',
                restart: 'üîÑ RESTART',
                score: 'SCORE',
                enemiesKilled: 'ENEMIES KILLED',
                waveReached: 'WAVE REACHED',
                playerLevel: 'PLAYER LEVEL',
                buildingsBuilt: 'BUILDINGS BUILT',
                weapon: 'WEAPON',
                waveStart: '‚öîÔ∏è WAVE {0} STARTED! {1} Enemies',
                waveCleared: '‚úÖ WAVE {0} CLEARED! üí∞ Bonus XP: +{1}',
                weaponUnlocked: '{0} UNLOCKED!',
                treeSelected: '{0} TREE SELECTED!\nStarting with {1}',
                gold: 'Gold',
                shop: 'SHOP',
                shopSubtitle: 'Upgrades and Potions',
                buyHealth: 'Health Potion (+100 HP)',
                buyDamage: 'Damage Upgrade (+20%)',
                buySpeed: 'Speed Upgrade (+15%)',
                buyTower: 'Extra Tower Build',
                buyWall: 'Extra Wall Build',
                closeShop: 'Close',
                notEnoughGold: 'üí∞ Not enough gold!',
                purchased: '‚úÖ Purchased!',
                eventActive: 'üé™ {0} ACTIVE!',
                powerUpCollected: '‚ö° {0} Collected!',
                leaderboard: 'LEADERBOARD',
                leaderboardTitle: 'üèÜ LEADERBOARD üèÜ',
                rank: 'Rank',
                enterName: 'Enter your name:',
                yourRank: 'Your Rank: #{0}',
                newRecord: 'üéâ NEW RECORD! üéâ',
                clearLeaderboard: 'Clear Leaderboard'
            }
        };
        
        function t(key, ...args) {
            let text = translations[currentLanguage][key] || key;
            args.forEach((arg, index) => {
                text = text.replace(`{${index}}`, arg);
            });
            return text;
        }
        
        function toggleLanguage() {
            currentLanguage = currentLanguage === 'tr' ? 'en' : 'tr';
            document.getElementById('languageToggle').textContent = 'üåê ' + (currentLanguage === 'tr' ? 'EN' : 'TR');
            updateLanguage();
        }
        
        function updateLanguage() {
            // Platform se√ßimi
            const platformTitle = document.getElementById('platformTitle');
            if (platformTitle) platformTitle.textContent = t('platformTitle');
            
            const platformSubtitle = document.getElementById('platformSubtitle');
            if (platformSubtitle) platformSubtitle.textContent = t('platformSubtitle');
            
            const desktopText = document.getElementById('desktopText');
            if (desktopText) desktopText.textContent = t('desktop');
            
            const mobileText = document.getElementById('mobileText');
            if (mobileText) mobileText.textContent = t('mobile');
            
            // Silah se√ßim ekranƒ±
            const selectionTitle = document.getElementById('weaponSelectionTitle');
            if (selectionTitle) selectionTitle.textContent = t('selectWeaponTree');
            
            const selectionSubtitle = document.getElementById('weaponSelectionSubtitle');
            if (selectionSubtitle) selectionSubtitle.textContent = t('selectSubtitle');
            
            const treeNames = document.querySelectorAll('.weapon-tree-name');
            if (treeNames[0]) treeNames[0].textContent = t('melee');
            if (treeNames[1]) treeNames[1].textContent = t('ranged');
            if (treeNames[2]) treeNames[2].textContent = t('hybrid');
            
            // Yeni ID'li tree name/desc'ler
            const meleeTreeName = document.getElementById('meleeTreeName');
            if (meleeTreeName) meleeTreeName.textContent = t('melee');
            
            const rangedTreeName = document.getElementById('rangedTreeName');
            if (rangedTreeName) rangedTreeName.textContent = t('ranged');
            
            const hybridTreeName = document.getElementById('hybridTreeName');
            if (hybridTreeName) hybridTreeName.textContent = t('hybrid');
            
            const meleeTreeDesc = document.getElementById('meleeTreeDesc');
            if (meleeTreeDesc) meleeTreeDesc.textContent = t('meleeDesc');
            
            const rangedTreeDesc = document.getElementById('rangedTreeDesc');
            if (rangedTreeDesc) rangedTreeDesc.textContent = t('rangedDesc');
            
            const hybridTreeDesc = document.getElementById('hybridTreeDesc');
            if (hybridTreeDesc) hybridTreeDesc.textContent = t('hybridDesc');
            
            const treeDescs = document.querySelectorAll('.weapon-tree-description');
            if (treeDescs[0]) treeDescs[0].textContent = t('meleeDesc');
            if (treeDescs[1]) treeDescs[1].textContent = t('rangedDesc');
            if (treeDescs[2]) treeDescs[2].textContent = t('hybridDesc');
            
            // √ús yerle≈ütirme
            const placeText = document.getElementById('basePlacementText');
            if (placeText) placeText.textContent = t('placeBase');
            
            // Butonlar
            document.getElementById('weaponTreeButtonText').textContent = t('weaponTreeButton');
            document.getElementById('closeModalText').textContent = t('close');
            document.getElementById('weaponTreeModalTitle').textContent = t('weaponTreeTitle');
            
            // Oyun sonu
            const restartBtn = document.querySelector('.restart-button');
            if (restartBtn) restartBtn.innerHTML = t('restart');
            
            // Shop - Dynamic, no translations needed
            
            // Leaderboard
            document.getElementById('leaderboardTitleText').textContent = t('leaderboardTitle');
            document.getElementById('closeLeaderboardText').textContent = t('close');
            document.getElementById('clearLeaderboardText').textContent = t('clearLeaderboard');
        }
        
        function showWeaponTreeModal() {
            if (!selectedWeaponTree || !WEAPONS) return;
            
            // Oyunu pause et
            if (gameState === 'playing') {
                previousGameState = 'playing';
                gameState = 'paused';
            }
            
            const modal = document.getElementById('weaponTreeModal');
            const list = document.getElementById('weaponProgressionList');
            list.innerHTML = '';
            
            // Silahlarƒ± sƒ±ralƒ± listele
            const weaponArray = Object.entries(WEAPONS).map(([key, weapon]) => ({
                key, ...weapon
            })).sort((a, b) => a.unlockKills - b.unlockKills);
            
            weaponArray.forEach(weapon => {
                const item = document.createElement('div');
                item.className = 'weapon-item';
                
                if (kills >= weapon.unlockKills) {
                    item.classList.add('unlocked');
                }
                if (player.weapon && weapon.name === player.weapon.name) {
                    item.classList.add('current');
                }
                
                const icon = WEAPON_TREES[selectedWeaponTree].icon;
                const reqText = kills >= weapon.unlockKills ? 
                    `‚úì ${t('unlocked')}` : 
                    `${weapon.unlockKills} ${t('kills')} ${t('required')}`;
                const reqClass = kills >= weapon.unlockKills ? '' : ' locked';
                
                item.innerHTML = `
                    <div class="weapon-item-icon">${icon}</div>
                    <div class="weapon-item-info">
                        <div class="weapon-item-name">${getWeaponName(weapon)}</div>
                        <div class="weapon-item-stats">
                            Damage: ${weapon.damage} | Range: ${weapon.range} | Speed: ${weapon.speed.toFixed(1)}x
                        </div>
                    </div>
                    <div class="weapon-item-requirement${reqClass}">${reqText}</div>
                `;
                
                list.appendChild(item);
            });
            
            modal.classList.add('active');
        }
        
        function closeWeaponTreeModal() {
            document.getElementById('weaponTreeModal').classList.remove('active');
            
            // Oyunu resume et
            if (previousGameState === 'playing') {
                gameState = 'playing';
            }
        }
        
        // Shop sistemi
        function openShop() {
            // Oyunu pause et
            if (gameState === 'playing') {
                previousGameState = 'playing';
                gameState = 'paused';
            }
            
            // Generate new shop items
            generateShopItems();
            updateShopUI();
            
            document.getElementById('shopModal').classList.add('active');
            const shopGoldEl = document.getElementById('shopGoldAmount');
            if (shopGoldEl) shopGoldEl.textContent = gold;
        }
        
        function closeShop() {
            document.getElementById('shopModal').classList.remove('active');
            
            // Oyunu resume et
            if (previousGameState === 'playing') {
                gameState = 'playing';
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DYNAMIC SHOP SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let currentShopItems = [];
        
        const SHOP_ITEM_POOL = {
            common: [
                { id: 'health', name: 'Health Pack', icon: '‚ù§Ô∏è', desc: '+100 HP', cost: 50, 
                  effect: () => { player.health = Math.min(player.maxHealth, player.health + 100); } },
                { id: 'smallDamage', name: 'Minor Damage', icon: 'üí•', desc: '+10% Damage', cost: 80, 
                  effect: () => { Object.keys(WEAPONS).forEach(k => { WEAPONS[k].damage = Math.floor(WEAPONS[k].damage * 1.1); }); 
                                  if (player.weapon) player.weapon.damage = Math.floor(player.weapon.damage * 1.1); } },
                { id: 'speed', name: 'Speed Boost', icon: '‚ö°', desc: '+15% Speed', cost: 80, 
                  effect: () => { player.baseSpeed *= 1.15; player.speed = player.baseSpeed; } },
                { id: 'building', name: 'Building Point', icon: 'üèóÔ∏è', desc: '+1 Building', cost: 120, 
                  effect: () => { buildingPoints++; } }
            ],
            rare: [
                { id: 'bigHealth', name: 'Major Health', icon: 'üíö', desc: '+200 HP', cost: 120, 
                  effect: () => { player.health = Math.min(player.maxHealth, player.health + 200); } },
                { id: 'damage', name: 'Damage Upgrade', icon: 'üî•', desc: '+25% Damage', cost: 150, 
                  effect: () => { Object.keys(WEAPONS).forEach(k => { WEAPONS[k].damage = Math.floor(WEAPONS[k].damage * 1.25); }); 
                                  if (player.weapon) player.weapon.damage = Math.floor(player.weapon.damage * 1.25); } },
                { id: 'maxHealth', name: 'Max HP Up', icon: 'üí™', desc: '+50 Max HP', cost: 200, 
                  effect: () => { player.maxHealth += 50; player.health += 50; } },
                { id: 'attackSpeed', name: 'Attack Speed', icon: '‚öîÔ∏è', desc: '+20% Fire Rate', cost: 180, 
                  effect: () => { if (player.weapon) player.weapon.cooldown = Math.floor(player.weapon.cooldown * 0.8); } }
            ],
            epic: [
                { id: 'megaDamage', name: 'Mega Damage', icon: 'üí£', desc: '+50% Damage', cost: 300, 
                  effect: () => { Object.keys(WEAPONS).forEach(k => { WEAPONS[k].damage = Math.floor(WEAPONS[k].damage * 1.5); }); 
                                  if (player.weapon) player.weapon.damage = Math.floor(player.weapon.damage * 1.5); } },
                { id: 'multiShot', name: 'Multi-Shot', icon: 'üéØ', desc: '+2 Projectiles', cost: 400, 
                  effect: () => { player.multiShot = (player.multiShot || 1) + 2; } },
                { id: 'fullHeal', name: 'Full Restore', icon: '‚ú®', desc: 'Full HP', cost: 250, 
                  effect: () => { player.health = player.maxHealth; } }
            ],
            legendary: [
                { id: 'timeFreeze', name: 'Time Freeze', icon: '‚è∞', desc: 'Freeze enemies 10s', cost: 600, 
                  effect: () => { enemies.forEach(e => e.stunned = 600); showNotification('‚è∞ TIME FREEZE!', 3000); } },
                { id: 'nuke', name: 'Orbital Strike', icon: '‚ò¢Ô∏è', desc: 'Clear all enemies', cost: 800, 
                  effect: () => { enemies.forEach(e => { e.health = 0; createParticles(e.x, e.y, '#ff0000', 30); }); 
                                  enemies = []; screenShake = 40; showNotification('‚ò¢Ô∏è ORBITAL STRIKE!', 3000); } },
                { id: 'godMode', name: 'Invincibility', icon: 'üëë', desc: '30s Invincible', cost: 1000, 
                  effect: () => { player.invincible = 1800; showNotification('üëë GOD MODE!', 3000); } }
            ],
            ad: [
                // REWARDED AD ITEMS - Always appears in shop
                { id: 'adGold', name: 'üí∞ BONUS GOLD', icon: 'üì∫', desc: '+500 Gold', cost: 'ad', 
                  effect: () => { gold += 500; document.getElementById('goldDisplay').textContent = gold; 
                                  showNotification('üì∫ +500 GOLD!\nThanks for watching!', 3000); } },
                { id: 'adEssence', name: '‚ú® FREE ESSENCE', icon: 'üì∫', desc: '+50 Essence', cost: 'ad', 
                  effect: () => { 
                      const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + 50;
                      localStorage.setItem('plasmaSpecialCurrency', essence);
                      updateMainMenuStats();
                      showNotification('üì∫ +50 ESSENCE!\nThanks for watching!', 3000); 
                  } },
                { id: 'adPower', name: '‚ö° POWER SURGE', icon: 'üì∫', desc: '3x Dmg for 60s', cost: 'ad', 
                  effect: () => { 
                      const originalDamage = player.weapon ? player.weapon.damage : 0;
                      if (player.weapon) player.weapon.damage *= 3;
                      setTimeout(() => {
                          if (player.weapon) player.weapon.damage = Math.floor(player.weapon.damage / 3);
                      }, 60000);
                      showNotification('üì∫ POWER SURGE!\n3x Damage for 60s!', 4000); 
                  } },
                { id: 'adRevive', name: 'üíö SECOND CHANCE', icon: 'üì∫', desc: 'Revive on death', cost: 'ad', 
                  effect: () => { 
                      player.hasRevive = true;
                      showNotification('üì∫ SECOND CHANCE!\nYou will revive if you die!', 4000); 
                  } }
            ]
        };
        
        function generateShopItems() {
            currentShopItems = [];
            
            // Always add 1 random AD item first (most prominent)
            const adPool = [...SHOP_ITEM_POOL.ad];
            const adIndex = Math.floor(Math.random() * adPool.length);
            currentShopItems.push({
                ...adPool[adIndex],
                tier: 'ad'
            });
            
            // Generate 3 random items with weighted rarity
            for (let i = 0; i < 3; i++) {
                let tier;
                const roll = Math.random();
                
                if (roll < 0.60) tier = 'common';      // 60%
                else if (roll < 0.90) tier = 'rare';   // 30%
                else if (roll < 0.98) tier = 'epic';   // 8%
                else tier = 'legendary';               // 2%
                
                const pool = SHOP_ITEM_POOL[tier];
                const item = pool[Math.floor(Math.random() * pool.length)];
                
                currentShopItems.push({
                    ...item,
                    tier: tier
                });
            }
        }
        
        function updateShopUI() {
            const shopList = document.getElementById('shopList');
            if (!shopList) return;
            
            shopList.innerHTML = '';
            
            const tierColors = {
                common: '#9ca3af',
                rare: '#3b82f6',
                epic: '#a855f7',
                legendary: '#f59e0b',
                ad: '#ff1744' // Special red for ads
            };
            
            const tierNames = {
                common: 'Common',
                rare: 'Rare',
                epic: 'Epic',
                legendary: 'Legendary',
                ad: 'üì∫ WATCH AD'
            };
            
            currentShopItems.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                
                // Special styling for ad items
                if (item.tier === 'ad') {
                    itemDiv.style.borderColor = '#ff1744';
                    itemDiv.style.background = 'linear-gradient(135deg, rgba(255, 23, 68, 0.15), rgba(255, 23, 68, 0.05))';
                    itemDiv.style.boxShadow = '0 0 20px rgba(255, 23, 68, 0.4)';
                    itemDiv.style.animation = 'adPulse 2s infinite';
                } else {
                    itemDiv.style.borderColor = tierColors[item.tier];
                }
                
                itemDiv.style.cursor = 'pointer';
                
                // Cost display
                const costDisplay = item.cost === 'ad' 
                    ? '<div style="font-size: 16px; color: #ff1744; font-weight: bold; margin-top: 10px;">üì∫ WATCH AD</div>'
                    : `<div style="font-size: 16px; color: #ffd700; font-weight: bold; margin-top: 10px;">üí∞ ${item.cost}</div>`;
                
                itemDiv.innerHTML = `
                    <div style="font-size: 40px; margin-bottom: 10px;">${item.icon}</div>
                    <div style="font-size: 12px; color: ${tierColors[item.tier]}; margin-bottom: 5px; font-weight: bold;">${tierNames[item.tier]}</div>
                    <div style="font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 5px;">${item.name}</div>
                    <div style="font-size: 14px; color: #aaa; margin: 5px 0;">${item.desc}</div>
                    ${costDisplay}
                `;
                itemDiv.onclick = () => buyDynamicItem(index);
                shopList.appendChild(itemDiv);
            });
        }
        
        function buyDynamicItem(index) {
            if (index >= currentShopItems.length) return;
            
            const item = currentShopItems[index];
            
            // Handle AD items
            if (item.cost === 'ad') {
                showNotification('üì∫ Loading ad...', 1000);
                
                showCrazyGamesRewardedAd(() => {
                    // Grant reward after ad
                    item.effect();
                    
                    // Remove item from shop
                    currentShopItems.splice(index, 1);
                    updateShopUI();
                    
                    showNotification(`‚úÖ ${item.name} activated!`, 2000);
                    console.log(`‚úÖ Dynamic shop ad item: ${item.name}`);
                });
                
                return;
            }
            
            // Regular items - check gold
            if (gold >= item.cost) {
                gold -= item.cost;
                item.effect();
                
                const tierEmoji = {
                    common: '‚ö™',
                    rare: 'üîµ',
                    epic: 'üü£',
                    legendary: 'üü°',
                    ad: 'üì∫'
                };
                
                showNotification(`${tierEmoji[item.tier]} ${item.name}\n${item.desc}`, 3000);
                
                const shopGoldEl = document.getElementById('shopGoldAmount');
                if (shopGoldEl) shopGoldEl.textContent = gold;
                
                const goldDisplayEl = document.getElementById('goldDisplay');
                if (goldDisplayEl) goldDisplayEl.textContent = gold;
                
                // Remove purchased item and update UI
                currentShopItems.splice(index, 1);
                updateShopUI();
            } else {
                showNotification('‚ùå Not enough gold!', 2000);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function buyItem(itemType) {
            let cost = 0;
            let canBuy = true;
            
            switch(itemType) {
                case 'health':
                    cost = 50;
                    if (gold >= cost) {
                        player.health = Math.min(player.maxHealth, player.health + 100);
                        gold -= cost;
                        showNotification(t('purchased') + ' ‚ù§Ô∏è +100 HP', 2000);
                    } else {
                        canBuy = false;
                    }
                    break;
                    
                case 'damage':
                    cost = 100;
                    if (gold >= cost) {
                        Object.keys(WEAPONS).forEach(key => {
                            WEAPONS[key].damage = Math.floor(WEAPONS[key].damage * 1.2);
                        });
                        if (player.weapon) {
                            player.weapon.damage = Math.floor(player.weapon.damage * 1.2);
                        }
                        gold -= cost;
                        showNotification(t('purchased') + ' üí• +20% Hasar', 2000);
                    } else {
                        canBuy = false;
                    }
                    break;
                    
                case 'speed':
                    cost = 80;
                    if (gold >= cost) {
                        player.baseSpeed *= 1.15;
                        player.speed = player.baseSpeed;
                        if (player.weapon && player.weapon.ability === 'speed_boost') {
                            player.speed = player.baseSpeed * 1.2;
                        }
                        gold -= cost;
                        showNotification(t('purchased') + ' ‚ö° +15% Hƒ±z', 2000);
                    } else {
                        canBuy = false;
                    }
                    break;
                    
                case 'tower':
                    cost = 150;
                    if (gold >= cost) {
                        buildingPoints++;
                        gold -= cost;
                        showNotification(t('purchased') + ' üóº +1 Kule Hakkƒ±', 2000);
                    } else {
                        canBuy = false;
                    }
                    break;
                    
                case 'wall':
                    cost = 100;
                    if (gold >= cost) {
                        buildingPoints++;
                        gold -= cost;
                        showNotification(t('purchased') + ' üß± +1 Duvar Hakkƒ±', 2000);
                    } else {
                        canBuy = false;
                    }
                    break;
            }
            
            if (!canBuy) {
                showNotification(t('notEnoughGold'), 2000);
            }
            
            document.getElementById('shopGoldAmount').textContent = gold;
            document.getElementById('goldDisplay').textContent = gold;
        }
        
        // Power-up spawn
        function spawnPowerUp(x, y, type) {
            if (!type) {
                const types = Object.keys(POWERUP_TYPES);
                type = types[Math.floor(Math.random() * types.length)];
            }
            
            powerUps.push({
                x, y,
                type,
                size: 25,
                lifetime: 600,
                pulse: 0
            });
        }
        
        // Power-up toplama
        function collectPowerUp(powerUp) {
            const type = POWERUP_TYPES[powerUp.type];
            
            if (powerUp.type === 'health') {
                player.health = Math.min(player.maxHealth, player.health + type.value);
                showNotification(t('powerUpCollected', type.icon + ' +' + type.value + ' HP'), 2000);
            } else {
                activePowerUps[powerUp.type] = type.duration;
                showNotification(t('powerUpCollected', type.icon + ' ' + powerUp.type.toUpperCase()), 2000);
            }
            
            powerUps.splice(powerUps.indexOf(powerUp), 1);
            updatePowerUpDisplay();
        }
        
        // Power-up display g√ºncelle
        function updatePowerUpDisplay() {
            const display = document.getElementById('powerUpDisplay');
            display.innerHTML = '';
            
            for (let type in activePowerUps) {
                if (activePowerUps[type] > 0) {
                    const powerUpType = POWERUP_TYPES[type];
                    const timeLeft = Math.ceil(activePowerUps[type] / 60);
                    
                    const div = document.createElement('div');
                    div.className = 'active-powerup';
                    div.innerHTML = `
                        <span class="powerup-icon">${powerUpType.icon}</span>
                        <span>${type.toUpperCase()}</span>
                        <span class="powerup-timer">${timeLeft}s</span>
                    `;
                    display.appendChild(div);
                }
            }
        }
        
        // Random event ba≈ülat
        function startRandomEvent() {
            const eventKeys = Object.keys(EVENTS);
            const randomEvent = eventKeys[Math.floor(Math.random() * eventKeys.length)];
            const event = EVENTS[randomEvent];
            
            currentEvent = {
                type: randomEvent,
                ...event,
                timer: 0
            };
            
            const eventName = currentLanguage === 'en' ? event.nameEn : event.nameTr;
            showNotification(t('eventActive', eventName), 3000);
            
            if (event.instant) {
                if (randomEvent === 'supplyDrop') {
                    for (let i = 0; i < event.powerUpCount; i++) {
                        const angle = (i / event.powerUpCount) * Math.PI * 2;
                        const dist = 200 + Math.random() * 100;
                        spawnPowerUp(
                            player.x + Math.cos(angle) * dist,
                            player.y + Math.sin(angle) * dist
                        );
                    }
                }
                currentEvent = null;
            }
            
            eventTimer = 0;
        }
        
        // Base customization modal
        function showBaseCustomization() {
            // Oyunu pause et
            if (gameState === 'playing') {
                previousGameState = 'playing';
                gameState = 'paused';
            }
            
            document.getElementById('baseCustomizationModal').classList.add('active');
            updateBaseCustomizationDisplay();
        }
        
        function closeBaseCustomization() {
            document.getElementById('baseCustomizationModal').classList.remove('active');
            
            // Oyunu resume et
            if (previousGameState === 'playing') {
                gameState = 'playing';
            }
        }
        
        function updateBaseCustomizationDisplay() {
            // Skins
            const skinsGrid = document.getElementById('baseSkinsGrid');
            skinsGrid.innerHTML = '';
            
            Object.keys(BASE_SKINS).forEach(skinKey => {
                const skin = BASE_SKINS[skinKey];
                const isSelected = baseCustomization.skin === skinKey;
                const isLocked = !skin.unlocked && gold < skin.cost;
                
                const item = document.createElement('div');
                item.className = 'base-skin-item';
                if (isSelected) item.classList.add('selected');
                if (isLocked) item.classList.add('locked');
                
                item.innerHTML = `
                    <div class="base-skin-preview" style="background: ${skin.color};"></div>
                    <div class="base-skin-name">${currentLanguage === 'en' ? skin.name : skin.nameTr}</div>
                    <div class="base-skin-cost">${skin.cost === 0 ? 'FREE' : 'üí∞ ' + skin.cost}</div>
                    ${isSelected ? '<div style="color: #00ff88; font-size: 12px; margin-top: 5px;">‚úì EQUIPPED</div>' : ''}
                `;
                
                item.onclick = () => selectBaseSkin(skinKey);
                skinsGrid.appendChild(item);
            });
            
            // Upgrades
            const upgradesGrid = document.getElementById('baseUpgradesGrid');
            upgradesGrid.innerHTML = '';
            
            Object.keys(BASE_UPGRADES).forEach(upgradeKey => {
                const upgrade = BASE_UPGRADES[upgradeKey];
                const isOwned = baseCustomization[upgradeKey];
                const isLocked = !isOwned && gold < upgrade.cost;
                
                const icons = {
                    autoTurret: 'üî´',
                    forceField: 'üõ°Ô∏è',
                    teslaTower: '‚ö°',
                    missileLauncher: 'üöÄ'
                };
                
                const item = document.createElement('div');
                item.className = 'base-upgrade-item';
                if (isOwned) item.classList.add('owned');
                if (isLocked) item.classList.add('locked');
                
                item.innerHTML = `
                    <div class="base-upgrade-icon">${icons[upgradeKey]}</div>
                    <div class="base-upgrade-name">${currentLanguage === 'en' ? upgrade.name : upgrade.nameTr}</div>
                    <div class="base-upgrade-desc">${currentLanguage === 'en' ? upgrade.description : upgrade.descriptionTr}</div>
                    <div class="base-upgrade-cost">${isOwned ? '‚úì OWNED' : 'üí∞ ' + upgrade.cost}</div>
                `;
                
                if (!isOwned) {
                    item.onclick = () => buyBaseUpgrade(upgradeKey);
                }
                
                upgradesGrid.appendChild(item);
            });
        }
        
        function selectBaseSkin(skinKey) {
            const skin = BASE_SKINS[skinKey];
            
            // Unlock kontrol√º
            if (!skin.unlocked && skin.cost > 0) {
                if (gold >= skin.cost) {
                    gold -= skin.cost;
                    skin.unlocked = true;
                    document.getElementById('goldDisplay').textContent = gold;
                    showNotification(`üé® Skin unlocked: ${skin.name}!`, 2000);
                } else {
                    showNotification(t('notEnoughGold'), 2000);
                    return;
                }
            }
            
            baseCustomization.skin = skinKey;
            saveBaseCustomization();
            
            // Base rengini g√ºncelle
            if (base) {
                base.color = skin.color;
            }
            
            updateBaseCustomizationDisplay();
        }
        
        function buyBaseUpgrade(upgradeKey) {
            const upgrade = BASE_UPGRADES[upgradeKey];
            
            if (gold >= upgrade.cost) {
                gold -= upgrade.cost;
                baseCustomization[upgradeKey] = true;
                document.getElementById('goldDisplay').textContent = gold;
                saveBaseCustomization();
                showNotification(`‚ö° Upgrade purchased: ${upgrade.name}!`, 2000);
                updateBaseCustomizationDisplay();
            } else {
                showNotification(t('notEnoughGold'), 2000);
            }
        }
        
        // Boss Rush Mode
        function toggleBossRush() {
            bossRushMode = !bossRushMode;
            const button = document.getElementById('bossRushButton');
            
            if (bossRushMode) {
                button.classList.add('active');
                showNotification('üëπ BOSS RUSH MODE ACTIVATED!\nEvery wave is a boss!', 3000);
            } else {
                button.classList.remove('active');
                showNotification('‚úì Boss Rush Mode deactivated', 2000);
            }
        }
        
        // Silah Aƒüa√ßlarƒ± Sistemi
        let selectedWeaponTree = null;
        
        const WEAPON_TREES = {
            melee: {
                name: 'Yakƒ±n Mesafe',
                nameEn: 'Melee',
                icon: '‚öîÔ∏è',
                ability: 'dodge_roll',
                abilityName: 'Dodge Roll',
                abilityNameTr: 'Ka√ßƒ±≈ü Takla',
                abilityDesc: 'Double tap Space to dodge (Unlocks Wave 4)',
                abilityDescTr: '2x Space ile ka√ßƒ±≈ü takla (4. dalgada a√ßƒ±lƒ±r)',
                abilityCooldown: 120, // 2 saniye
                weapons: {
                    woodenSword: { 
                        name: 'Ah≈üap Kƒ±lƒ±√ß',
                        nameEn: 'Wooden Sword',
                        damage: 20, 
                        range: 60, 
                        color: '#8B4513', 
                        speed: 1.5,
                        reloadTime: 20,
                        unlockKills: 0,
                        type: 'melee'
                    },
                    ironSword: { 
                        name: 'Demir Kƒ±lƒ±√ß',
                        nameEn: 'Iron Sword',
                        damage: 35, 
                        range: 70, 
                        color: '#708090', 
                        speed: 1.3,
                        reloadTime: 15,
                        unlockKills: 15,
                        type: 'melee'
                    },
                    battleAxe: {
                        name: 'ü™ì Sava≈ü Baltasƒ±',
                        nameEn: 'ü™ì Battle Axe',
                        damage: 55,
                        range: 65,
                        color: '#7c2d12',
                        speed: 1.8,
                        reloadTime: 40,
                        ability: 'cleave',
                        unlockKills: 35,
                        type: 'melee'
                    },
                    steelSword: { 
                        name: '√áelik Kƒ±lƒ±√ß',
                        nameEn: 'Steel Sword',
                        damage: 50, 
                        range: 80, 
                        color: '#C0C0C0', 
                        speed: 1.0,
                        reloadTime: 10,
                        ability: 'speed_boost',
                        unlockKills: 60,
                        type: 'melee'
                    },
                    dualBlades: {
                        name: '‚öîÔ∏è ƒ∞kiz Bƒ±√ßaklar',
                        nameEn: '‚öîÔ∏è Dual Blades',
                        damage: 40,
                        range: 50,
                        color: '#a855f7',
                        speed: 0.5,
                        reloadTime: 8,
                        ability: 'double_strike',
                        unlockKills: 100,
                        type: 'melee'
                    },
                    lightsaber: {
                        name: '‚ö° I≈üƒ±n Kƒ±lƒ±cƒ±',
                        nameEn: '‚ö° Lightsaber',
                        damage: 90,
                        range: 95,
                        color: '#3b82f6',
                        speed: 0.6,
                        reloadTime: 3,
                        ability: 'laser_cut',
                        unlockKills: 150,
                        type: 'melee'
                    }
                }
            },
            ranged: {
                name: 'Uzak Mesafe',
                nameEn: 'Ranged',
                icon: 'üèπ',
                ability: 'critical_shot',
                abilityName: 'Critical Shot',
                abilityNameTr: 'Kritik Atƒ±≈ü',
                abilityDesc: '30% critical hit chance (Unlocks Wave 4)',
                abilityDescTr: '%30 kritik vuru≈ü ≈üansƒ± (4. dalgada a√ßƒ±lƒ±r)',
                abilityCooldown: 0, // Pasif yetenek
                weapons: {
                    huntingBow: {
                        name: 'üèπ Av Yayƒ±',
                        nameEn: 'üèπ Hunting Bow',
                        damage: 25,
                        range: 200,
                        color: '#65a30d',
                        speed: 1.4,
                        reloadTime: 30,
                        unlockKills: 0,
                        type: 'ranged'
                    },
                    steelBow: {
                        name: 'üèπ √áelik Yay',
                        nameEn: 'üèπ Steel Bow',
                        damage: 40,
                        range: 250,
                        color: '#059669',
                        speed: 1.1,
                        reloadTime: 25,
                        unlockKills: 15,
                        type: 'ranged'
                    },
                    crossbow: {
                        name: 'üéØ Aƒüƒ±r Arbalet',
                        nameEn: 'üéØ Heavy Crossbow',
                        damage: 70,
                        range: 280,
                        color: '#78716c',
                        speed: 1.8,
                        reloadTime: 50,
                        ability: 'pierce',
                        unlockKills: 35,
                        type: 'ranged'
                    },
                    firearm: {
                        name: 'üî´ Ate≈üli Silah',
                        nameEn: 'üî´ Firearm',
                        damage: 55,
                        range: 300,
                        color: '#fb923c',
                        speed: 0.9,
                        reloadTime: 20,
                        ability: 'rapid',
                        unlockKills: 60,
                        type: 'ranged'
                    },
                    laserRifle: {
                        name: '‚ö° Lazer T√ºfeƒüi',
                        nameEn: '‚ö° Laser Rifle',
                        damage: 65,
                        range: 350,
                        color: '#06b6d4',
                        speed: 0.7,
                        reloadTime: 15,
                        ability: 'pierce',
                        unlockKills: 100,
                        type: 'ranged'
                    },
                    plasmaCannon: {
                        name: 'üî´ Plazma Topu',
                        nameEn: 'üî´ Plasma Cannon',
                        damage: 100,
                        range: 280,
                        color: '#8b5cf6',
                        speed: 2.0,
                        reloadTime: 60,
                        ability: 'explosion',
                        unlockKills: 150,
                        type: 'ranged'
                    }
                }
            },
            hybrid: {
                name: 'Hibrit',
                nameEn: 'Hybrid',
                icon: 'üî•',
                ability: 'sprint',
                abilityName: 'Sprint',
                abilityNameTr: 'Ko≈üu',
                abilityDesc: 'Hold Shift for speed boost (Unlocks Wave 4)',
                abilityDescTr: 'Shift ile hƒ±z artƒ±≈üƒ± (4. dalgada a√ßƒ±lƒ±r)',
                abilityCooldown: 180, // 3 saniye cooldown
                abilityDuration: 180, // 3 saniye s√ºre
                weapons: {
                    torch: {
                        name: 'üî• Me≈üale',
                        nameEn: 'üî• Torch',
                        damage: 18,
                        range: 70,
                        color: '#f97316',
                        speed: 1.3,
                        reloadTime: 18,
                        ability: 'burn',
                        unlockKills: 0,
                        type: 'hybrid' // Changed to hybrid for testing
                    },
                    flameSword: {
                        name: 'üî• Alev Kƒ±lƒ±cƒ±',
                        nameEn: 'üî• Flame Sword',
                        damage: 35,
                        range: 85,
                        color: '#ea580c',
                        speed: 1.1,
                        reloadTime: 12,
                        ability: 'burn',
                        unlockKills: 15,
                        type: 'melee'
                    },
                    fireAxe: {
                        name: 'üî• Ate≈ü Baltasƒ±',
                        nameEn: 'üî• Fire Axe',
                        damage: 50,
                        range: 75,
                        color: '#dc2626',
                        speed: 1.2,
                        reloadTime: 15,
                        ability: 'dash',
                        unlockKills: 35,
                        type: 'melee'
                    },
                    burningChain: {
                        name: '‚õìÔ∏è Yanƒ±k Zincir',
                        nameEn: '‚õìÔ∏è Burning Chain',
                        damage: 45,
                        range: 120,
                        color: '#b91c1c',
                        speed: 1.0,
                        reloadTime: 20,
                        ability: 'chain',
                        unlockKills: 60,
                        type: 'hybrid'
                    },
                    meteorHammer: {
                        name: 'üí• Meteor √áekici',
                        nameEn: 'üí• Meteor Hammer',
                        damage: 75,
                        range: 90,
                        color: '#991b1b',
                        speed: 1.5,
                        reloadTime: 35,
                        ability: 'meteor',
                        unlockKills: 100,
                        type: 'melee'
                    },
                    sunSpear: {
                        name: 'üåü G√ºne≈ü Mƒ±zraƒüƒ±',
                        nameEn: 'üåü Sun Spear',
                        damage: 85,
                        range: 130,
                        color: '#fbbf24',
                        speed: 0.8,
                        reloadTime: 10,
                        ability: 'radiance',
                        unlockKills: 150,
                        type: 'hybrid'
                    }
                }
            }
        };
        
        // Silahƒ±n √ßevrilmi≈ü ismini al
        function getWeaponName(weapon) {
            if (!weapon) return '';
            return currentLanguage === 'en' ? (weapon.nameEn || weapon.name) : weapon.name;
        }
        
        let WEAPONS = {}; // Se√ßilen aƒüaca g√∂re dolacak
        
        // Silah aƒüacƒ± se√ßimi
        function selectWeaponTree(tree) {
            console.log('selectWeaponTree called:', tree);
            selectedWeaponTree = tree;
            WEAPONS = WEAPON_TREES[tree].weapons;
            
            // Ability ayarla
            const treeData = WEAPON_TREES[tree];
            abilityName = currentLanguage === 'en' ? treeData.abilityName : treeData.abilityNameTr;
            abilityMaxCooldown = treeData.abilityCooldown || 180;
            
            // ƒ∞lk silahƒ± equiple
            const firstWeaponKey = Object.keys(WEAPONS)[0];
            player.weapon = WEAPONS[firstWeaponKey];
            
            // APPLY ACTIVE PERKS
            applyActivePerks();
            console.log('Active perks applied:', equippedItems.perks);
            
            // UI g√ºncelle
            document.getElementById('weaponInfo').textContent = t('weapon') + ': ' + player.weapon.name;
            
            // Se√ßim ekranƒ±nƒ± kapat
            document.getElementById('weaponSelection').classList.add('hidden');
            console.log('weaponSelection hidden');
            
            // Base placement'ƒ± g√∂ster
            document.getElementById('basePlacement').classList.remove('hidden');
            console.log('basePlacement shown');
            
            // Base placement'a ge√ß
            gameState = 'placement';
            console.log('gameState set to placement');
            
            // Silah aƒüacƒ± butonunu g√∂ster
            document.getElementById('weaponTreeButton').style.display = 'block';
            
            // Bildirim g√∂ster
            const treeName = t(tree);
            showNotification(t('treeSelected', `${WEAPON_TREES[tree].icon} ${treeName}`, player.weapon.name), 4000);
        }
        
        // Silah tipleri (eski sistem - kaldƒ±rƒ±ldƒ±)
        
        // D√º≈üman tipleri - Futuristik Robot/Drone temasƒ±
        const ENEMY_TYPES = {
            scout: { 
                name: 'Scout Drone', 
                health: 30, 
                speed: 0.8,
                damage: 5, 
                color: '#06b6d4', 
                size: 20,
                scoreValue: 10,
                xpValue: 15,
                ability: 'speed',
                targetPreference: 'player',
                threatLevel: 3, // Low threat
                role: 'normal'
            },
            combat: { 
                name: 'Combat Bot', 
                health: 50, 
                speed: 0.6,
                damage: 10, 
                color: '#f59e0b', 
                size: 25,
                scoreValue: 20,
                xpValue: 30,
                ability: 'shoot',
                targetPreference: 'player',
                threatLevel: 3,
                role: 'normal'
            },
            heavy: { 
                name: 'Heavy Mech', 
                health: 80, 
                speed: 0.5,
                damage: 15, 
                color: '#ef4444', 
                size: 30,
                scoreValue: 35,
                xpValue: 50,
                ability: 'flame',
                targetPreference: 'base',
                threatLevel: 4, // Tank - low priority
                role: 'tank'
            },
            elite: { 
                name: 'Elite Unit', 
                health: 150, 
                speed: 0.7,
                damage: 25, 
                color: '#8b5cf6', 
                size: 35,
                scoreValue: 50,
                xpValue: 100,
                ability: 'laser',
                targetPreference: 'base',
                threatLevel: 4,
                role: 'tank'
            },
            teleporter: {
                name: 'Teleporter',
                health: 40,
                speed: 0.9,
                damage: 8,
                color: '#06b6d4',
                size: 22,
                scoreValue: 30,
                xpValue: 40,
                ability: 'teleport',
                targetPreference: 'player',
                threatLevel: 2, // High threat - teleports to base
                role: 'assassin'
            },
            summoner: {
                name: 'Summoner',
                health: 60,
                speed: 0.4,
                damage: 5,
                color: '#c084fc',
                size: 28,
                scoreValue: 40,
                xpValue: 60,
                ability: 'summon',
                targetPreference: 'base',
                threatLevel: 1, // HIGHEST THREAT - spawns enemies
                role: 'spawner'
            },
            tank: {
                name: 'Tank Bot',
                health: 200,
                speed: 0.3,
                damage: 30,
                color: '#1e293b',
                size: 40,
                scoreValue: 60,
                xpValue: 80,
                ability: 'shield',
                targetPreference: 'base',
                threatLevel: 5, // Lowest priority - tanky but slow
                role: 'tank'
            },
            runner: {
                name: 'Speed Runner',
                health: 25,
                speed: 1.5,
                damage: 12,
                color: '#10b981',
                size: 18,
                scoreValue: 25,
                xpValue: 35,
                ability: 'sprint',
                targetPreference: 'player',
                threatLevel: 2, // High threat - fast, reaches base quickly
                role: 'assassin'
            },
            healer: {
                name: 'Support Drone',
                health: 50,
                speed: 0.5,
                damage: 3,
                color: '#22c55e',
                size: 24,
                scoreValue: 80,
                xpValue: 120,
                ability: 'heal',
                targetPreference: 'base',
                threatLevel: 1, // HIGHEST PRIORITY - heals other enemies!
                role: 'healer',
                healAmount: 20,
                healRange: 150,
                healCooldown: 3000 // 3 seconds
            },
            buffer: {
                name: 'Boost Unit',
                health: 60,
                speed: 0.5,
                damage: 5,
                color: '#f59e0b',
                size: 26,
                scoreValue: 70,
                xpValue: 100,
                ability: 'buff',
                targetPreference: 'base',
                threatLevel: 1, // HIGHEST PRIORITY - buffs allies!
                role: 'buffer',
                buffRange: 200,
                buffAmount: 0.5 // +50% damage to allies
            }
        };
        
        // Oyuncu
        const player = {
            x: ARENA_SIZE / 2,
            y: ARENA_SIZE / 2,
            size: 25,
            health: 100,
            maxHealth: 100,
            speed: 3,
            baseSpeed: 3,
            color: '#00aaff',
            weapon: null, // Aƒüa√ß se√ßilince ayarlanacak
            attacking: false,
            attackCooldown: 0,
            attackAngle: 0,
            attackFrame: 0,
            direction: 0,
            idleFrame: 0,
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            visualTier: 1,
            reloading: false,
            reloadProgress: 0,
            canAttack: true,
            dashCooldown: 0,
            dashActive: false
        };
        
        let notifications = []; // Bildirimler i√ßin
        let gameState = 'selection'; // 'selection', 'placement', 'playing', 'paused', 'gameover'
        let continueUsed = false; // Track if player used continue with ad
        let base = null; // Oyuncu √ºss√º
        let baseUpgradeAvailable = false; // √ús y√ºkseltilebilir mi?
        let buildings = []; // Oyuncu yapƒ±larƒ±
        let buildingSynergies = []; // Active synergy connections
        let soldiers = []; // Barracks'tan spawn olan askerler
        let buildingPoints = 0; // Ka√ß yapƒ± in≈üa edebilir
        let buildMode = null; // 'tower', 'wall', 'farm' veya null
        
        // PERK APPLICATION SYSTEM
        function applyActivePerks() {
            // Reset to base values
            player.maxHealth = 100;
            player.baseSpeed = 3;
            
            // Check if perks exist
            if (!equippedItems.perks || !Array.isArray(equippedItems.perks)) {
                console.log('No perks to apply');
                player.speed = player.baseSpeed;
                return;
            }
            
            // Apply each active perk
            equippedItems.perks.forEach(perkId => {
                switch(perkId) {
                    case 'perk_health':
                        // Extra Life: +50 Max HP
                        player.maxHealth += 50;
                        break;
                    case 'perk_damage':
                        // Power Boost: +10% Damage (applied in attack calculation)
                        break;
                    case 'perk_speed':
                        // Swift Feet: +15% Speed
                        player.baseSpeed *= 1.15;
                        break;
                    case 'perk_goldbonus':
                        // Wealth: +25% Gold (applied in gold reward)
                        break;
                    case 'perk_xpbonus':
                        // Fast Learner: +30% XP (applied in XP gain)
                        break;
                    case 'perk_buildpoints':
                        // Architect: +2 Starting buildings
                        buildingPoints += 2;
                        break;
                    case 'perk_startlevel':
                        // Head Start: Start at level 3
                        if (player.level === 1) {
                            player.level = 3;
                            player.xp = 0;
                            player.xpToNextLevel = 100 + (player.level - 1) * 50;
                        }
                        break;
                }
            });
            
            // Heal to new max if increased
            if (player.health > player.maxHealth) {
                player.health = player.maxHealth;
            }
            
            // Update speed
            player.speed = player.baseSpeed;
        }
        
        // Check if perk is active
        function hasPerk(perkId) {
            return equippedItems.perks && Array.isArray(equippedItems.perks) && equippedItems.perks.includes(perkId);
        }
        
        // ACHIEVEMENT SYSTEM
        let achievements = {
            firstBlood: { unlocked: false, name: 'First Blood', desc: 'Kill your first enemy', icon: 'ü©∏' },
            centurion: { unlocked: false, name: 'Centurion', desc: 'Kill 100 enemies', icon: 'üíØ' },
            untouchable: { unlocked: false, name: 'Untouchable', desc: 'Survive 5 waves without damage', icon: 'üõ°Ô∏è' },
            collector: { unlocked: false, name: 'Collector', desc: 'Earn 10,000 gold', icon: 'üí∞' },
            speedRunner: { unlocked: false, name: 'Speed Runner', desc: 'Reach wave 10 in 5 minutes', icon: '‚ö°' },
            architect: { unlocked: false, name: 'Architect', desc: 'Build 10 structures', icon: 'üèóÔ∏è' },
            jediMaster: { unlocked: false, name: 'Jedi Master', desc: 'Spawn 20 soldiers', icon: '‚öîÔ∏è' },
            survivor: { unlocked: false, name: 'Survivor', desc: 'Reach wave 20', icon: 'üèÜ' },
            legendary: { unlocked: false, name: 'Legendary', desc: 'Reach wave 30', icon: 'üëë' },
            destroyer: { unlocked: false, name: 'Destroyer', desc: 'Kill 500 enemies', icon: 'üíÄ' }
        };
        
        let achievementTracking = {
            totalKills: 0,
            totalGold: 0,
            totalBuildings: 0,
            totalSoldiers: 0,
            wavesWithoutDamage: 0,
            gameStartTime: 0,
            lastWaveDamaged: 0
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEEKLY CHALLENGES SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let weeklyChallenges = [];
        
        const CHALLENGE_POOL = [
            // Kill Challenges (3-7 days)
            { id: 'kill_1000', name: 'üéØ Exterminator', desc: 'Kill 1,000 enemies', target: 1000, type: 'kills', reward: 150, duration: 7 },
            { id: 'kill_2500', name: '‚öîÔ∏è Slayer', desc: 'Kill 2,500 enemies', target: 2500, type: 'kills', reward: 300, duration: 7 },
            { id: 'kill_5000', name: 'üíÄ Death Incarnate', desc: 'Kill 5,000 enemies', target: 5000, type: 'kills', reward: 500, duration: 7 },
            
            // Building Challenges (3-5 days)
            { id: 'build_100', name: 'üèóÔ∏è Constructor', desc: 'Build 100 structures', target: 100, type: 'buildings', reward: 120, duration: 5 },
            { id: 'build_250', name: 'üè∞ Architect Master', desc: 'Build 250 structures', target: 250, type: 'buildings', reward: 250, duration: 7 },
            
            // Wave Challenges (Multiple attempts)
            { id: 'wave_30', name: 'üåä Wave Warrior', desc: 'Reach wave 30', target: 30, type: 'wave', reward: 200, duration: 7 },
            { id: 'wave_40', name: '‚ö° Unstoppable', desc: 'Reach wave 40', target: 40, type: 'wave', reward: 350, duration: 7 },
            { id: 'wave_50', name: 'üëë Legendary', desc: 'Reach wave 50', target: 50, type: 'wave', reward: 500, duration: 7 },
            
            // Score Challenges (1-2 weeks)
            { id: 'score_50k', name: 'üíØ High Scorer', desc: 'Score 50,000 points', target: 50000, type: 'score', reward: 200, duration: 7 },
            { id: 'score_100k', name: 'üèÜ Elite Player', desc: 'Score 100,000 points', target: 100000, type: 'score', reward: 400, duration: 14 },
            
            // Gold Challenges (3-5 days)
            { id: 'gold_25k', name: 'üí∞ Rich', desc: 'Earn 25,000 gold', target: 25000, type: 'gold', reward: 150, duration: 5 },
            { id: 'gold_50k', name: 'üíé Wealthy', desc: 'Earn 50,000 gold', target: 50000, type: 'gold', reward: 300, duration: 7 },
            
            // Soldier Challenges (5-7 days)
            { id: 'soldiers_200', name: '‚öîÔ∏è Recruiter', desc: 'Spawn 200 soldiers', target: 200, type: 'soldiers', reward: 150, duration: 7 },
            { id: 'soldiers_500', name: 'üë• Army Commander', desc: 'Spawn 500 soldiers', target: 500, type: 'soldiers', reward: 350, duration: 7 },
            
            // Perfect Run Challenges (Hard)
            { id: 'nodamage_10', name: 'üõ°Ô∏è Untouchable', desc: 'Complete 10 waves without damage', target: 10, type: 'nodamage', reward: 400, duration: 7 },
            
            // Playtime Challenges (1-2 weeks)
            { id: 'playtime_10h', name: '‚è±Ô∏è Dedicated', desc: 'Play for 10 hours total', target: 600, type: 'playtime', reward: 250, duration: 14 }, // 10h in minutes
            { id: 'playtime_25h', name: 'üéÆ Veteran', desc: 'Play for 25 hours total', target: 1500, type: 'playtime', reward: 500, duration: 14 }
        ];
        
        function initializeWeeklyChallenges() {
            const saved = localStorage.getItem('plasmaWeeklyChallenges');
            const lastReset = localStorage.getItem('plasmaWeeklyChallengesReset');
            
            const now = Date.now();
            const weekInMs = 7 * 24 * 60 * 60 * 1000;
            
            console.log('Initializing weekly challenges...');
            console.log('Saved challenges:', saved);
            console.log('Last reset:', lastReset);
            
            // Check if we need to reset (weekly)
            if (!lastReset || now - parseInt(lastReset) > weekInMs) {
                console.log('Generating new challenges...');
                // Generate 3 random challenges
                weeklyChallenges = generateWeeklyChallenges();
                saveWeeklyChallenges();
                localStorage.setItem('plasmaWeeklyChallengesReset', now);
            } else if (saved) {
                console.log('Loading saved challenges...');
                weeklyChallenges = JSON.parse(saved);
            } else {
                console.log('No saved challenges, generating new...');
                weeklyChallenges = generateWeeklyChallenges();
                saveWeeklyChallenges();
            }
            
            console.log('Weekly challenges loaded:', weeklyChallenges);
        }
        
        function generateWeeklyChallenges() {
            const challenges = [];
            const pool = [...CHALLENGE_POOL];
            
            // Select 3 random challenges
            for (let i = 0; i < 3; i++) {
                if (pool.length === 0) break;
                const index = Math.floor(Math.random() * pool.length);
                const challenge = { ...pool[index], progress: 0, completed: false };
                challenges.push(challenge);
                pool.splice(index, 1);
            }
            
            return challenges;
        }
        
        function saveWeeklyChallenges() {
            localStorage.setItem('plasmaWeeklyChallenges', JSON.stringify(weeklyChallenges));
        }
        
        function updateChallengeProgress(type, value) {
            console.log(`Challenge progress: ${type} +${value}`);
            console.log('Current challenges:', weeklyChallenges);
            
            let hasProgress = false;
            
            weeklyChallenges.forEach(challenge => {
                if (challenge.completed) return;
                
                if (challenge.type === type) {
                    hasProgress = true;
                    
                    const oldProgress = challenge.progress;
                    
                    if (type === 'wave' || type === 'score' || type === 'nodamage') {
                        // Max value challenges
                        challenge.progress = Math.max(challenge.progress, value);
                    } else {
                        // Cumulative challenges
                        challenge.progress += value;
                    }
                    
                    console.log(`${challenge.name}: ${oldProgress} ‚Üí ${challenge.progress} / ${challenge.target}`);
                    
                    // Check completion
                    if (challenge.progress >= challenge.target && !challenge.completed) {
                        challenge.completed = true;
                        
                        // Award essence
                        const essence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0) + challenge.reward;
                        localStorage.setItem('plasmaSpecialCurrency', essence);
                        
                        // Update main menu stats
                        updateMainMenuStats();
                        
                        console.log(`‚ú® Challenge completed! Reward: ${challenge.reward} essence`);
                        showNotification(`‚ú® CHALLENGE COMPLETE!\n${challenge.name}\nReward: ${challenge.reward} Essence`, 4000);
                        screenShake = 20;
                    }
                }
            });
            
            // Save and update display if any progress was made
            if (hasProgress) {
                console.log('Saving challenges and updating display...');
                saveWeeklyChallenges();
                updateWeeklyChallengesDisplay();
            } else {
                console.log('No matching challenge for type:', type);
            }
        }
        
        function updateWeeklyChallengesDisplay() {
            const list = document.getElementById('weeklyChallengesList');
            if (!list) return;
            
            list.innerHTML = '';
            
            weeklyChallenges.forEach(challenge => {
                const progress = Math.min(challenge.progress, challenge.target);
                const percent = (progress / challenge.target * 100).toFixed(0);
                
                const item = document.createElement('div');
                item.className = 'challenge-item';
                if (challenge.completed) {
                    item.style.opacity = '0.6';
                    item.style.borderColor = 'rgba(0, 255, 136, 0.5)';
                }
                
                item.innerHTML = `
                    <div class="challenge-name">${challenge.name}${challenge.completed ? ' ‚úì' : ''}</div>
                    <div class="challenge-desc">${challenge.desc}</div>
                    <div class="challenge-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="progress-text">${progress}/${challenge.target}</div>
                    </div>
                    <div class="challenge-reward">Reward: ${challenge.reward} ‚ú® Essence${challenge.completed ? ' (Claimed)' : ''}</div>
                `;
                
                list.appendChild(item);
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PLAYTIME TRACKING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let sessionStartTime = 0;
        let totalPlaytimeMinutes = 0;
        
        function initializePlaytime() {
            totalPlaytimeMinutes = parseInt(localStorage.getItem('plasmaTotalPlaytime') || 0);
            sessionStartTime = Date.now();
        }
        
        function updatePlaytime() {
            if (gameState !== 'playing') return;
            
            const now = Date.now();
            const sessionMinutes = Math.floor((now - sessionStartTime) / 60000);
            
            if (sessionMinutes > 0) {
                totalPlaytimeMinutes += sessionMinutes;
                localStorage.setItem('plasmaTotalPlaytime', totalPlaytimeMinutes);
                sessionStartTime = now;
                
                // Update challenge progress
                updateChallengeProgress('playtime', sessionMinutes);
                
                // Update display
                updatePlaytimeDisplay();
            }
        }
        
        function updatePlaytimeDisplay() {
            const hours = Math.floor(totalPlaytimeMinutes / 60);
            const minutes = totalPlaytimeMinutes % 60;
            const display = `${hours}h ${minutes}m`;
            
            const el = document.getElementById('totalPlaytime');
            if (el) el.textContent = display;
        }
        
        // Update playtime every minute
        setInterval(updatePlaytime, 60000);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Wave sistemi
        let waveActive = false;
        let waveEnemiesRemaining = 0;
        let waveTransition = false;
        let waveStartDelay = 0;
        let totalBuildingsBuilt = 0; // ƒ∞statistik i√ßin
        let muzzleFlashes = []; // Ate≈ü animasyonlarƒ±
        let screenShake = 0; // Ekran sarsƒ±ntƒ±sƒ±
        let mapDecorations = []; // Harita dekorasyonlarƒ±
        
        // Harita dekorasyonlarƒ± olu≈ütur
        function generateMapDecorations() {
            mapDecorations = [];
            const decorationTypes = ['rock', 'tnt', 'ruins', 'crystal', 'energyShield'];
            
            for (let i = 0; i < 50; i++) {
                const type = decorationTypes[Math.floor(Math.random() * decorationTypes.length)];
                const x = Math.random() * ARENA_SIZE;
                const y = Math.random() * ARENA_SIZE;
                
                // Merkeze √ßok yakƒ±n olmasƒ±n
                const distFromCenter = Math.sqrt(
                    Math.pow(x - ARENA_SIZE / 2, 2) + 
                    Math.pow(y - ARENA_SIZE / 2, 2)
                );
                if (distFromCenter < 300) continue;
                
                mapDecorations.push({
                    type,
                    x, y,
                    size: type === 'tnt' ? 35 : 30 + Math.random() * 40,
                    rotation: Math.random() * Math.PI * 2,
                    variant: Math.floor(Math.random() * 3),
                    health: type === 'tnt' ? 50 : null, // TNT'nin 50 canƒ± var
                    maxHealth: type === 'tnt' ? 50 : null,
                    exploded: false
                });
            }
        }
        
        // Dekorasyonlarƒ± √ßiz
        function drawMapDecorations() {
            mapDecorations.forEach(deco => {
                if (deco.exploded) return;
                
                const dx = deco.x - camera.x;
                const dy = deco.y - camera.y;
                
                ctx.save();
                ctx.translate(dx, dy);
                ctx.rotate(deco.rotation);
                
                if (deco.type === 'rock') {
                    // Kaya
                    ctx.fillStyle = '#5a5a5a';
                    ctx.strokeStyle = '#3a3a3a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const radius = deco.size * (0.8 + Math.random() * 0.4);
                        ctx.lineTo(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius
                        );
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Detay
                    ctx.fillStyle = '#6a6a6a';
                    ctx.beginPath();
                    ctx.arc(-deco.size * 0.2, -deco.size * 0.2, deco.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (deco.type === 'tnt') {
                    // TNT Varili
                    const pulse = Math.sin(Date.now() / 300) * 0.1 + 1;
                    
                    // Varil g√∂vdesi
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-deco.size * 0.4, -deco.size * 0.5, deco.size * 0.8, deco.size);
                    
                    // Metal halkalar
                    ctx.strokeStyle = '#696969';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-deco.size * 0.4, -deco.size * 0.2);
                    ctx.lineTo(deco.size * 0.4, -deco.size * 0.2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(-deco.size * 0.4, deco.size * 0.2);
                    ctx.lineTo(deco.size * 0.4, deco.size * 0.2);
                    ctx.stroke();
                    
                    // TNT Yazƒ±sƒ±
                    ctx.fillStyle = '#FF0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('TNT', 0, 5);
                    
                    // Parlayan fitil
                    ctx.fillStyle = `rgba(255, 165, 0, ${pulse})`;
                    ctx.shadowColor = '#FFA500';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, -deco.size * 0.6, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Can barƒ±
                    if (deco.health < deco.maxHealth) {
                        const barWidth = deco.size * 0.8;
                        const barHeight = 6;
                        const healthPercent = deco.health / deco.maxHealth;
                        
                        // Arka plan
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(-barWidth / 2, -deco.size * 0.7, barWidth, barHeight);
                        
                        // Can
                        ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
                        ctx.fillRect(-barWidth / 2, -deco.size * 0.7, barWidth * healthPercent, barHeight);
                        
                        // √áer√ßeve
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(-barWidth / 2, -deco.size * 0.7, barWidth, barHeight);
                    }
                } else if (deco.type === 'ruins') {
                    // Harabe s√ºtunlar
                    ctx.fillStyle = '#8B8B8B';
                    ctx.strokeStyle = '#5a5a5a';
                    ctx.lineWidth = 2;
                    
                    // Sol s√ºtun
                    ctx.fillRect(-deco.size * 0.4, -deco.size * 0.3, deco.size * 0.3, deco.size);
                    ctx.strokeRect(-deco.size * 0.4, -deco.size * 0.3, deco.size * 0.3, deco.size);
                    
                    // Saƒü s√ºtun (kƒ±rƒ±k)
                    ctx.fillRect(deco.size * 0.1, 0, deco.size * 0.3, deco.size * 0.6);
                    ctx.strokeRect(deco.size * 0.1, 0, deco.size * 0.3, deco.size * 0.6);
                    
                    // √úst par√ßa
                    ctx.fillRect(-deco.size * 0.5, -deco.size * 0.4, deco.size, deco.size * 0.15);
                    ctx.strokeRect(-deco.size * 0.5, -deco.size * 0.4, deco.size, deco.size * 0.15);
                } else if (deco.type === 'crystal') {
                    // Kristal
                    const colors = ['#00ffff', '#ff00ff', '#00ff00'];
                    const pulse = Math.sin(Date.now() / 500 + deco.x) * 0.3 + 0.7;
                    
                    ctx.fillStyle = colors[deco.variant];
                    ctx.shadowColor = colors[deco.variant];
                    ctx.shadowBlur = 15 * pulse;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -deco.size);
                    ctx.lineTo(deco.size * 0.4, 0);
                    ctx.lineTo(0, deco.size * 0.3);
                    ctx.lineTo(-deco.size * 0.4, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                } else if (deco.type === 'energyShield') {
                    // Enerji Kalkanƒ±
                    const pulse = Math.sin(Date.now() / 400 + deco.x) * 0.2 + 0.8;
                    
                    ctx.strokeStyle = `rgba(0, 200, 255, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#00c8ff';
                    ctx.shadowBlur = 20;
                    
                    // Altƒ±gen kalkan
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * deco.size;
                        const y = Math.sin(angle) * deco.size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    // ƒ∞√ß √ßizgiler
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * deco.size, Math.sin(angle) * deco.size);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            });
        }
        
        // Muzzle flash olu≈ütur
        function createMuzzleFlash(x, y, angle, color, size = 15) {
            muzzleFlashes.push({
                x, y,
                angle,
                color,
                size,
                life: 8,
                maxLife: 8
            });
        }
        
        // Oyun sonu g√∂ster
        function showGameOver(reason) {
            // GUARD: Prevent multiple calls
            if (gameState === 'gameover') {
                console.log('Game over already triggered, ignoring duplicate call');
                return;
            }
            
            gameState = 'gameover';
            console.log('=== GAME OVER TRIGGERED ===');
            
            document.getElementById('gameOverReason').textContent = reason;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalKills').textContent = kills;
            document.getElementById('finalWave').textContent = wave;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('finalBuildings').textContent = totalBuildingsBuilt;
            document.getElementById('finalWeapon').textContent = player.weapon ? getWeaponName(player.weapon) : 'Yok';
            
            // PERSISTENT STATS UPDATE
            // Games played - ONLY increment once per game
            const gamesPlayed = parseInt(localStorage.getItem('plasmaGamesPlayed') || 0) + 1;
            localStorage.setItem('plasmaGamesPlayed', gamesPlayed);
            
            // Total kills - PERSISTENT (separate from weekly challenges)
            const totalKills = parseInt(localStorage.getItem('plasmaTotalKills') || 0) + kills;
            localStorage.setItem('plasmaTotalKills', totalKills);
            console.log(`Total kills updated: ${totalKills} (this session: ${kills})`);
            
            // Highest wave
            const highestWave = parseInt(localStorage.getItem('plasmaHighestWave') || 0);
            if (wave > highestWave) {
                localStorage.setItem('plasmaHighestWave', wave);
            }
            
            // Special currency - earn based on wave reached (1 per wave)
            const currentEssence = parseInt(localStorage.getItem('plasmaSpecialCurrency') || 0);
            const essenceEarned = wave; // 1 essence per wave
            localStorage.setItem('plasmaSpecialCurrency', currentEssence + essenceEarned);
            
            console.log(`Game Over - Games: ${gamesPlayed}, Wave: ${wave}, Essence earned: ${essenceEarned}, Total kills: ${totalKills}`);
            
            // WEEKLY CHALLENGES UPDATE (these handle their own progress)
            updateChallengeProgress('wave', wave);
            updateChallengeProgress('score', score);
            updateChallengeProgress('gold', gold);
            
            // Final playtime update
            updatePlaytime();
            
            // Battle Pass XP
            const bpXP = (wave * 100) + (kills * 5);
            addBattlePassXP(bpXP);
            console.log(`Battle Pass XP earned: ${bpXP} (Wave: ${wave * 100}, Kills: ${kills * 5})`);
            
            // Update main menu stats
            updateMainMenuStats();
            
            // PLAYER PROFILE G√úNCELLE
            const oldHighScore = playerProfile.highScore;
            updatePlayerProfile();
            const newRecord = score > oldHighScore;
            
            document.getElementById('highScoreDisplay').textContent = playerProfile.highScore;
            
            // YENƒ∞ REKOR ANƒ∞MASYONU!
            if (newRecord && score > 0) {
                setTimeout(() => {
                    // Ekranƒ± titret
                    screenShake = 30;
                    
                    // Dev "NEW RECORD" mesajƒ±
                    const recordDiv = document.createElement('div');
                    recordDiv.style.position = 'fixed';
                    recordDiv.style.top = '50%';
                    recordDiv.style.left = '50%';
                    recordDiv.style.transform = 'translate(-50%, -50%)';
                    recordDiv.style.fontSize = '80px';
                    recordDiv.style.fontWeight = 'bold';
                    recordDiv.style.color = '#ffd700';
                    recordDiv.style.textShadow = '0 0 50px rgba(255, 215, 0, 1), 0 0 100px rgba(255, 215, 0, 0.8)';
                    recordDiv.style.zIndex = '10000';
                    recordDiv.style.animation = 'recordPulse 2s infinite';
                    recordDiv.style.pointerEvents = 'none';
                    recordDiv.innerHTML = 'üéâ NEW RECORD! üéâ<br><span style="font-size: 50px; color: #fff;">' + score + ' POINTS</span>';
                    
                    document.body.appendChild(recordDiv);
                    
                    // Konfeti efekti
                    for (let i = 0; i < 100; i++) {
                        setTimeout(() => {
                            const confetti = document.createElement('div');
                            confetti.style.position = 'fixed';
                            confetti.style.left = Math.random() * 100 + '%';
                            confetti.style.top = '-20px';
                            confetti.style.width = '10px';
                            confetti.style.height = '10px';
                            confetti.style.backgroundColor = ['#ffd700', '#ff4444', '#00ff88', '#3b82f6', '#a855f7'][Math.floor(Math.random() * 5)];
                            confetti.style.transform = 'rotate(' + Math.random() * 360 + 'deg)';
                            confetti.style.animation = 'confettiFall ' + (2 + Math.random() * 2) + 's linear';
                            confetti.style.zIndex = '9999';
                            confetti.style.pointerEvents = 'none';
                            document.body.appendChild(confetti);
                            
                            setTimeout(() => confetti.remove(), 4000);
                        }, i * 30);
                    }
                    
                    // Mesajƒ± 5 saniye sonra kaldƒ±r
                    setTimeout(() => {
                        recordDiv.remove();
                    }, 5000);
                }, 500);
            }
            
            document.getElementById('gameOver').classList.add('active');
            
            // Show continue button if not used
            const continueBtn = document.getElementById('continueAdButton');
            if (!continueUsed && continueBtn) {
                continueBtn.style.display = 'block';
            }
            
            // LEADERBOARD'A EKLE
            setTimeout(() => {
                const rank = addToLeaderboard(playerProfile.name, score, wave, kills);
                
                if (!newRecord && rank <= 10) {
                    showNotification(`üìä Rank #${rank} in your top 10!`, 3000);
                }
            }, newRecord ? 2000 : 1000);
        }
        
        // Wave d√º≈üman kompozisyonu
        function getWaveComposition(wave) {
            const compositions = {
                1: { scout: 5 },
                2: { scout: 7, combat: 2 },
                3: { scout: 5, combat: 5 },
                4: { scout: 3, combat: 5, heavy: 2 },
                5: { combat: 5, heavy: 3, teleporter: 2 },
                6: { combat: 4, heavy: 4, teleporter: 3, runner: 2 },
                7: { heavy: 5, elite: 2, teleporter: 3, runner: 3 },
                8: { combat: 3, heavy: 5, elite: 3, teleporter: 4, runner: 3 },
                9: { heavy: 4, elite: 4, summoner: 2, teleporter: 4, runner: 4 },
                10: { heavy: 5, elite: 5, summoner: 3, tank: 2, teleporter: 5, runner: 5 }
            };
            
            // Wave 10'dan sonra zorluk artar (IMPROVED: Cap multiplier to prevent too many enemies)
            if (wave > 10) {
                const multiplier = Math.min(1 + (wave - 10) * 0.15, 8); // Max 8x instead of unlimited, reduced growth
                return {
                    elite: Math.min(Math.floor(5 * multiplier), 30), // Cap at 30 per type
                    tank: Math.min(Math.floor(3 * multiplier), 20),
                    summoner: Math.min(Math.floor(3 * multiplier), 15),
                    teleporter: Math.min(Math.floor(4 * multiplier), 25),
                    runner: Math.min(Math.floor(4 * multiplier), 25),
                    heavy: Math.min(Math.floor(3 * multiplier), 20)
                };
            }
            
            return compositions[wave] || compositions[10];
        }
        
        // Yapƒ± tipleri
        const BUILDING_TYPES = {
            tower: {
                name: 'Kule',
                nameEn: 'Tower',
                size: 40,
                health: 500,
                attackRange: 300,
                attackDamage: 20,
                attackSpeed: 60,
                cost: 1
            },
            wall: {
                name: 'Duvar',
                nameEn: 'Wall',
                size: 50, // Daha b√ºy√ºk
                width: 80, // Geni≈ülik
                height: 60, // Y√ºkseklik
                health: 1500, // Daha dayanƒ±klƒ±
                cost: 1,
                blocksMovement: true // D√º≈üman ge√ßemez
            },
            farm: {
                name: '√áiftlik',
                nameEn: 'Farm',
                size: 35,
                health: 300,
                xpPerSecond: 5,
                cost: 1
            },
            barracks: {
                name: 'Kƒ±≈üla',
                nameEn: 'Barracks',
                size: 45,
                health: 800,
                spawnInterval: 600, // 10 saniye (60 fps)
                soldierHealth: 100,
                soldierDamage: 25,
                soldierSpeed: 2.5,
                cost: 1,
                requiresBaseLevel: 2 // √ús level 2'de a√ßƒ±lƒ±r
            }
        };
        
        // √ús seviyeleri
        const BASE_LEVELS = {
            1: { maxHealth: 1000, size: 80, color: '#60a5fa' },
            2: { maxHealth: 1500, size: 90, color: '#3b82f6' },
            3: { maxHealth: 2000, size: 100, color: '#2563eb' },
            4: { maxHealth: 2500, size: 110, color: '#1d4ed8' },
            5: { maxHealth: 3000, size: 120, color: '#fbbf24' } // Altƒ±n
        };
        
        // Bildirim g√∂ster
        function showNotification(text, duration = 3000) {
            // Limit notifications to prevent screen spam (max 3 active)
            if (notifications.length >= 3) {
                // Remove oldest notification
                notifications.shift();
            }
            
            notifications.push({
                text,
                life: duration / 16.67, // Frame sayƒ±sƒ±na √ßevir (60 FPS)
                maxLife: duration / 16.67
            });
        }
        
        // Yapƒ± se√ßimi
        function selectBuilding(type) {
            buildMode = type;
            document.querySelectorAll('.build-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            event.target.closest('.build-option').classList.add('selected');
            showNotification(`${BUILDING_TYPES[type].name} se√ßildi!\nHaritaya tƒ±klayarak yerle≈ütirin`, 3000);
        }
        
        // D√º≈ümanlar ve kontroller
        let enemies = [];
        let currentPriorityTarget = null; // Currently targeted high-priority enemy
        let priorityTargetIndex = 0; // For TAB cycling
        let showThreatIndicators = true; // Show threat level UI
        let particles = [];
        let ambientParticles = []; // Biome ambient particles (stars, dust, ice)
        let decorations = [];
        let projectiles = []; // D√º≈üman mermileri
        let hazards = []; // Arena tehlikeleri (spike'lar)
        let boss = null;
        const keys = {};
        
        // WEAPON TREE SPECIFIC ABILITIES
        let abilityUnlocked = false; // 4. dalgada a√ßƒ±lƒ±r
        let abilityName = ''; // Dodge Roll, Critical Shot, Sprint
        let abilityCooldown = 0; // Cooldown frames
        let abilityMaxCooldown = 180; // 3 saniye
        let abilityActive = false; // Aktif mi?
        let abilityDuration = 0; // S√ºre (sprint i√ßin)
        
        // COSMETIC SYSTEM
        let unlockedCosmetics = {
            trails: ['default'], // default her zaman var
            skins: ['default']
        };
        let equippedTrail = 'default';
        let equippedSkin = 'default';
        
        const COSMETICS = {
            trails: {
                default: { name: 'None', color: null, unlockWave: 0 },
                neon: { name: 'Neon Trail', color: '#00ffdd', unlockWave: 10, glow: true },
                fire: { name: 'Fire Trail', color: '#ff4400', unlockWave: 15, particle: 'fire' },
                ice: { name: 'Ice Trail', color: '#00ddff', unlockWave: 20, particle: 'ice' },
                rainbow: { name: 'Rainbow Trail', color: 'rainbow', unlockWave: 25, animated: true }
            },
            skins: {
                default: { name: 'Default', colors: { primary: '#4db8ff', secondary: '#0088cc', accent: '#00ffff' }, unlockWave: 0 },
                neonAssassin: { name: 'Neon Assassin', colors: { primary: '#00ffdd', secondary: '#00ccaa', accent: '#00fff2' }, unlockWave: 20 },
                cyberSamurai: { name: 'Cyber Samurai', colors: { primary: '#ff0066', secondary: '#cc0044', accent: '#ff99cc' }, unlockKills: 500 },
                plasmaGhost: { name: 'Plasma Ghost', colors: { primary: '#9933ff', secondary: '#6600cc', accent: '#cc66ff' }, unlockWave: 30 }
            }
        };
        
        // WAVE MODIFIERS SYSTEM
        let activeModifier = null;
        let modifierDuration = 0;
        
        // Modifier multipliers (global for draw function)
        let playerSpeedMod = 1;
        let enemySpeedMod = 1;
        let playerSizeMod = 1;
        let enemySizeMod = 1;
        
        const WAVE_MODIFIERS = {
            5: { 
                name: 'SPEED BOOST', 
                description: 'Everyone moves faster!',
                icon: '‚ö°',
                playerSpeedMult: 1.5,
                enemySpeedMult: 1.3,
                duration: 1800, // 30 saniye
                color: '#ffdd00'
            },
            10: { 
                name: 'GRAVITY STORM', 
                description: 'Low gravity active!',
                icon: 'üå™Ô∏è',
                gravity: 0.5,
                duration: 1800,
                color: '#00ddff'
            },
            15: { 
                name: 'TINY MODE', 
                description: 'Everyone is tiny!',
                icon: 'üî¨',
                sizeMult: 0.6,
                duration: 1800,
                color: '#ff66ff'
            },
            20: { 
                name: 'GIANT ENEMIES', 
                description: 'Boss-sized enemies!',
                icon: 'üëπ',
                enemySizeMult: 2.0,
                duration: 1800,
                color: '#ff0000'
            },
            25: { 
                name: 'BULLET TIME', 
                description: 'Slow motion combat!',
                icon: '‚è∞',
                timeMult: 0.7,
                duration: 1800,
                color: '#00ff88'
            },
            30: { 
                name: 'CHAOS MODE', 
                description: 'Random mayhem!',
                icon: 'üí•',
                random: true,
                duration: 1800,
                color: '#ff00ff'
            }
        };
        let mouse = { x: 0, y: 0, down: false };
        
        // Dekorasyon olu≈ütur
        function createDecorations() {
            decorations = [];
            // Kristaller
            for (let i = 0; i < 30; i++) {
                decorations.push({
                    type: 'crystal',
                    x: Math.random() * (ARENA_SIZE - 200) + 100,
                    y: Math.random() * (ARENA_SIZE - 200) + 100,
                    size: 15 + Math.random() * 15,
                    color: ['#a855f7', '#ec4899', '#3b82f6', '#10b981'][Math.floor(Math.random() * 4)],
                    rotation: Math.random() * Math.PI * 2,
                    health: 50,
                    maxHealth: 50,
                    destroyed: false
                });
            }
            
            // Antik s√ºtunlar
            for (let i = 0; i < 15; i++) {
                decorations.push({
                    type: 'pillar',
                    x: Math.random() * (ARENA_SIZE - 200) + 100,
                    y: Math.random() * (ARENA_SIZE - 200) + 100,
                    size: 30,
                    height: 60 + Math.random() * 40,
                    health: 100,
                    maxHealth: 100,
                    destroyed: false
                });
            }
            
            // Kayalar
            for (let i = 0; i < 20; i++) {
                decorations.push({
                    type: 'rock',
                    x: Math.random() * (ARENA_SIZE - 200) + 100,
                    y: Math.random() * (ARENA_SIZE - 200) + 100,
                    size: 20 + Math.random() * 25,
                    health: 75,
                    maxHealth: 75,
                    destroyed: false
                });
            }
        }
        
        createDecorations();
        
        // Tehlike olu≈üturma (spike'lar)
        function spawnHazards() {
            if (wave < 5) return; // 5. dalgadan sonra ba≈ülar
            
            const hazardCount = Math.min(wave - 4, 10);
            for (let i = 0; i < hazardCount; i++) {
                const x = Math.random() * (ARENA_SIZE - 400) + 200;
                const y = Math.random() * (ARENA_SIZE - 400) + 200;
                
                // Oyuncudan uzakta spawn et
                const dx = x - player.x;
                const dy = y - player.y;
                if (Math.sqrt(dx*dx + dy*dy) < 300) continue;
                
                hazards.push({
                    x, y,
                    size: 20,
                    damage: 10,
                    active: false,
                    timer: Math.random() * 60 + 60, // 1-2 saniye bekleme
                    warningTimer: 30
                });
            }
        }
        
        // Boss spawn
        function spawnBoss() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: x = player.x + 1000; y = player.y; break;
                case 1: x = player.x - 1000; y = player.y; break;
                case 2: x = player.x; y = player.y + 1000; break;
                case 3: x = player.x; y = player.y - 1000; break;
            }
            
            boss = {
                x, y,
                size: 60,
                health: 500 + wave * 100,
                maxHealth: 500 + wave * 100,
                speed: 1,
                damage: 30,
                color: '#dc2626',
                attackCooldown: 0,
                phase: 1
            };
        }
        
        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // TAB: Cycle priority targets
            if (e.key === 'Tab') {
                e.preventDefault(); // Prevent browser tab switching
                if (gameState === 'playing') {
                    cyclePriorityTarget();
                }
                return;
            }
            
            // T: Toggle threat indicators
            if (e.key.toLowerCase() === 't') {
                if (gameState === 'playing') {
                    showThreatIndicators = !showThreatIndicators;
                    showNotification(`Threat Indicators: ${showThreatIndicators ? 'ON' : 'OFF'}`, 1500);
                }
                return;
            }
            
            // P: Pause/Resume
            if (e.key.toLowerCase() === 'p') {
                if (gameState === 'playing') {
                    gameState = 'paused';
                    showNotification('‚è∏Ô∏è PAUSED\nPress P to resume', 0); // 0 = stays until dismissed
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                    // Clear pause notification (it will auto-clear when game resumes)
                }
                return;
            }
            
            // Ability kullanƒ±mƒ± (SADECE unlock edildiyse)
            if (!abilityUnlocked || abilityCooldown > 0) {
                // Ability kullanƒ±lamaz ama tu≈ülar √ßalƒ±≈ümalƒ±
                return; // Ability kodunu atla ama keys zaten ayarlandƒ±
            }
            
            const treeData = WEAPON_TREES[selectedWeaponTree];
            if (!treeData) return; // Safety check
            
            // MELEE: Dodge Roll (√áift Space)
            if (treeData.ability === 'dodge_roll' && e.key === ' ') {
                const now = Date.now();
                if (now - (window.lastSpacePress || 0) < 300) {
                    // Dodge roll ba≈ülat
                    abilityActive = true;
                    abilityCooldown = abilityMaxCooldown;
                    
                    // Hareket y√∂n√ºn√º belirle
                    let dx = 0, dy = 0;
                    if (keys['w']) dy -= 1;
                    if (keys['s']) dy += 1;
                    if (keys['a']) dx -= 1;
                    if (keys['d']) dx += 1;
                    
                    // Hareket yoksa fare y√∂n√ºnde
                    if (dx === 0 && dy === 0) {
                        dx = Math.cos(player.attackAngle);
                        dy = Math.sin(player.attackAngle);
                    }
                    
                    // Normalize ve hƒ±z
                    const mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag > 0) {
                        window.dodgeDirection = {
                            x: (dx / mag) * 15,
                            y: (dy / mag) * 15
                        };
                    }
                    
                    // 20 frame s√ºre
                    setTimeout(() => {
                        abilityActive = false;
                        window.dodgeDirection = null;
                    }, 330);
                }
                window.lastSpacePress = now;
            }
            
            // HYBRID: Sprint (Shift)
            if (treeData.ability === 'sprint' && e.key === 'Shift') {
                abilityActive = true;
                abilityCooldown = abilityMaxCooldown;
                abilityDuration = treeData.abilityDuration;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            // Sprint bitir (Shift bƒ±rakƒ±nca)
            if (e.key === 'Shift' && WEAPON_TREES[selectedWeaponTree]?.ability === 'sprint') {
                abilityActive = false;
                abilityDuration = 0;
            }
        });
        
        // Resize handler
        window.addEventListener('resize', () => {
            if (platform) {
                resizeCanvas();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left + camera.x;
            mouse.y = e.clientY - rect.top + camera.y;
            
            // Oyuncu y√∂n√º - SADECE desktop'ta VE WASD kullanƒ±lmƒ±yorsa
            // WASD ile hareket ediyorsa, hareket y√∂n√º √∂nceliklidir
        });
        
        canvas.addEventListener('mousedown', () => mouse.down = true);
        canvas.addEventListener('mouseup', () => mouse.down = false);
        
        // √ús yerle≈ütirme veya yapƒ± in≈üasƒ± (Click ve Touch)
        function handlePlacement(clientX, clientY) {
            console.log('handlePlacement called, gameState:', gameState);
            
            // Selection ekranlarƒ±nda tƒ±klamalarƒ± yoksay
            if (gameState === 'selection') {
                console.log('Ignoring click - still in selection');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            console.log('Placement attempt, rect:', rect);
            
            // ƒ∞lk tƒ±klamada kamera merkezdedir
            if (gameState === 'placement') {
                console.log('Placing base...');
                // Kamera oyuncuya kilitli deƒüil, merkezdedir
                const clickX = clientX - rect.left + (ARENA_SIZE / 2 - canvas.width / 2);
                const clickY = clientY - rect.top + (ARENA_SIZE / 2 - canvas.height / 2);
                
                // √úss√º yerle≈ütir
                base = {
                    x: clickX,
                    y: clickY,
                    level: 1,
                    size: BASE_LEVELS[1].size,
                    health: BASE_LEVELS[1].maxHealth,
                    maxHealth: BASE_LEVELS[1].maxHealth,
                    color: BASE_LEVELS[1].color,
                    attackCooldown: 0,
                    attackRange: 0,
                    regenTimer: 0
                };
                
                // Oyuncuyu √ºss√ºn yanƒ±na koy
                player.x = clickX + 150;
                player.y = clickY;
                
                // Oyunu ba≈ülat
                gameState = 'playing';
                document.getElementById('basePlacement').classList.add('hidden');
                document.getElementById('baseCustomButton').classList.add('visible');
                
                // Initialize playtime tracking
                initializePlaytime();
                achievementTracking.gameStartTime = Date.now();
                
                // Base'e skin uygula
                if (baseCustomization.skin !== 'default') {
                    base.color = BASE_SKINS[baseCustomization.skin].color;
                }
                
                // Harita dekorasyonlarƒ±nƒ± olu≈ütur
                generateMapDecorations();
                
                showNotification('üè∞ BASE ESTABLISHED!\n‚öîÔ∏è Prepare Your Defenses!', 4000);
            } else if (buildMode && buildingPoints > 0) {
                // Yapƒ± in≈üa et - oyun ba≈üladƒ±ktan sonra, kamera oyuncuya kilitli
                const clickX = clientX - rect.left + camera.x;
                const clickY = clientY - rect.top + camera.y;
                
                const buildingType = BUILDING_TYPES[buildMode];
                
                buildings.push({
                    type: buildMode,
                    x: clickX,
                    y: clickY,
                    size: buildingType.size,
                    health: buildingType.health,
                    maxHealth: buildingType.health,
                    level: base ? base.level : 1,
                    attackCooldown: 0,
                    xpTimer: 0,
                    // Synergy bonuses
                    attackSpeedBonus: 0,
                    damageBonus: 0,
                    xpBonus: 0,
                    synergizedWith: []
                });
                
                buildingPoints--;
                totalBuildingsBuilt++;
                
                // Weekly challenge tracking
                updateChallengeProgress('buildings', 1);
                
                // Check synergies after building
                checkBuildingSynergies();
                
                // Men√ºy√º kapat
                if (buildingPoints === 0) {
                    document.getElementById('buildMenu').classList.remove('active');
                    buildMode = null;
                }
                
                showNotification(`${buildingType.name} in≈üa edildi!`, 2000);
            }
        }
        
        // Click event
        canvas.addEventListener('click', (e) => {
            handlePlacement(e.clientX, e.clientY);
        });
        
        // Touch event (mobile i√ßin)
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'placement' || buildMode) {
                e.preventDefault();
                const touch = e.touches[0];
                handlePlacement(touch.clientX, touch.clientY);
            }
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TOWER SYNERGY SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const SYNERGY_RANGE = 150; // Pixels
        
        function checkBuildingSynergies() {
            // Reset all synergies
            buildings.forEach(b => {
                b.attackSpeedBonus = 0;
                b.damageBonus = 0;
                b.xpBonus = 0;
                b.synergizedWith = [];
            });
            buildingSynergies = [];
            
            // Check each building against others
            buildings.forEach((building, i) => {
                buildings.forEach((other, j) => {
                    if (i >= j) return; // Skip self and duplicates
                    
                    const dist = Math.hypot(building.x - other.x, building.y - other.y);
                    
                    if (dist < SYNERGY_RANGE) {
                        // Found synergy!
                        applySynergy(building, other);
                        
                        // Track connection for visual
                        buildingSynergies.push({
                            from: building,
                            to: other,
                            type: getSynergyType(building.type, other.type)
                        });
                    }
                });
            });
            
            console.log(`Building synergies: ${buildingSynergies.length} active connections`);
        }
        
        function applySynergy(building1, building2) {
            const type1 = building1.type;
            const type2 = building2.type;
            
            // Tower + Tower = Attack Speed
            if (type1 === 'tower' && type2 === 'tower') {
                building1.attackSpeedBonus += 0.25; // +25%
                building2.attackSpeedBonus += 0.25;
                building1.synergizedWith.push(building2);
                building2.synergizedWith.push(building1);
            }
            
            // Tower + Wall = Damage Boost
            else if ((type1 === 'tower' && type2 === 'wall') || (type1 === 'wall' && type2 === 'tower')) {
                const tower = type1 === 'tower' ? building1 : building2;
                tower.damageBonus += 0.5; // +50%
                tower.synergizedWith.push(type1 === 'tower' ? building2 : building1);
            }
            
            // Farm + Farm = XP Boost
            else if (type1 === 'farm' && type2 === 'farm') {
                building1.xpBonus += 0.5; // +50%
                building2.xpBonus += 0.5;
                building1.synergizedWith.push(building2);
                building2.synergizedWith.push(building1);
            }
            
            // Barracks + Tower = Damage Aura (stored for later use)
            else if ((type1 === 'barracks' && type2 === 'tower') || (type1 === 'tower' && type2 === 'barracks')) {
                const tower = type1 === 'tower' ? building1 : building2;
                tower.damageBonus += 0.3; // +30%
                tower.synergizedWith.push(type1 === 'tower' ? building2 : building1);
            }
            
            // Wall + Wall = Fortification (future: could add shield dome)
            else if (type1 === 'wall' && type2 === 'wall') {
                building1.health = Math.min(building1.health + 50, building1.maxHealth);
                building2.health = Math.min(building2.health + 50, building2.maxHealth);
                building1.synergizedWith.push(building2);
                building2.synergizedWith.push(building1);
            }
        }
        
        function getSynergyType(type1, type2) {
            if (type1 === 'tower' && type2 === 'tower') return 'attack_speed';
            if ((type1 === 'tower' && type2 === 'wall') || (type1 === 'wall' && type2 === 'tower')) return 'damage';
            if (type1 === 'farm' && type2 === 'farm') return 'xp';
            if ((type1 === 'barracks' && type2 === 'tower') || (type1 === 'tower' && type2 === 'barracks')) return 'aura';
            if (type1 === 'wall' && type2 === 'wall') return 'fortify';
            return 'generic';
        }
        
        function drawBuildingSynergies() {
            // Draw connection lines between synergized buildings
            buildingSynergies.forEach(synergy => {
                const fx = synergy.from.x - camera.x;
                const fy = synergy.from.y - camera.y;
                const tx = synergy.to.x - camera.x;
                const ty = synergy.to.y - camera.y;
                
                // Animated pulse
                const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
                
                // Color based on synergy type
                let color;
                switch(synergy.type) {
                    case 'attack_speed': color = '#ff6600'; break;
                    case 'damage': color = '#ff0000'; break;
                    case 'xp': color = '#00ff00'; break;
                    case 'aura': color = '#ff00ff'; break;
                    case 'fortify': color = '#0088ff'; break;
                    default: color = '#ffff00';
                }
                
                ctx.save();
                ctx.globalAlpha = 0.4 * pulse;
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(tx, ty);
                ctx.stroke();
                
                // Draw midpoint particle
                const midX = (fx + tx) / 2;
                const midY = (fy + ty) / 2;
                ctx.fillStyle = color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(midX, midY, 5 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MUTATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function calculateMutations() {
            // Progressive scaling every 10 waves
            const tier = mutationLevel;
            
            // HP scaling (exponential)
            enemyHPMultiplier = 1 + (tier * 0.25); // +25% per tier
            // Wave 10: 1.25x, Wave 20: 1.5x, Wave 30: 1.75x, Wave 40: 2x, Wave 50: 2.25x
            
            // Speed scaling (moderate)
            enemySpeedMultiplier = 1 + (tier * 0.10); // +10% per tier
            // Wave 10: 1.1x, Wave 20: 1.2x, Wave 30: 1.3x, Wave 40: 1.4x, Wave 50: 1.5x
            
            // Damage scaling (slower)
            enemyDamageMultiplier = 1 + (tier * 0.15); // +15% per tier
            // Wave 10: 1.15x, Wave 20: 1.3x, Wave 30: 1.45x, Wave 40: 1.6x, Wave 50: 1.75x
            
            console.log(`=== MUTATION LEVEL ${tier} ===`);
            console.log(`HP: ${enemyHPMultiplier.toFixed(2)}x`);
            console.log(`Speed: ${enemySpeedMultiplier.toFixed(2)}x`);
            console.log(`Damage: ${enemyDamageMultiplier.toFixed(2)}x`);
            console.log('==========================');
        }
        
        function applyMutations(enemy) {
            // Apply mutation multipliers to enemy
            enemy.health *= enemyHPMultiplier;
            enemy.maxHealth *= enemyHPMultiplier;
            enemy.speed *= enemySpeedMultiplier;
            enemy.damage *= enemyDamageMultiplier;
            
            // Visual mutation based on level
            if (mutationLevel > 0) {
                enemy.mutated = true;
                enemy.mutationLevel = mutationLevel;
                
                // Size increase
                enemy.size *= (1 + mutationLevel * 0.05); // +5% size per tier
                
                // Color shift (more purple/red)
                const originalColor = enemy.color;
                const r = parseInt(originalColor.slice(1, 3), 16);
                const g = parseInt(originalColor.slice(3, 5), 16);
                const b = parseInt(originalColor.slice(5, 7), 16);
                
                // Add purple tint
                const newR = Math.min(255, r + mutationLevel * 10);
                const newG = Math.max(0, g - mutationLevel * 5);
                const newB = Math.min(255, b + mutationLevel * 15);
                
                enemy.color = `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            const spawnDistance = 800;
            
            switch(side) {
                case 0: x = player.x + spawnDistance; y = player.y + (Math.random() - 0.5) * 1000; break;
                case 1: x = player.x - spawnDistance; y = player.y + (Math.random() - 0.5) * 1000; break;
                case 2: x = player.x + (Math.random() - 0.5) * 1000; y = player.y + spawnDistance; break;
                case 3: x = player.x + (Math.random() - 0.5) * 1000; y = player.y - spawnDistance; break;
            }
            
            x = Math.max(50, Math.min(ARENA_SIZE - 50, x));
            y = Math.max(50, Math.min(ARENA_SIZE - 50, y));
            
            let type;
            if (wave <= 2) type = ENEMY_TYPES.scout;
            else if (wave <= 4) type = Math.random() < 0.7 ? ENEMY_TYPES.scout : ENEMY_TYPES.combat;
            else if (wave <= 6) type = Math.random() < 0.4 ? ENEMY_TYPES.scout : (Math.random() < 0.7 ? ENEMY_TYPES.combat : ENEMY_TYPES.heavy);
            else if (wave <= 9) {
                const rand = Math.random();
                if (rand < 0.25) type = ENEMY_TYPES.scout;
                else if (rand < 0.5) type = ENEMY_TYPES.combat;
                else if (rand < 0.7) type = ENEMY_TYPES.heavy;
                else if (rand < 0.85) type = ENEMY_TYPES.teleporter;
                else type = ENEMY_TYPES.runner;
            } else if (wave <= 15) {
                const rand = Math.random();
                if (rand < 0.15) type = ENEMY_TYPES.combat;
                else if (rand < 0.3) type = ENEMY_TYPES.heavy;
                else if (rand < 0.5) type = ENEMY_TYPES.elite;
                else if (rand < 0.65) type = ENEMY_TYPES.teleporter;
                else if (rand < 0.8) type = ENEMY_TYPES.runner;
                else if (rand < 0.9) type = ENEMY_TYPES.summoner;
                else type = ENEMY_TYPES.tank;
            } else if (wave <= 20) {
                const rand = Math.random();
                if (rand < 0.2) type = ENEMY_TYPES.elite;
                else if (rand < 0.35) type = ENEMY_TYPES.teleporter;
                else if (rand < 0.5) type = ENEMY_TYPES.tank;
                else if (rand < 0.65) type = ENEMY_TYPES.summoner;
                else if (rand < 0.8) type = ENEMY_TYPES.runner;
                else type = ENEMY_TYPES.heavy;
            } else {
                // Wave 21+ - SPECIAL ENEMIES APPEAR!
                const rand = Math.random();
                if (rand < 0.1) type = ENEMY_TYPES.healer; // 10% - CRITICAL THREAT
                else if (rand < 0.2) type = ENEMY_TYPES.buffer; // 10% - CRITICAL THREAT
                else if (rand < 0.35) type = ENEMY_TYPES.summoner; // 15%
                else if (rand < 0.5) type = ENEMY_TYPES.elite; // 15%
                else if (rand < 0.65) type = ENEMY_TYPES.tank; // 15%
                else if (rand < 0.8) type = ENEMY_TYPES.teleporter; // 15%
                else type = ENEMY_TYPES.runner; // 20%
            }
            
            const newEnemy = {
                x, y,
                ...JSON.parse(JSON.stringify(type)),
                maxHealth: type.health,
                stunned: 0,
                abilityCooldown: 0,
                dashCooldown: 0,
                sprintActive: 0,
                shieldActive: 0
            };
            
            // Apply mutations
            applyMutations(newEnemy);
            
            enemies.push(newEnemy);
        }
        
        // Belirli tip d√º≈üman spawn et
        function spawnEnemyOfType(type) {
            if (!base) return;
            
            const spawnDistance = 800;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
                case 0: x = player.x + (Math.random() - 0.5) * 1000; y = player.y - spawnDistance; break;
                case 1: x = player.x + (Math.random() - 0.5) * 1000; y = player.y + spawnDistance; break;
                case 2: x = player.x + spawnDistance; y = player.y + (Math.random() - 0.5) * 1000; break;
                case 3: x = player.x - spawnDistance; y = player.y + (Math.random() - 0.5) * 1000; break;
            }
            
            x = Math.max(50, Math.min(ARENA_SIZE - 50, x));
            y = Math.max(50, Math.min(ARENA_SIZE - 50, y));
            
            const newEnemy = {
                x, y,
                ...JSON.parse(JSON.stringify(type)),
                maxHealth: type.health,
                stunned: 0,
                abilityCooldown: 0,
                dashCooldown: 0,
                sprintActive: 0,
                shieldActive: 0
            };
            
            // Apply mutations FIRST
            applyMutations(newEnemy);
            
            // EVENT: Blood Moon - d√º≈ümanlar g√º√ßlenir (AFTER mutations)
            if (currentEvent && currentEvent.type === 'bloodMoon') {
                newEnemy.health *= currentEvent.enemyMultiplier;
                newEnemy.maxHealth *= currentEvent.enemyMultiplier;
                newEnemy.damage *= currentEvent.enemyMultiplier;
                newEnemy.xpValue *= currentEvent.xpMultiplier;
                newEnemy.color = '#8b0000'; // Kanlƒ± kƒ±rmƒ±zƒ±
            }
            
            enemies.push(newEnemy);
            
            waveEnemiesRemaining--;
        }
        
        // Par√ßacƒ±k efekti
        function createParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ACHIEVEMENT UNLOCK NOTIFICATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function unlockAchievement(achievementKey) {
            if (achievements[achievementKey].unlocked) return; // Already unlocked
            
            achievements[achievementKey].unlocked = true;
            const achievement = achievements[achievementKey];
            
            // Create achievement notification (bottom center)
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                bottom: -200px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 10000;
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
                padding: 25px 40px;
                border-radius: 15px;
                border: 3px solid #ffd700;
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.6), inset 0 0 20px rgba(255, 215, 0, 0.1);
                text-align: center;
                pointer-events: none;
                animation: achievementSlideUp 0.6s ease-out forwards;
            `;
            
            notif.innerHTML = `
                <div style="font-size: 14px; color: #ffd700; font-weight: bold; margin-bottom: 8px; letter-spacing: 2px;">üèÜ ACHIEVEMENT UNLOCKED üèÜ</div>
                <div style="font-size: 48px; margin: 10px 0; animation: achievementIconBounce 0.8s ease-out;">${achievement.icon}</div>
                <div style="font-size: 24px; font-weight: bold; color: #ffffff; margin-bottom: 5px;">${achievement.name}</div>
                <div style="font-size: 16px; color: #aaaaaa;">${achievement.desc}</div>
            `;
            
            document.body.appendChild(notif);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                notif.style.animation = 'achievementSlideDown 0.6s ease-in forwards';
                setTimeout(() => notif.remove(), 600);
            }, 5000);
            
            // Sound effect (visual shake)
            screenShake = 15;
            createLevelUpEffect(player.x, player.y);
        }
        
        // Add CSS animations for achievements
        const achievementStyle = document.createElement('style');
        achievementStyle.textContent = `
            @keyframes achievementSlideUp {
                0% {
                    bottom: -200px;
                    opacity: 0;
                }
                100% {
                    bottom: 50px;
                    opacity: 1;
                }
            }
            
            @keyframes achievementSlideDown {
                0% {
                    bottom: 50px;
                    opacity: 1;
                }
                100% {
                    bottom: -200px;
                    opacity: 0;
                }
            }
            
            @keyframes achievementIconBounce {
                0%, 100% {
                    transform: scale(1);
                }
                25% {
                    transform: scale(1.3);
                }
                50% {
                    transform: scale(0.9);
                }
                75% {
                    transform: scale(1.15);
                }
            }
        `;
        document.head.appendChild(achievementStyle);
        
        // Check achievements function
        function checkAchievements() {
            // First Blood
            if (achievementTracking.totalKills >= 1) {
                unlockAchievement('firstBlood');
            }
            
            // Centurion
            if (achievementTracking.totalKills >= 100) {
                unlockAchievement('centurion');
            }
            
            // Destroyer
            if (achievementTracking.totalKills >= 500) {
                unlockAchievement('destroyer');
            }
            
            // Collector
            if (achievementTracking.totalGold >= 10000) {
                unlockAchievement('collector');
            }
            
            // Architect
            if (achievementTracking.totalBuildings >= 10) {
                unlockAchievement('architect');
            }
            
            // Jedi Master
            if (achievementTracking.totalSoldiers >= 20) {
                unlockAchievement('jediMaster');
            }
            
            // Speed Runner (wave 10 in 5 minutes)
            if (wave >= 10 && !achievements.speedRunner.unlocked) {
                const elapsed = (Date.now() - achievementTracking.gameStartTime) / 1000;
                if (elapsed <= 300) { // 5 minutes
                    unlockAchievement('speedRunner');
                }
            }
            
            // Untouchable (5 waves without damage)
            if (achievementTracking.wavesWithoutDamage >= 5) {
                unlockAchievement('untouchable');
            }
            
            // Survivor
            if (wave >= 20) {
                unlockAchievement('survivor');
            }
            
            // Legendary
            if (wave >= 30) {
                unlockAchievement('legendary');
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DRAMATIC CENTER ANNOUNCEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function showDramaticAnnouncement(title, description, icon, color, duration = 3000) {
            // Create announcement element
            const announcement = document.createElement('div');
            announcement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0);
                z-index: 10000;
                background: rgba(0, 0, 0, 0.95);
                padding: 60px 80px;
                border-radius: 20px;
                border: 4px solid ${color};
                box-shadow: 0 0 50px ${color}, inset 0 0 30px rgba(0, 0, 0, 0.5);
                text-align: center;
                pointer-events: none;
                animation: dramaticEnter 0.5s ease-out forwards;
            `;
            
            announcement.innerHTML = `
                <div style="font-size: 120px; margin-bottom: 20px; animation: iconPulse 1s infinite;">${icon}</div>
                <div style="font-size: 64px; font-weight: 900; color: ${color}; text-shadow: 0 0 20px ${color}; margin-bottom: 15px; letter-spacing: 8px;">${title}</div>
                <div style="font-size: 28px; color: #ffffff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);">${description}</div>
            `;
            
            document.body.appendChild(announcement);
            
            // Auto remove
            setTimeout(() => {
                announcement.style.animation = 'dramaticExit 0.5s ease-in forwards';
                setTimeout(() => announcement.remove(), 500);
            }, duration);
        }
        
        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes dramaticEnter {
                0% {
                    transform: translate(-50%, -50%) scale(0) rotate(-10deg);
                    opacity: 0;
                }
                60% {
                    transform: translate(-50%, -50%) scale(1.1) rotate(2deg);
                }
                100% {
                    transform: translate(-50%, -50%) scale(1) rotate(0deg);
                    opacity: 1;
                }
            }
            
            @keyframes dramaticExit {
                0% {
                    transform: translate(-50%, -50%) scale(1);
                    opacity: 1;
                }
                100% {
                    transform: translate(-50%, -50%) scale(0.8);
                    opacity: 0;
                }
            }
            
            @keyframes iconPulse {
                0%, 100% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.15);
                }
            }
        `;
        document.head.appendChild(style);
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AMBIENT BIOME PARTICLES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function spawnAmbientParticles() {
            // Spawn rate (her 10 frame'de bir)
            if (Math.random() > 0.1) return;
            
            const biome = BIOMES[currentBiome];
            if (!biome) return; // Safety check
            
            if (currentBiome === 'proxima') {
                // Yƒ±ldƒ±zlar (stars)
                ambientParticles.push({
                    x: Math.random() * ARENA_SIZE,
                    y: Math.random() * ARENA_SIZE,
                    vx: 0,
                    vy: 0,
                    life: 120 + Math.random() * 120,
                    maxLife: 240,
                    color: '#ffffff',
                    size: Math.random() * 2 + 1,
                    twinkle: true
                });
            } else if (currentBiome === 'kepler') {
                // Toz par√ßacƒ±klarƒ± (dust)
                ambientParticles.push({
                    x: player.x + (Math.random() - 0.5) * 1000,
                    y: player.y + (Math.random() - 0.5) * 1000,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: 180,
                    color: 'rgba(249, 115, 22, 0.4)',
                    size: Math.random() * 3 + 1
                });
            } else if (currentBiome === 'titan') {
                // Buz kristalleri (ice crystals)
                ambientParticles.push({
                    x: player.x + (Math.random() - 0.5) * 1000,
                    y: -camera.y - 50,
                    vx: (Math.random() - 0.5) * 1,
                    vy: 1 + Math.random() * 2,
                    life: 200,
                    color: 'rgba(56, 189, 248, 0.6)',
                    size: Math.random() * 4 + 2,
                    rotate: Math.random() * Math.PI * 2,
                    rotateSpeed: (Math.random() - 0.5) * 0.1
                });
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DAMAGE SYSTEM (Critical Hits & Damage Numbers)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let comboCount = 0;
        let comboTimer = 0;
        let lastKillTime = 0;
        const COMBO_TIMEOUT = 180; // 3 saniye
        
        // MINI-BOSS SYSTEM
        let miniBoss = null;
        const MINI_BOSS_WAVES = [5, 15, 25];
        
        const MINI_BOSS_TYPES = {
            shielder: {
                name: 'SHIELDER',
                health: 800,
                size: 50,
                speed: 1.5,
                damage: 30,
                color: '#3b82f6',
                ability: 'auraShield', // Etrafƒ±ndaki d√º≈ümanlara kalkan
                abilityRange: 200,
                teleportCooldown: 300, // 5 saniye
                scoreValue: 500
            },
            summoner: {
                name: 'SUMMONER',
                health: 600,
                size: 45,
                speed: 1.8,
                damage: 25,
                color: '#a855f7',
                ability: 'summon', // K√º√ß√ºk d√º≈üman spawn
                summonCooldown: 240, // 4 saniye
                maxSummons: 5,
                scoreValue: 600
            },
            berserker: {
                name: 'BERSERKER',
                health: 1200,
                size: 55,
                speed: 1.2,
                damage: 40,
                color: '#ef4444',
                ability: 'rage', // Can azaldƒ±k√ßa hƒ±zlanƒ±r
                rageThreshold: 0.5, // %50 HP'de rage
                rageSpeedBonus: 2.0,
                areaDamage: 50,
                scoreValue: 800
            }
        };
        
        function spawnMiniBoss(wave) {
            let bossType;
            if (wave === 5) bossType = 'shielder';
            else if (wave === 15) bossType = 'summoner';
            else if (wave === 25) bossType = 'berserker';
            
            const bossData = MINI_BOSS_TYPES[bossType];
            
            miniBoss = {
                x: Math.random() * (ARENA_SIZE - 200) + 100,
                y: Math.random() * (ARENA_SIZE - 200) + 100,
                size: bossData.size,
                health: bossData.health,
                maxHealth: bossData.health,
                speed: bossData.speed,
                baseSpeed: bossData.speed,
                damage: bossData.damage,
                color: bossData.color,
                name: bossData.name,
                ability: bossData.ability,
                abilityRange: bossData.abilityRange || 0,
                teleportCooldown: bossData.teleportCooldown || 0,
                summonCooldown: bossData.summonCooldown || 0,
                maxSummons: bossData.maxSummons || 0,
                currentSummons: 0,
                rageActive: false,
                scoreValue: bossData.scoreValue,
                type: bossType,
                isMiniBoss: true
            };
            
            // Dramatic announcement
            showDramaticAnnouncement(
                `‚ö†Ô∏è ${bossData.name} ‚ö†Ô∏è`,
                'Mini-Boss Appeared!',
                'üëπ',
                bossData.color,
                2000
            );
            
            screenShake = 30;
        }
        
        function dealDamage(enemy, baseDamage, source = 'player') {
            // Headshot chance (%15 - enemy'nin √ºst kƒ±smƒ±na vurursa)
            const isHeadshot = Math.random() < 0.15;
            
            // Critical hit chance (tree-specific)
            let critChance = 0;
            
            // RANGED: Critical Shot ability
            if (selectedWeaponTree === 'ranged' && abilityUnlocked) {
                critChance = 0.30; // %30
            }
            
            const isCrit = Math.random() < critChance;
            
            // Damage calculation
            let finalDamage = baseDamage;
            let damageType = 'normal';
            
            if (isHeadshot) {
                finalDamage *= 1.5; // 1.5x for headshot
                damageType = 'headshot';
                createSparkles(enemy.x, enemy.y - enemy.size, 3); // Sparkles at head
            }
            
            if (isCrit) {
                finalDamage *= 2; // 2x damage
                damageType = isCrit && isHeadshot ? 'critHeadshot' : 'crit';
                createSparkles(enemy.x, enemy.y, 5);
                screenShake = 5;
            }
            
            // Combo multiplier
            if (comboCount > 1 && source === 'player') {
                const comboBonus = Math.min(comboCount * 0.1, 2.0); // Max 3x at 20 combo
                finalDamage *= (1 + comboBonus);
            }
            
            enemy.health -= finalDamage;
            
            // Enhanced damage number
            let damageColor = '#ffffff';
            let damageSize = 18;
            let damageText = Math.floor(finalDamage).toString();
            
            if (damageType === 'headshot') {
                damageColor = '#ffaa00';
                damageSize = 22;
                damageText = Math.floor(finalDamage) + ' HEADSHOT!';
            } else if (damageType === 'crit') {
                damageColor = '#ff0000';
                damageSize = 24;
                damageText = Math.floor(finalDamage) + ' CRIT!';
            } else if (damageType === 'critHeadshot') {
                damageColor = '#ff00ff';
                damageSize = 28;
                damageText = Math.floor(finalDamage) + ' MEGA CRIT!';
            }
            
            // Add combo indicator to damage
            if (comboCount > 1 && source === 'player') {
                damageText += ` (${comboCount}x)`;
            }
            
            particles.push({
                x: enemy.x + (Math.random() - 0.5) * 20,
                y: enemy.y - 30 - Math.random() * 10,
                vx: (Math.random() - 0.5) * 2,
                vy: -3 - Math.random(),
                life: 40,
                color: damageColor,
                text: damageText,
                size: damageSize,
                isDamageNumber: true
            });
            
            return finalDamage;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GELƒ∞≈ûMƒ∞≈û PAR√áACIK EFEKTLERƒ∞
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Trail effect (iz bƒ±rakma - mermiler i√ßin)
        function createTrailParticle(x, y, color, vx = 0, vy = 0) {
            particles.push({
                x, y,
                vx: vx * 0.3 + (Math.random() - 0.5) * 2,
                vy: vy * 0.3 + (Math.random() - 0.5) * 2,
                life: 20,
                color,
                size: Math.random() * 3 + 1,
                alpha: 1,
                fadeRate: 0.05
            });
        }
        
        // Explosion burst (patlama - √∂l√ºm ve b√ºy√ºk hasar)
        function createExplosionBurst(x, y, color, count = 30) {
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2;
                const speed = 5 + Math.random() * 10;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 40,
                    color,
                    size: Math.random() * 6 + 3,
                    alpha: 1,
                    fadeRate: 0.025,
                    gravity: 0.2
                });
            }
        }
        
        // Sparkle effect (parƒ±ltƒ± - level up, kritik vuru≈ü)
        function createSparkles(x, y, count = 10) {
            const colors = ['#ffffff', '#ffff00', '#00ffff', '#ff00ff', '#00ff00'];
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 30,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    size: Math.random() * 3 + 1,
                    alpha: 1,
                    fadeRate: 0.033,
                    sparkle: true
                });
            }
        }
        
        // Impact effect (√ßarpma - mermi d√º≈üman √ßarpƒ±≈ümasƒ±)
        function createImpactEffect(x, y, angle, color) {
            for (let i = 0; i < 15; i++) {
                const spreadAngle = angle + (Math.random() - 0.5) * 1;
                const speed = 8 + Math.random() * 4;
                particles.push({
                    x, y,
                    vx: Math.cos(spreadAngle) * speed,
                    vy: Math.sin(spreadAngle) * speed,
                    life: 20,
                    color,
                    size: Math.random() * 4 + 2,
                    alpha: 1,
                    fadeRate: 0.05
                });
            }
        }
        
        // Level up effect
        function createLevelUpEffect(x, y) {
            // Golden ring explosion
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const speed = 8 + Math.random() * 4;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 50,
                    color: ['#ffd700', '#ffed4e', '#ffffff'][i % 3],
                    size: Math.random() * 5 + 3,
                    alpha: 1,
                    fadeRate: 0.02,
                    sparkle: true
                });
            }
            createSparkles(x, y, 20);
        }
        
        // Death explosion (d√º≈üman √∂l√ºm√º)
        function createDeathExplosion(x, y, color) {
            createExplosionBurst(x, y, color, 25);
            createSparkles(x, y, 15);
            
            // White ring
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    life: 35,
                    color: '#ffffff',
                    size: 2,
                    alpha: 1,
                    fadeRate: 0.028
                });
            }
        }
        
        // Silah g√ºncelle
        function upgradeWeapon() {
            if (!selectedWeaponTree || !WEAPONS) return;
            
            // Mevcut silahlarƒ± kill sayƒ±sƒ±na g√∂re sƒ±rala
            const weaponArray = Object.entries(WEAPONS).map(([key, weapon]) => ({
                key,
                ...weapon
            })).sort((a, b) => a.unlockKills - b.unlockKills);
            
            // Oyuncunun a√ßabileceƒüi en y√ºksek seviye silahƒ± bul
            let newWeapon = null;
            for (const weapon of weaponArray) {
                if (kills >= weapon.unlockKills) {
                    newWeapon = weapon;
                }
            }
            
            // Yeni silaha ge√ß - SADECE ger√ßekten deƒüi≈ütiyse
            if (newWeapon && player.weapon && newWeapon.name !== player.weapon.name) {
                const oldWeaponName = player.weapon.name;
                player.weapon = newWeapon;
                
                // Mobile'da dash butonunu g√∂ster
                if (platform === 'mobile' && newWeapon.ability === 'dash') {
                    document.getElementById('dashButton').style.display = 'flex';
                }
                
                // √ñzel bildirimler
                const treeIcon = WEAPON_TREES[selectedWeaponTree].icon;
                let notificationText = `${treeIcon} ${newWeapon.name.toUpperCase()} A√áILDI!`;
                
                // Yetenek a√ßƒ±klamalarƒ±
                const abilityDescriptions = {
                    'cleave': '\nAlan Hasarƒ±: Yakƒ±ndaki d√º≈ümanlara',
                    'speed_boost': '\n‚ö° +20% Hƒ±z Bonusu',
                    'pierce': '\nDelici: D√º≈ümanlarƒ± deler',
                    'double_strike': '\n√áift Vuru≈ü: 2 kez vurur',
                    'laser_cut': '\nLaser Kesimi: Jedi g√ºc√º',
                    'explosion': '\nPatlama: Alan hasarƒ±',
                    'dash': '\nDash: Shift+WASD ile ka√ßƒ±≈ü',
                    'burn': '\nYakma: S√ºrekli hasar',
                    'chain': '\nZincir: 3 d√º≈ümana sƒ±√ßrar',
                    'meteor': '\nMeteor: G√∂kten ate≈ü',
                    'radiance': '\nParƒ±ltƒ±: D√º≈ümanlarƒ± k√∂r eder',
                    'rapid': '\nHƒ±zlƒ± Atƒ±≈ü: √áok hƒ±zlƒ±'
                };
                
                if (newWeapon.ability && abilityDescriptions[newWeapon.ability]) {
                    notificationText += abilityDescriptions[newWeapon.ability];
                }
                
                showNotification(notificationText, 5000);
                
                document.getElementById('weaponInfo').textContent = t('weapon') + ': ' + getWeaponName(player.weapon);
                
                // Hƒ±z bonusu uygula
                player.speed = player.baseSpeed;
                if (player.weapon && player.weapon.ability === 'speed_boost') {
                    player.speed = player.baseSpeed * 1.2;
                }
                
                // Legendary tier hƒ±z bonusu
                if (player.visualTier === 4) {
                    player.speed *= 1.3;
                }
            }
        }
        
        // Level up sistemi
        function checkLevelUp() {
            if (player.xp >= player.xpToNextLevel) {
                player.xp -= player.xpToNextLevel;
                player.level++;
                player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
                
                // GELƒ∞≈ûMƒ∞≈û LEVEL UP EFEKTƒ∞
                createLevelUpEffect(player.x, player.y);
                screenShake = 15;
                
                // Karakter geli≈üimi
                player.maxHealth += 20;
                player.health = Math.min(player.health + 50, player.maxHealth); // Can yenileme
                player.baseSpeed += 0.15;
                player.speed = player.baseSpeed;
                
                // Silah bonusunu tekrar uygula
                if (player.weapon && player.weapon.ability === 'speed_boost') {
                    player.speed = player.baseSpeed * 1.2;
                }
                
                const oldTier = player.visualTier;
                
                // G√∂rsel tier deƒüi≈üimi
                if (player.level >= 15) player.visualTier = 4; // Legendary
                else if (player.level >= 10) player.visualTier = 3; // Elite
                else if (player.level >= 5) player.visualTier = 2; // Advanced
                
                // Tier deƒüi≈üimi bildirimleri
                if (oldTier !== player.visualTier) {
                    if (player.visualTier === 4) {
                        showNotification('üëë LEGENDARY TIER A√áILDI!\nü™Ω KANATLAR AKTƒ∞F - √áok Daha Hƒ±zlƒ±sƒ±n!', 5000);
                        player.speed *= 1.3; // Kanatlarla ekstra hƒ±z
                    } else if (player.visualTier === 3) {
                        showNotification('‚≠ê ELITE TIER A√áILDI!\n‚ú® Enerji Kalkanƒ± Aktif', 4000);
                    } else if (player.visualTier === 2) {
                        showNotification('üî∑ ADVANCED TIER A√áILDI!\nüí™ Geli≈ümi≈ü Zƒ±rh', 4000);
                    }
                }
                
                // Her 3 levelda yapƒ± hakkƒ±
                if (player.level % 3 === 0 && buildingPoints < 3) { // Max 3 stok
                    buildingPoints++;
                    if (!player.buildNotificationShown) {
                        document.getElementById('buildMenu').classList.add('active');
                        showNotification('üèóÔ∏è YENƒ∞ YAPI HAKKI!\nBir yapƒ± in≈üa edebilirsin', 4000);
                        player.buildNotificationShown = true;
                    }
                } else if (player.level % 3 !== 0) {
                    player.buildNotificationShown = false;
                }
                
                // Level up animasyonu
                const levelProgress = document.getElementById('levelProgress');
                levelProgress.style.animation = 'none';
                setTimeout(() => {
                    levelProgress.style.animation = 'levelUp 1s ease';
                }, 10);
                
                // Level up efekti
                const particleColor = player.visualTier === 4 ? '#ffd700' : 
                                     player.visualTier === 3 ? '#a855f7' :
                                     player.visualTier === 2 ? '#3b82f6' : '#00ff88';
                
                for (let i = 0; i < 50; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        life: 60,
                        color: particleColor
                    });
                }
                
                document.getElementById('level').textContent = player.level;
            }
        }
        
        // Oyun d√∂ng√ºs√º
        function update() {
            // Silah se√ßilmediyse oyunu ba≈ülatma
            if (!player.weapon) {
                return;
            }
            
            // Oyun pause ise g√ºncelleme yapma
            if (gameState === 'paused') {
                return;
            }
            
            // Ability cooldown ve duration
            if (abilityCooldown > 0) abilityCooldown--;
            if (abilityDuration > 0) {
                abilityDuration--;
                if (abilityDuration <= 0) {
                    abilityActive = false;
                }
            }
            
            // WAVE MODIFIER EFFECTS
            if (modifierDuration > 0) {
                modifierDuration--;
                if (modifierDuration <= 0) {
                    activeModifier = null;
                    // Reset modifiers
                    playerSpeedMod = 1;
                    enemySpeedMod = 1;
                    playerSizeMod = 1;
                    enemySizeMod = 1;
                }
            }
            
            // Apply modifier multipliers
            if (activeModifier) {
                if (activeModifier.playerSpeedMult) playerSpeedMod = activeModifier.playerSpeedMult;
                if (activeModifier.enemySpeedMult) enemySpeedMod = activeModifier.enemySpeedMult;
                if (activeModifier.sizeMult) {
                    playerSizeMod = activeModifier.sizeMult;
                    enemySizeMod = activeModifier.sizeMult;
                }
                if (activeModifier.enemySizeMult) enemySizeMod = activeModifier.enemySizeMult;
            }
            
            // Idle animasyon
            player.idleFrame++;
            
            // Combo timer decay
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer <= 0) {
                    if (comboCount > 1) {
                        showNotification(`üíî COMBO LOST!\n${comboCount}x combo ended`, 2000);
                    }
                    comboCount = 0;
                }
            }
            
            // Oyuncu hareketi (Keyboard veya Joystick) - √ñNCE HESAPLA
            let moveX = 0, moveY = 0;
            
            if (platform === 'mobile' && joystick.active) {
                // Mobile joystick hareketi
                moveX = joystick.deltaX;
                moveY = joystick.deltaY;
            } else {
                // Keyboard hareketi
                if (keys['w'] || keys['W'] || keys['arrowup']) moveY = -1;
                if (keys['s'] || keys['S'] || keys['arrowdown']) moveY = 1;
                if (keys['a'] || keys['A'] || keys['arrowleft']) moveX = -1;
                if (keys['d'] || keys['D'] || keys['arrowright']) moveX = 1;
            }
            
            const isMoving = moveX !== 0 || moveY !== 0;
            
            // Oyuncu y√∂n√º (Mobile: aim joystick, Desktop: WASD/mouse)
            if (platform === 'mobile' && aimJoystick.active) {
                // Mobile'da hedefleme joystick'inin g√∂sterdiƒüi y√∂n
                player.direction = aimJoystick.angle;
            } else if (platform === 'desktop') {
                // Desktop'ta WASD ile hareket ediyorsa, hareket y√∂n√ºne bak
                if (isMoving && (moveX !== 0 || moveY !== 0)) {
                    player.direction = Math.atan2(moveY, moveX);
                }
                // Mouse ile hedefleme hala mousemove event'inde ayarlanƒ±yor
            }
            
            // Dash yeteneƒüi
            const dashActive = platform === 'mobile' ? mobileDashing : (keys['shift'] || keys['Shift']);
            
            if (player.weapon && player.weapon.ability === 'dash' && dashActive && 
                player.dashCooldown <= 0 && isMoving) {
                player.dashCooldown = 120;
                player.dashActive = true;
                
                const dashSpeed = 20;
                player.x += moveX * dashSpeed;
                player.y += moveY * dashSpeed;
                
                // Dash efekti
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: -moveX * 5 + (Math.random() - 0.5) * 3,
                        vy: -moveY * 5 + (Math.random() - 0.5) * 3,
                        life: 20,
                        color: '#ff4500'
                    });
                }
                
                setTimeout(() => player.dashActive = false, 200);
            }
            if (player.dashCooldown > 0) player.dashCooldown--;
            
            // ABILITY EFFECTS
            const treeData = WEAPON_TREES[selectedWeaponTree];
            
            // MELEE: Dodge Roll
            if (treeData?.ability === 'dodge_roll' && abilityActive && window.dodgeDirection) {
                player.x += window.dodgeDirection.x;
                player.y += window.dodgeDirection.y;
                
                // Dodge trail
                if (Math.random() > 0.5) {
                    createTrailParticle(player.x, player.y, '#00ffdd', 0, 0);
                }
            } else {
                // Normal hareket
                if (isMoving) {
                    // Normalize diagonal movement
                    const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
                    if (magnitude > 0) {
                        moveX /= magnitude;
                        moveY /= magnitude;
                    }
                    
                    // HYBRID: Sprint speed boost
                    let currentSpeed = player.speed * playerSpeedMod; // Apply modifier
                    if (treeData?.ability === 'sprint' && abilityActive && abilityDuration > 0) {
                        currentSpeed *= 1.5; // %50 hƒ±z artƒ±≈üƒ±
                        
                        // Sprint particles
                        if (Math.random() > 0.7) {
                            createTrailParticle(player.x, player.y, '#ffd700', -moveX * 2, -moveY * 2);
                        }
                    }
                    
                    // Trail effect (cosmetic) - MORE VISIBLE
                    if (equippedTrail !== 'default' && Math.random() > 0.5) { // %50 spawn rate (was 0.8)
                        const trail = COSMETICS.trails[equippedTrail];
                        if (trail.color) {
                            const trailColor = trail.color === 'rainbow' 
                                ? `hsl(${Date.now() / 10 % 360}, 100%, 50%)`
                                : trail.color;
                            
                            // Create bigger trail particles
                            particles.push({
                                x: player.x,
                                y: player.y,
                                vx: -moveX * 2,
                                vy: -moveY * 2,
                                life: 30, // Longer life
                                color: trailColor,
                                size: 8, // Bigger
                                alpha: 0.8,
                                fadeRate: 0.03
                            });
                        }
                    }
                    
                    player.x += moveX * currentSpeed;
                    player.y += moveY * currentSpeed;
                }
            }
            
            // Arena sƒ±nƒ±rlarƒ±
            player.x = Math.max(player.size, Math.min(ARENA_SIZE - player.size, player.x));
            player.y = Math.max(player.size, Math.min(ARENA_SIZE - player.size, player.y));
            
            // Dekorasyon √ßarpƒ±≈ümasƒ±
            decorations.forEach(deco => {
                if (deco.destroyed) return;
                
                const dx = player.x - deco.x;
                const dy = player.y - deco.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = player.size + deco.size;
                
                if (dist < minDist) {
                    // Oyuncuyu geri it
                    const angle = Math.atan2(dy, dx);
                    const overlap = minDist - dist;
                    player.x += Math.cos(angle) * overlap;
                    player.y += Math.sin(angle) * overlap;
                }
            });
            
            // Saldƒ±rƒ± (Mouse/Space veya Mobile Button)
            const attackInput = platform === 'mobile' ? 
                mobileAttacking : 
                (mouse.down || keys[' '] || keys['space']);
            
            if (attackInput && player.canAttack && !player.reloading && player.weapon) {
                console.log('üéØ ATTACK! Weapon:', player.weapon.name, 'Type:', player.weapon.type);
                
                player.attacking = true;
                
                // POWER-UP: Fire rate boost
                let attackSpeed = player.weapon.speed;
                if (activePowerUps.fireRate > 0) {
                    attackSpeed *= POWERUP_TYPES.fireRate.multiplier;
                }
                player.attackCooldown = 30 / attackSpeed;
                
                // Attack angle = player'ƒ±n baktƒ±ƒüƒ± y√∂n (WASD veya mouse veya joystick)
                player.attackAngle = player.direction;
                
                player.attackFrame = 15;
                player.canAttack = false;
                
                // Reload ba≈ülat
                player.reloading = true;
                player.reloadProgress = 0;
                
                // Ranged ve Hybrid silahlar i√ßin mermi olu≈ütur
                if (player.weapon.type === 'ranged' || player.weapon.type === 'hybrid') {
                    console.log('üî´ Creating projectile for weapon:', player.weapon.name, 'type:', player.weapon.type);
                    
                    const angle = player.attackAngle;
                    const startDist = player.size + 20;
                    
                    // Get equipped weapon skin
                    const equippedSkin = equippedItems.weapon || 'default';
                    const isCosmetic = equippedSkin.startsWith('weapon_');
                    
                    projectiles.push({
                        x: player.x + Math.cos(angle) * startDist,
                        y: player.y + Math.sin(angle) * startDist,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        damage: player.weapon.damage,
                        size: 8,
                        color: player.weapon.color,
                        life: 150,
                        targetBase: false,
                        fromPlayer: true,
                        piercing: player.weapon.ability === 'pierce' || player.weapon.ability === 'explosion',
                        weaponSkin: isCosmetic ? equippedSkin : null // Add weapon skin for custom bullet
                    });
                    
                    // Muzzle flash
                    createMuzzleFlash(
                        player.x + Math.cos(angle) * startDist,
                        player.y + Math.sin(angle) * startDist,
                        angle,
                        player.weapon.color,
                        15
                    );
                }
                
                // Harita dekorasyonlarƒ±na hasar (TNT varilleri!)
                mapDecorations.forEach(deco => {
                    if (deco.exploded) return;
                    if (deco.type !== 'tnt') return;
                    
                    const dx = deco.x - player.x;
                    const dy = deco.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angle - player.attackAngle);
                    
                    if (dist < player.weapon.range + player.size + deco.size && angleDiff < 0.8) {
                        // TNT'ye hasar ver
                        deco.health -= player.weapon.damage;
                        
                        // Hasar efekti
                        createParticles(deco.x, deco.y, '#FF4500', 5);
                        
                        // Can 0'a d√º≈üt√ºƒü√ºnde PATLAMA!
                        if (deco.health <= 0) {
                            deco.exploded = true;
                            screenShake = 25;
                            
                            // Patlama efekti
                            for (let i = 0; i < 50; i++) {
                                const angle = (i / 50) * Math.PI * 2;
                                particles.push({
                                    x: deco.x,
                                    y: deco.y,
                                    vx: Math.cos(angle) * (10 + Math.random() * 10),
                                    vy: Math.sin(angle) * (10 + Math.random() * 10),
                                    life: 60,
                                    color: i % 3 === 0 ? '#FF4500' : i % 3 === 1 ? '#FFA500' : '#FFFF00',
                                    size: 8 + Math.random() * 6
                                });
                            }
                            
                            // Yakƒ±ndaki herkese hasar
                            const explosionRadius = 200;
                            const explosionDamage = 150;
                            
                            // D√º≈ümanlara hasar
                            enemies.forEach(enemy => {
                                const edx = enemy.x - deco.x;
                                const edy = enemy.y - deco.y;
                                const edist = Math.sqrt(edx * edx + edy * edy);
                                
                                if (edist < explosionRadius) {
                                    const damageMultiplier = 1 - (edist / explosionRadius);
                                    enemy.health -= explosionDamage * damageMultiplier;
                                    createParticles(enemy.x, enemy.y, '#FF4500', 15);
                                }
                            });
                            
                            // Yapƒ±lara hasar
                            buildings.forEach(building => {
                                const bdx = building.x - deco.x;
                                const bdy = building.y - deco.y;
                                const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
                                
                                if (bdist < explosionRadius) {
                                    const damageMultiplier = 1 - (bdist / explosionRadius);
                                    building.health -= explosionDamage * damageMultiplier * 0.5;
                                }
                            });
                            
                            // Oyuncuya hasar
                            const pdx = player.x - deco.x;
                            const pdy = player.y - deco.y;
                            const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                            
                            if (pdist < explosionRadius) {
                                const damageMultiplier = 1 - (pdist / explosionRadius);
                                player.health -= explosionDamage * damageMultiplier * 0.3;
                            }
                            
                            showNotification('üí• TNT EXPLOSION! üí•', 3000);
                        }
                    }
                });
                
                // Dekorasyonlara hasar
                decorations.forEach(deco => {
                    if (deco.destroyed) return;
                    
                    const dx = deco.x - player.x;
                    const dy = deco.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angle - player.attackAngle);
                    
                    // Melee/hybrid weapons get +20% range boost
                    const rangeMultiplier = (player.weapon.type === 'melee' || player.weapon.type === 'hybrid') ? 1.8 : 1.0;
                    const effectiveRange = player.weapon.range * rangeMultiplier;
                    
                    if (dist < effectiveRange + player.size + deco.size && angleDiff < 0.8) {
                        deco.health -= player.weapon.damage;
                        
                        if (deco.type === 'crystal') {
                            createParticles(deco.x, deco.y, deco.color, 5);
                        } else if (deco.type === 'pillar') {
                            createParticles(deco.x, deco.y, '#78716c', 5);
                        } else if (deco.type === 'rock') {
                            createParticles(deco.x, deco.y, '#57534e', 5);
                        }
                        
                        if (deco.health <= 0) {
                            deco.destroyed = true;
                            createParticles(deco.x, deco.y, deco.color || '#78716c', 15);
                        }
                    }
                });
                
                // D√º≈ümanlara hasar
                enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angle - player.attackAngle);
                    
                    // Melee/hybrid weapons get +20% range boost
                    const rangeMultiplier = (player.weapon.type === 'melee' || player.weapon.type === 'hybrid') ? 1.8 : 1.0;
                    const effectiveRange = player.weapon.range * rangeMultiplier;
                    
                    if (dist < effectiveRange + player.size && angleDiff < 0.8) {
                        let damage = player.weapon.damage;
                        
                        // POWER-UP: Damage boost
                        if (activePowerUps.damage > 0) {
                            damage *= POWERUP_TYPES.damage.multiplier;
                        }
                        
                        // Blood Moon event: ekstra XP
                        if (currentEvent && currentEvent.type === 'bloodMoon') {
                            // D√º≈ümanlar g√º√ßl√º ama biz bu hasarƒ± d√º≈ümana verirken uygularƒ±z
                        }
                        
                        // Kalkan varsa hasar azalt
                        if (enemy.shieldActive && enemy.shieldActive > 0) {
                            damage *= 0.3;
                        }
                        
                        // DAMAGE SYSTEM (crit + numbers)
                        dealDamage(enemy, damage);
                        enemy.stunned = 10;
                        
                        // Geri itme efekti
                        const knockback = 15;
                        enemy.x += Math.cos(angle) * knockback;
                        enemy.y += Math.sin(angle) * knockback;
                        
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        
                        // Hasar sayƒ±sƒ± efekti
                        particles.push({
                            x: enemy.x,
                            y: enemy.y - 30,
                            vx: 0,
                            vy: -2,
                            life: 40,
                            color: enemy.shieldActive ? '#60a5fa' : '#ffffff',
                            text: '-' + Math.floor(damage)
                        });
                        
                        // √ñzel silah yetenekleri
                        if (player.weapon.ability === 'cleave') {
                            // Sava≈ü Baltasƒ± - Alan hasarƒ± (yakƒ±ndaki d√º≈ümanlara)
                            enemies.forEach(nearEnemy => {
                                if (nearEnemy !== enemy) {
                                    const ndx = nearEnemy.x - enemy.x;
                                    const ndy = nearEnemy.y - enemy.y;
                                    const ndist = Math.sqrt(ndx * ndx + ndy * ndy);
                                    
                                    if (ndist < 80) {
                                        nearEnemy.health -= damage * 0.5;
                                        createParticles(nearEnemy.x, nearEnemy.y, '#ffa500', 5);
                                    }
                                }
                            });
                        } else if (player.weapon.ability === 'burn') {
                            // Yanma hasarƒ± - zamanla hasar
                            enemy.burning = 120; // 2 saniye
                            enemy.burnDamage = 1; // Frame ba≈üƒ±na
                        } else if (player.weapon.ability === 'chain') {
                            // Zincir - 3 d√º≈ümana sƒ±√ßrar
                            let chainTargets = [enemy];
                            for (let i = 0; i < 2; i++) {
                                let nearestChain = null;
                                let nearestDist = 150;
                                
                                enemies.forEach(e => {
                                    if (!chainTargets.includes(e)) {
                                        const lastTarget = chainTargets[chainTargets.length - 1];
                                        const dx = e.x - lastTarget.x;
                                        const dy = e.y - lastTarget.y;
                                        const dist = Math.sqrt(dx * dx + dy * dy);
                                        
                                        if (dist < nearestDist) {
                                            nearestDist = dist;
                                            nearestChain = e;
                                        }
                                    }
                                });
                                
                                if (nearestChain) {
                                    chainTargets.push(nearestChain);
                                    nearestChain.health -= damage * 0.6;
                                    createParticles(nearestChain.x, nearestChain.y, '#b91c1c', 8);
                                }
                            }
                        } else if (player.weapon.ability === 'meteor') {
                            // Meteor - patla
                            setTimeout(() => {
                                enemies.forEach(e => {
                                    const dx = e.x - enemy.x;
                                    const dy = e.y - enemy.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < 100) {
                                        e.health -= 30;
                                        createParticles(e.x, e.y, '#991b1b', 10);
                                    }
                                });
                            }, 300);
                        } else if (player.weapon.ability === 'radiance') {
                            // Parƒ±ltƒ± - k√∂r et
                            enemies.forEach(e => {
                                const dx = e.x - enemy.x;
                                const dy = e.y - enemy.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist < 200) {
                                    e.stunned = Math.max(e.stunned, 60); // 1 saniye
                                    createParticles(e.x, e.y, '#fbbf24', 5);
                                }
                            });
                        } else if (player.weapon.ability === 'double_strike') {
                            // ƒ∞kiz Bƒ±√ßaklar - 2. vuru≈ü
                            setTimeout(() => {
                                if (enemy.health > 0) {
                                    enemy.health -= damage * 0.7;
                                    createParticles(enemy.x, enemy.y, '#a855f7', 8);
                                }
                            }, 150);
                        } else if (player.weapon.ability === 'laser_cut') {
                            // I≈üƒ±n Kƒ±lƒ±cƒ± - Laser kesimi efekti
                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: enemy.x + (Math.random() - 0.5) * 30,
                                    y: enemy.y + (Math.random() - 0.5) * 30,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 30,
                                    color: '#3b82f6',
                                    size: 3
                                });
                            }
                        }
                        
                        if (enemy.health <= 0) {
                            console.log('‚öîÔ∏è MELEE KILL! Weapon:', player.weapon.name, 'Type:', player.weapon.type, 'Score:', enemy.scoreValue);
                            
                            score += enemy.scoreValue;
                            kills++;
                            
                            // Calculate XP with bonus
                            let xpGain = enemy.xpValue;
                            if (hasPerk('perk_xpbonus')) {
                                xpGain = Math.floor(xpGain * 1.30); // +30% XP
                            }
                            player.xp += xpGain;
                            
                            // Weekly challenge tracking
                            updateChallengeProgress('kills', 1);
                            
                            // GELƒ∞≈ûMƒ∞≈û √ñL√úM EFEKTƒ∞
                            createDeathExplosion(enemy.x, enemy.y, enemy.color);
                            
                            // GOLD DROP
                            const goldAmount = Math.floor(5 + Math.random() * 10); // 5-15 gold
                            let goldMultiplier = activePowerUps.goldRush > 0 ? 
                                POWERUP_TYPES.goldRush.multiplier : 
                                (currentEvent && currentEvent.type === 'goldRush' ? currentEvent.goldMultiplier : 1);
                            
                            // Apply Wealth perk (+25% gold)
                            if (hasPerk('perk_goldbonus')) {
                                goldMultiplier *= 1.25;
                            }
                            
                            gold += Math.floor(goldAmount * goldMultiplier);
                            document.getElementById('goldDisplay').textContent = gold;
                            
                            // Gold par√ßacƒ±k efekti
                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: -5 - Math.random() * 3,
                                    life: 40,
                                    color: '#ffd700',
                                    size: 4,
                                    text: 'üí∞'
                                });
                            }
                            
                            // POWER-UP DROP (5% ≈üans)
                            if (Math.random() < 0.05) {
                                spawnPowerUp(enemy.x, enemy.y);
                            }
                            
                            // Plazma Topu patlama hasarƒ±
                            if (player.weapon.ability === 'explosion') {
                                enemies.forEach(nearEnemy => {
                                    const edx = nearEnemy.x - enemy.x;
                                    const edy = nearEnemy.y - enemy.y;
                                    const edist = Math.sqrt(edx * edx + edy * edy);
                                    
                                    if (edist < 150) {
                                        nearEnemy.health -= 50;
                                        createParticles(nearEnemy.x, nearEnemy.y, '#06b6d4', 10);
                                    }
                                });
                                
                                // Patlama efekti
                                for (let i = 0; i < 30; i++) {
                                    particles.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        vx: Math.cos(i / 30 * Math.PI * 2) * 10,
                                        vy: Math.sin(i / 30 * Math.PI * 2) * 10,
                                        life: 40,
                                        color: '#06b6d4',
                                        size: 5
                                    });
                                }
                            }
                            
                            upgradeWeapon();
                            
                            // Skor animasyonu
                            const scoreDisplay = document.getElementById('scoreDisplay');
                            scoreDisplay.style.animation = 'none';
                            setTimeout(() => {
                                scoreDisplay.style.animation = 'scorePopUp 0.5s ease';
                            }, 10);
                            
                            // Skor par√ßacƒ±klarƒ±
                            const particlesContainer = document.getElementById('scoreParticles');
                            for (let i = 0; i < 8; i++) {
                                const particle = document.createElement('div');
                                particle.className = 'score-particle';
                                const angle = (i / 8) * Math.PI * 2;
                                particle.style.setProperty('--tx', Math.cos(angle) * 100 + 'px');
                                particle.style.setProperty('--ty', Math.sin(angle) * 100 + 'px');
                                particlesContainer.appendChild(particle);
                                setTimeout(() => particle.remove(), 1000);
                            }
                        }
                    }
                });
                
                // Boss'a hasar
                if (boss) {
                    const dx = boss.x - player.x;
                    const dy = boss.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angle - player.attackAngle);
                    
                    // Melee/hybrid weapons get +20% range boost
                    const rangeMultiplier = (player.weapon.type === 'melee' || player.weapon.type === 'hybrid') ? 1.8 : 1.0;
                    const effectiveRange = player.weapon.range * rangeMultiplier;
                    
                    if (dist < effectiveRange + player.size + boss.size && angleDiff < 0.8) {
                        boss.health -= player.weapon.damage;
                        createParticles(boss.x, boss.y, boss.color, 12);
                        
                        particles.push({
                            x: boss.x,
                            y: boss.y - 40,
                            vx: 0,
                            vy: -2,
                            life: 40,
                            color: '#ffffff',
                            text: '-' + player.weapon.damage
                        });
                        
                        if (boss.health <= 0) {
                            score += 500;
                            player.xp += 300;
                            createParticles(boss.x, boss.y, boss.color, 50);
                            screenShake = 30; // Boss √∂l√ºm√ºnde b√ºy√ºk sarsƒ±ntƒ±
                            boss = null;
                        }
                    }
                }
            }
            
            if (player.attackFrame > 0) {
                player.attackFrame--;
            } else {
                player.attacking = false;
            }
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            
            // Reload sistemi
            if (player.reloading && player.weapon) {
                player.reloadProgress++;
                if (player.reloadProgress >= player.weapon.reloadTime) {
                    player.reloading = false;
                    player.reloadProgress = 0;
                    player.canAttack = true;
                }
            }
            
            // Bildirimler
            notifications.forEach(notif => {
                notif.life--;
            });
            notifications = notifications.filter(n => n.life > 0);
            
            // Muzzle flash'ler
            muzzleFlashes.forEach(flash => {
                flash.life--;
            });
            muzzleFlashes = muzzleFlashes.filter(f => f.life > 0);
            
            // BASE UPGRADES √ßalƒ±≈üƒ±yor
            if (base && gameState === 'playing') {
                // Auto-Turret
                if (baseCustomization.autoTurret) {
                    if (!base.turretCooldown) base.turretCooldown = 0;
                    base.turretCooldown--;
                    
                    if (base.turretCooldown <= 0) {
                        const turretRange = BASE_UPGRADES.autoTurret.range;
                        const nearestEnemy = enemies.find(e => {
                            const dx = e.x - base.x;
                            const dy = e.y - base.y;
                            return Math.sqrt(dx * dx + dy * dy) < turretRange;
                        });
                        
                        if (nearestEnemy) {
                            base.turretCooldown = BASE_UPGRADES.autoTurret.cooldown;
                            const angle = Math.atan2(nearestEnemy.y - base.y, nearestEnemy.x - base.x);
                            
                            projectiles.push({
                                x: base.x,
                                y: base.y,
                                vx: Math.cos(angle) * 8,
                                vy: Math.sin(angle) * 8,
                                damage: BASE_UPGRADES.autoTurret.damage,
                                color: '#fbbf24',
                                size: 6,
                                fromBase: true
                            });
                            
                            createMuzzleFlash(base.x, base.y, angle, '#fbbf24', 15);
                        }
                    }
                }
                
                // Tesla Coil
                if (baseCustomization.teslaTower) {
                    if (!base.teslaCooldown) base.teslaCooldown = 0;
                    base.teslaCooldown--;
                    
                    if (base.teslaCooldown <= 0) {
                        base.teslaCooldown = 60;
                        const teslaRange = BASE_UPGRADES.teslaTower.range;
                        
                        const nearEnemies = enemies.filter(e => {
                            const dx = e.x - base.x;
                            const dy = e.y - base.y;
                            return Math.sqrt(dx * dx + dy * dy) < teslaRange;
                        });
                        
                        if (nearEnemies.length > 0) {
                            let chainTargets = nearEnemies.slice(0, BASE_UPGRADES.teslaTower.chainCount);
                            chainTargets.forEach(target => {
                                target.health -= BASE_UPGRADES.teslaTower.damage;
                                
                                // Lightning efekti
                                for (let i = 0; i < 5; i++) {
                                    particles.push({
                                        x: target.x,
                                        y: target.y,
                                        vx: (Math.random() - 0.5) * 8,
                                        vy: (Math.random() - 0.5) * 8,
                                        life: 15,
                                        color: '#60a5fa',
                                        size: 4
                                    });
                                }
                            });
                        }
                    }
                }
                
                // Missile Launcher
                if (baseCustomization.missileLauncher) {
                    if (!base.missileCooldown) base.missileCooldown = 0;
                    base.missileCooldown--;
                    
                    if (base.missileCooldown <= 0) {
                        const missileRange = BASE_UPGRADES.missileLauncher.range;
                        const nearestEnemy = enemies.find(e => {
                            const dx = e.x - base.x;
                            const dy = e.y - base.y;
                            return Math.sqrt(dx * dx + dy * dy) < missileRange;
                        });
                        
                        if (nearestEnemy) {
                            base.missileCooldown = BASE_UPGRADES.missileLauncher.cooldown;
                            
                            // Patlama
                            for (let i = 0; i < 30; i++) {
                                const angle = (i / 30) * Math.PI * 2;
                                particles.push({
                                    x: nearestEnemy.x,
                                    y: nearestEnemy.y,
                                    vx: Math.cos(angle) * 12,
                                    vy: Math.sin(angle) * 12,
                                    life: 40,
                                    color: '#f97316',
                                    size: 6
                                });
                            }
                            
                            // Area damage
                            enemies.forEach(e => {
                                const dx = e.x - nearestEnemy.x;
                                const dy = e.y - nearestEnemy.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 150) {
                                    e.health -= BASE_UPGRADES.missileLauncher.damage * (1 - dist / 150);
                                }
                            });
                        }
                    }
                }
                
                // Force Field (d√º≈ümanlarƒ± yava≈ülat)
                if (baseCustomization.forceField) {
                    enemies.forEach(enemy => {
                        const dx = enemy.x - base.x;
                        const dy = enemy.y - base.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < BASE_UPGRADES.forceField.range) {
                            enemy.forcefieldSlow = BASE_UPGRADES.forceField.slowAmount;
                            
                            // Force field par√ßacƒ±klarƒ±
                            if (Math.random() > 0.9) {
                                particles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: 0,
                                    vy: -1,
                                    life: 20,
                                    color: '#3b82f6',
                                    size: 4
                                });
                            }
                        }
                    });
                }
            }
            
            // D√º≈üman hareketi ve saldƒ±rƒ±
            enemies.forEach(enemy => {
                if (enemy.stunned > 0) {
                    enemy.stunned--;
                    return;
                }
                
                // Yanma hasarƒ±
                if (enemy.burning && enemy.burning > 0) {
                    enemy.burning--;
                    enemy.health -= enemy.burnDamage || 1;
                    
                    if (Math.random() > 0.7) {
                        createParticles(enemy.x, enemy.y, '#f97316', 2);
                    }
                }
                
                // Hedef belirleme
                let targetX, targetY, targetSize;
                if (enemy.targetPreference === 'base' && base) {
                    targetX = base.x;
                    targetY = base.y;
                    targetSize = base.size;
                } else {
                    targetX = player.x;
                    targetY = player.y;
                    targetSize = player.size;
                }
                
                const dx = targetX - enemy.x;
                const dy = targetY - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Dalga ilerledik√ße hƒ±z artar (her dalgada %5 artƒ±≈ü)
                const speedMultiplier = 1 + (wave - 1) * 0.05;
                // BIOME speed multiplier
                const biomeSpeedMult = BIOMES[currentBiome].enemySpeedMult;
                const actualSpeed = enemy.speed * speedMultiplier * biomeSpeedMult * enemySpeedMod;
                
                // √ñzel yetenekler (sadece oyuncuya kar≈üƒ±)
                if (enemy.targetPreference === 'player') {
                    if (enemy.ability === 'speed' && enemy.dashCooldown <= 0 && dist < 400 && dist > 100) {
                        enemy.dashCooldown = 180;
                        const dashSpeed = 15 * speedMultiplier;
                        enemy.x += (dx / dist) * dashSpeed;
                        enemy.y += (dy / dist) * dashSpeed;
                        createParticles(enemy.x, enemy.y, enemy.color, 5);
                        
                    } else if (enemy.ability === 'shoot' && enemy.abilityCooldown <= 0 && dist < 500 && dist > 150) {
                        enemy.abilityCooldown = 120;
                        const angle = Math.atan2(dy, dx);
                        
                        // Muzzle flash
                        createMuzzleFlash(enemy.x, enemy.y, angle, '#f59e0b', 12);
                        
                        projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 5,
                            vy: Math.sin(angle) * 5,
                            damage: 15,
                            size: 8,
                            color: '#f59e0b',
                            life: 120,
                            targetBase: false
                        });
                    } else if (enemy.ability === 'teleport' && enemy.abilityCooldown <= 0 && dist < 500 && dist > 200) {
                        // Teleport - Oyuncuya yakƒ±n teleport
                        enemy.abilityCooldown = 240;
                        createParticles(enemy.x, enemy.y, enemy.color, 15);
                        
                        const teleportDist = 150;
                        enemy.x = targetX + Math.cos(Math.random() * Math.PI * 2) * teleportDist;
                        enemy.y = targetY + Math.cos(Math.random() * Math.PI * 2) * teleportDist;
                        
                        createParticles(enemy.x, enemy.y, enemy.color, 15);
                    } else if (enemy.ability === 'sprint' && enemy.abilityCooldown <= 0 && dist < 300) {
                        // Sprint - Hƒ±z patlamasƒ±
                        enemy.abilityCooldown = 120;
                        enemy.sprintActive = 30;
                    }
                }
                
                // Sprint aktifse hƒ±z x3
                let moveSpeed = actualSpeed;
                if (enemy.sprintActive && enemy.sprintActive > 0) {
                    moveSpeed *= 3;
                    enemy.sprintActive--;
                    if (Math.random() > 0.7) {
                        createParticles(enemy.x, enemy.y, enemy.color, 2);
                    }
                }
                
                // √ús saldƒ±rƒ±sƒ± yetenekleri
                if (enemy.targetPreference === 'base' && base) {
                    if (enemy.ability === 'flame' && enemy.abilityCooldown <= 0 && dist < 250) {
                        enemy.abilityCooldown = 5;
                        const angle = Math.atan2(dy, dx);
                        const spread = (Math.random() - 0.5) * 0.5;
                        projectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle + spread) * 4,
                            vy: Math.sin(angle + spread) * 4,
                            damage: 3,
                            size: 6,
                            color: Math.random() > 0.5 ? '#ff4500' : '#ffa500',
                            life: 40,
                            targetBase: true
                        });
                        
                    } else if (enemy.ability === 'laser' && enemy.abilityCooldown <= 0 && dist < 600) {
                        enemy.abilityCooldown = 180;
                        const angle = Math.atan2(dy, dx);
                        
                        for (let i = 0; i < 10; i++) {
                            projectiles.push({
                                x: enemy.x + Math.cos(angle) * i * 20,
                                y: enemy.y + Math.sin(angle) * i * 20,
                                vx: Math.cos(angle) * 12,
                                vy: Math.sin(angle) * 12,
                                damage: 10,
                                size: 4,
                                color: '#a78bfa',
                                life: 60,
                                laser: true,
                                targetBase: true
                            });
                        }
                    } else if (enemy.ability === 'summon' && enemy.abilityCooldown <= 0 && dist < 400) {
                        // Summoner - K√º√ß√ºk d√º≈ümanlar √ßaƒüƒ±rƒ±r
                        enemy.abilityCooldown = 300; // 5 saniye
                        
                        for (let i = 0; i < 2; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const spawnDist = 50;
                            enemies.push({
                                x: enemy.x + Math.cos(angle) * spawnDist,
                                y: enemy.y + Math.sin(angle) * spawnDist,
                                ...JSON.parse(JSON.stringify(ENEMY_TYPES.scout)),
                                health: 20, // Daha zayƒ±f
                                maxHealth: 20,
                                stunned: 0,
                                abilityCooldown: 0,
                                dashCooldown: 0,
                                summoned: true
                            });
                        }
                        createParticles(enemy.x, enemy.y, enemy.color, 20);
                    } else if (enemy.ability === 'shield' && !enemy.shieldActive) {
                        // Tank - Kalkan
                        if (enemy.health < enemy.maxHealth * 0.5 && enemy.abilityCooldown <= 0) {
                            enemy.shieldActive = 180; // 3 saniye
                            enemy.abilityCooldown = 360; // 6 saniye cooldown
                            createParticles(enemy.x, enemy.y, '#60a5fa', 15);
                        }
                    }
                    
                    // Kalkan azalmasƒ±
                    if (enemy.shieldActive && enemy.shieldActive > 0) {
                        enemy.shieldActive--;
                    }
                }
                
                if (enemy.abilityCooldown > 0) enemy.abilityCooldown--;
                if (enemy.dashCooldown > 0) enemy.dashCooldown--;
                
                // Normal hareket
                if (dist > enemy.size + targetSize + 10) {
                    // Force Field slow etkisi
                    let moveSpeed = actualSpeed;
                    if (enemy.forcefieldSlow) {
                        moveSpeed *= enemy.forcefieldSlow;
                        enemy.forcefieldSlow = null; // Her frame yeniden hesaplanƒ±r
                    }
                    
                    enemy.x += (dx / dist) * moveSpeed;
                    enemy.y += (dy / dist) * moveSpeed;
                    
                    // Geli≈ümi≈ü duvar √ßarpƒ±≈ümasƒ± - d√º≈üman ge√ßemez
                    buildings.forEach(building => {
                        if (building.type === 'wall') {
                            const wallW = BUILDING_TYPES.wall.width;
                            const wallH = BUILDING_TYPES.wall.height;
                            
                            // Dikd√∂rtgen √ßarpƒ±≈üma kontrol√º
                            const enemyLeft = enemy.x - enemy.size;
                            const enemyRight = enemy.x + enemy.size;
                            const enemyTop = enemy.y - enemy.size;
                            const enemyBottom = enemy.y + enemy.size;
                            
                            const wallLeft = building.x - wallW / 2;
                            const wallRight = building.x + wallW / 2;
                            const wallTop = building.y - wallH;
                            const wallBottom = building.y;
                            
                            // √áarpƒ±≈üma var mƒ±?
                            if (enemyRight > wallLeft && enemyLeft < wallRight &&
                                enemyBottom > wallTop && enemyTop < wallBottom) {
                                
                                // D√º≈ümanƒ± dƒ±≈üarƒ± it
                                const overlapLeft = enemyRight - wallLeft;
                                const overlapRight = wallRight - enemyLeft;
                                const overlapTop = enemyBottom - wallTop;
                                const overlapBottom = wallBottom - enemyTop;
                                
                                const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                                
                                if (minOverlap === overlapLeft) {
                                    enemy.x -= overlapLeft;
                                } else if (minOverlap === overlapRight) {
                                    enemy.x += overlapRight;
                                } else if (minOverlap === overlapTop) {
                                    enemy.y -= overlapTop;
                                } else {
                                    enemy.y += overlapBottom;
                                }
                                
                                // Duvara hasar
                                building.health -= 0.2;
                                
                                // Elektrik efekti
                                if (Math.random() > 0.8) {
                                    createParticles(
                                        enemy.x,
                                        enemy.y,
                                        '#00ffff',
                                        3
                                    );
                                }
                            }
                        }
                    });
                } else {
                    // Hedefe zarar ver
                    if (enemy.targetPreference === 'base' && base) {
                        base.health -= enemy.damage * 0.1;
                    } else {
                        // POWER-UP: Shield - hasar almaz
                        if (activePowerUps.shield <= 0) {
                            player.health -= enemy.damage * 0.1;
                        } else {
                            // Shield aktif - par√ßacƒ±k efekti
                            if (Math.random() > 0.8) {
                                createParticles(player.x, player.y, '#4444ff', 3);
                            }
                        }
                    }
                }
            });
            
            // √ñl√º d√º≈ümanlarƒ± temizle
            // Track combo on enemy death
            enemies.forEach(enemy => {
                if (enemy.health <= 0 && !enemy.comboCounted) {
                    enemy.comboCounted = true;
                    comboCount++;
                    comboTimer = COMBO_TIMEOUT;
                    
                    // Combo milestone notifications
                    if (comboCount === 5) {
                        showNotification('üî• 5x COMBO!', 2000);
                    } else if (comboCount === 10) {
                        showNotification('‚ö° 10x MEGA COMBO!', 2000);
                        screenShake = 10;
                    } else if (comboCount === 20) {
                        showNotification('üí• 20x ULTRA COMBO!', 2000);
                        screenShake = 15;
                    } else if (comboCount === 50) {
                        showNotification('üëë 50x LEGENDARY COMBO!', 3000);
                        screenShake = 20;
                    }
                }
            });
            
            enemies = enemies.filter(e => e.health > 0);
            
            // √ús saldƒ±rƒ±sƒ± (Level 3+)
            if (base && base.level >= 3) {
                if (base.attackCooldown <= 0) {
                    // En yakƒ±n d√º≈ümanƒ± bul
                    let nearestEnemy = null;
                    let nearestDist = base.attackRange;
                    
                    enemies.forEach(enemy => {
                        const dx = enemy.x - base.x;
                        const dy = enemy.y - base.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        base.attackCooldown = 60;
                        const angle = Math.atan2(nearestEnemy.y - base.y, nearestEnemy.x - base.x);
                        
                        // √ús ate≈üi (level'e g√∂re farklƒ±)
                        const baseDamage = 15 + base.level * 5;
                        const baseColor = base.level === 5 ? '#ffd700' : '#60a5fa';
                        
                        // Muzzle flash
                        createMuzzleFlash(base.x, base.y, angle, baseColor, 25 + base.level * 5);
                        
                        projectiles.push({
                            x: base.x,
                            y: base.y,
                            vx: Math.cos(angle) * 8,
                            vy: Math.sin(angle) * 8,
                            damage: baseDamage,
                            size: 10,
                            color: base.level === 5 ? '#ffd700' : '#60a5fa',
                            life: 100,
                            targetBase: false,
                            fromBase: true
                        });
                    }
                }
                base.attackCooldown--;
            }
            
            // Yapƒ± AI'larƒ±
            buildings.forEach((building, index) => {
                if (building.type === 'tower') {
                    // Kule saldƒ±rƒ±sƒ±
                    if (building.attackCooldown <= 0) {
                        const towerRange = 300 + building.level * 50;
                        let nearestEnemy = null;
                        let nearestDist = towerRange;
                        
                        enemies.forEach(enemy => {
                            const dx = enemy.x - building.x;
                            const dy = enemy.y - building.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestEnemy = enemy;
                            }
                        });
                        
                        if (nearestEnemy) {
                            // Base cooldown with synergy bonus
                            const baseCooldown = 180 - building.level * 20; // Level 1: 3s, Level 5: 2s
                            const attackSpeedMultiplier = 1 + building.attackSpeedBonus;
                            building.attackCooldown = baseCooldown / attackSpeedMultiplier;
                            
                            const angle = Math.atan2(nearestEnemy.y - building.y, nearestEnemy.x - building.x);
                            
                            const towerColors = ['#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#fbbf24'];
                            const baseDamage = 8 + building.level * 4;
                            const towerDamage = baseDamage * (1 + building.damageBonus); // Apply damage synergy
                            const towerColor = towerColors[building.level - 1] || '#f59e0b';
                            
                            // Muzzle flash (bigger if synergized)
                            const flashSize = (20 + building.level * 3) * (building.synergizedWith.length > 0 ? 1.3 : 1);
                            createMuzzleFlash(building.x, building.y, angle, towerColor, flashSize);
                            
                            projectiles.push({
                                x: building.x,
                                y: building.y,
                                vx: Math.cos(angle) * 10,
                                vy: Math.sin(angle) * 10,
                                damage: towerDamage,
                                size: 8 + building.level,
                                color: towerColors[building.level - 1] || '#f59e0b',
                                life: 120,
                                targetBase: false,
                                fromTower: true,
                                synergized: building.synergizedWith.length > 0 // For visual effect
                            });
                        }
                    }
                    building.attackCooldown--;
                    
                } else if (building.type === 'farm') {
                    // √áiftlik XP √ºretimi
                    building.xpTimer++;
                    const xpInterval = 60 / (1 + building.xpBonus); // Synergy speeds up XP generation
                    if (building.xpTimer >= xpInterval) {
                        const xpAmount = (5 * building.level) * (1 + building.xpBonus); // Synergy boosts XP amount
                        player.xp += xpAmount;
                        building.xpTimer = 0;
                        
                        // XP par√ßacƒ±ƒüƒ± (bigger if synergized)
                        particles.push({
                            x: building.x,
                            y: building.y - 20,
                            vx: 0,
                            vy: -2,
                            life: 40,
                            color: building.synergizedWith.length > 0 ? '#00ff00' : '#fbbf24',
                            text: '+' + (5 * building.level) + ' XP'
                        });
                    }
                }
                
                // BARRACKS - Soldier spawn
                if (building.type === 'barracks') {
                    if (!building.spawnCooldown) building.spawnCooldown = 0;
                    
                    if (building.spawnCooldown <= 0 && enemies.length > 0) {
                        building.spawnCooldown = BUILDING_TYPES.barracks.spawnInterval;
                        
                        // Spawn soldier
                        soldiers.push({
                            x: building.x + (Math.random() - 0.5) * 40,
                            y: building.y + (Math.random() - 0.5) * 40,
                            size: wave >= 12 ? 25 : 20, // Bigger after wave 12
                            health: BUILDING_TYPES.barracks.soldierHealth,
                            maxHealth: BUILDING_TYPES.barracks.soldierHealth,
                            damage: BUILDING_TYPES.barracks.soldierDamage,
                            speed: wave >= 12 ? 3.5 : BUILDING_TYPES.barracks.soldierSpeed,
                            target: null,
                            attackCooldown: 0,
                            lightsaberAngle: 0,
                            lightsaberColor: ['#00ff00', '#0088ff', '#ff00ff', '#ffdd00'][Math.floor(Math.random() * 4)],
                            lifetime: 900, // 15 saniye (60 fps)
                            maxLifetime: 900,
                            elite: wave >= 12 // Elite Jedi after wave 12
                        });
                        
                        // Weekly challenge tracking
                        updateChallengeProgress('soldiers', 1);
                        
                        // Spawn effect
                        createLevelUpEffect(building.x, building.y);
                    }
                    building.spawnCooldown--;
                }
            });
            
            // Yƒ±kƒ±lan yapƒ±larƒ± temizle
            buildings = buildings.filter(b => b.health > 0);
            
            // SOLDIER AI (Jedi warriors)
            soldiers.forEach((soldier, index) => {
                // Lifetime countdown
                soldier.lifetime--;
                
                // Target bulma
                if (!soldier.target || soldier.target.health <= 0) {
                    // En yakƒ±n d√º≈ümanƒ± bul
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    
                    enemies.forEach(enemy => {
                        const dx = enemy.x - soldier.x;
                        const dy = enemy.y - soldier.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    soldier.target = nearestEnemy;
                }
                
                // Hedef varsa hareket et ve saldƒ±r
                if (soldier.target) {
                    const dx = soldier.target.x - soldier.x;
                    const dy = soldier.target.y - soldier.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Lightsaber a√ßƒ±sƒ±nƒ± hedef y√∂n√ºnde tut
                    soldier.lightsaberAngle = Math.atan2(dy, dx);
                    
                    if (dist > 50) {
                        // Hareket et
                        const moveAngle = Math.atan2(dy, dx);
                        soldier.x += Math.cos(moveAngle) * soldier.speed;
                        soldier.y += Math.sin(moveAngle) * soldier.speed;
                    } else {
                        // Saldƒ±r (lightsaber swing)
                        if (soldier.attackCooldown <= 0) {
                            soldier.attackCooldown = 30; // 0.5 saniye
                            
                            // Hasar ver
                            soldier.target.health -= soldier.damage;
                            
                            // Lightsaber swing effect
                            for (let i = 0; i < 5; i++) {
                                const angle = soldier.lightsaberAngle + (Math.random() - 0.5) * 0.5;
                                particles.push({
                                    x: soldier.x + Math.cos(angle) * 30,
                                    y: soldier.y + Math.sin(angle) * 30,
                                    vx: Math.cos(angle) * 3,
                                    vy: Math.sin(angle) * 3,
                                    life: 15,
                                    color: soldier.lightsaberColor,
                                    size: 8
                                });
                            }
                        }
                        soldier.attackCooldown--;
                    }
                }
                
                // Arena sƒ±nƒ±rlarƒ±
                soldier.x = Math.max(20, Math.min(ARENA_SIZE - 20, soldier.x));
                soldier.y = Math.max(20, Math.min(ARENA_SIZE - 20, soldier.y));
            });
            
            // √ñlen ve s√ºresi dolan askerleri temizle
            soldiers = soldiers.filter(s => s.health > 0 && s.lifetime > 0);
            
            // Mermiler
            projectiles.forEach(proj => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;
                
                // TRAIL EFEKTƒ∞ (her 2 frame'de bir)
                if (proj.life % 2 === 0 && proj.fromPlayer) {
                    createTrailParticle(proj.x, proj.y, proj.color, proj.vx, proj.vy);
                }
                
                if (proj.targetBase && base) {
                    // √ússe √ßarpma kontrol√º
                    const dx = proj.x - base.x;
                    const dy = proj.y - base.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < base.size + proj.size) {
                        base.health -= proj.damage;
                        proj.life = 0;
                        createParticles(proj.x, proj.y, proj.color, 8);
                    }
                } else if (proj.fromTower) {
                    // Kule mermisi - d√º≈ümanlara hasar
                    enemies.forEach(enemy => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.size + proj.size && proj.life > 0) {
                            let damage = proj.damage;
                            
                            // Apply Power Boost perk (+10% damage)
                            if (hasPerk('perk_damage')) {
                                damage *= 1.10;
                            }
                            
                            enemy.health -= damage;
                            proj.life = 0;
                            createParticles(proj.x, proj.y, proj.color, 8);
                            
                            // Hasar g√∂stergesi
                            particles.push({
                                x: enemy.x,
                                y: enemy.y - 30,
                                vx: 0,
                                vy: -2,
                                life: 40,
                                color: '#ffffff',
                                text: '-' + proj.damage
                            });
                            
                            if (enemy.health <= 0) {
                                score += enemy.scoreValue;
                                kills++;
                                player.xp += enemy.xpValue;
                                createParticles(enemy.x, enemy.y, enemy.color, 20);
                                upgradeWeapon();
                            }
                        }
                    });
                } else if (proj.fromBase) {
                    // √ús mermisi - d√º≈ümanlara hasar
                    enemies.forEach(enemy => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.size + proj.size && proj.life > 0) {
                            let damage = proj.damage;
                            
                            // Apply Power Boost perk (+10% damage)
                            if (hasPerk('perk_damage')) {
                                damage *= 1.10;
                            }
                            
                            enemy.health -= damage;
                            proj.life = 0;
                            createParticles(proj.x, proj.y, proj.color, 10);
                            
                            // Hasar g√∂stergesi
                            particles.push({
                                x: enemy.x,
                                y: enemy.y - 30,
                                vx: 0,
                                vy: -2,
                                life: 40,
                                color: '#60a5fa',
                                text: '-' + proj.damage
                            });
                            
                            if (enemy.health <= 0) {
                                score += enemy.scoreValue;
                                kills++;
                                player.xp += enemy.xpValue;
                                createParticles(enemy.x, enemy.y, enemy.color, 20);
                                upgradeWeapon();
                            }
                        }
                    });
                } else if (proj.fromPlayer) {
                    // Oyuncu mermisi (yay, plazma topu) - d√º≈ümanlara hasar
                    
                    // MINI BOSS COLLISION
                    if (miniBoss && miniBoss.health > 0 && proj.life > 0) {
                        const dx = proj.x - miniBoss.x;
                        const dy = proj.y - miniBoss.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < miniBoss.size + proj.size) {
                            let damage = proj.damage;
                            
                            // Apply Power Boost perk
                            if (hasPerk('perk_damage')) {
                                damage *= 1.10;
                            }
                            
                            miniBoss.health -= damage;
                            
                            if (!proj.piercing) {
                                proj.life = 0;
                            }
                            
                            createParticles(proj.x, proj.y, '#ff00ff', 15);
                            
                            // Hasar g√∂stergesi
                            particles.push({
                                x: miniBoss.x,
                                y: miniBoss.y - 40,
                                vx: 0,
                                vy: -2,
                                life: 40,
                                color: '#ff00ff',
                                text: '-' + Math.floor(damage)
                            });
                            
                            // Mini boss √∂ld√º
                            if (miniBoss.health <= 0) {
                                let goldReward = miniBoss.scoreValue;
                                
                                // Apply Wealth perk (+25% gold)
                                if (hasPerk('perk_goldbonus')) {
                                    goldReward = Math.floor(goldReward * 1.25);
                                }
                                
                                score += miniBoss.scoreValue;
                                gold += goldReward;
                                document.getElementById('goldDisplay').textContent = gold;
                                
                                createParticles(miniBoss.x, miniBoss.y, '#ff00ff', 50);
                                screenShake = 30;
                                
                                showNotification(`üíÄ ${miniBoss.name} DEFEATED!\n+${miniBoss.scoreValue} Gold`, 4000);
                                
                                miniBoss = null;
                            }
                        }
                    }
                    
                    // Regular enemies
                    enemies.forEach(enemy => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.size + proj.size && proj.life > 0) {
                            let damage = proj.damage;
                            
                            // Kalkan varsa hasar azalt
                            if (enemy.shieldActive && enemy.shieldActive > 0) {
                                damage *= 0.3;
                            }
                            
                            // Apply Power Boost perk (+10% damage)
                            if (hasPerk('perk_damage')) {
                                damage *= 1.10;
                            }
                            
                            enemy.health -= damage;
                            
                            // Pierce yoksa mermi yok olur
                            if (!proj.piercing) {
                                proj.life = 0;
                            }
                            
                            createParticles(proj.x, proj.y, proj.color, 10);
                            
                            // Hasar g√∂stergesi
                            particles.push({
                                x: enemy.x,
                                y: enemy.y - 30,
                                vx: 0,
                                vy: -2,
                                life: 40,
                                color: enemy.shieldActive ? '#60a5fa' : '#ffffff',
                                text: '-' + Math.floor(damage)
                            });
                            
                            if (enemy.health <= 0) {
                                console.log('üíÄ PLAYER PROJECTILE KILL! Weapon:', player.weapon.name, 'Type:', player.weapon.type, 'Score:', enemy.scoreValue);
                                
                                score += enemy.scoreValue;
                                kills++;
                                
                                // Calculate XP with bonus
                                let xpGain = enemy.xpValue;
                                if (hasPerk('perk_xpbonus')) {
                                    xpGain = Math.floor(xpGain * 1.30); // +30% XP
                                }
                                player.xp += xpGain;
                                
                                createParticles(enemy.x, enemy.y, enemy.color, 20);
                                
                                // GOLD DROP (same as melee)
                                const goldAmount = Math.floor(5 + Math.random() * 10); // 5-15 gold
                                let goldMultiplier = activePowerUps.goldRush > 0 ? 
                                    POWERUP_TYPES.goldRush.multiplier : 
                                    (currentEvent && currentEvent.type === 'goldRush' ? currentEvent.goldMultiplier : 1);
                                
                                // Apply Wealth perk (+25% gold)
                                if (hasPerk('perk_goldbonus')) {
                                    goldMultiplier *= 1.25;
                                }
                                
                                gold += Math.floor(goldAmount * goldMultiplier);
                                document.getElementById('goldDisplay').textContent = gold;
                                
                                // Gold particle effect
                                for (let i = 0; i < 5; i++) {
                                    particles.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        vx: (Math.random() - 0.5) * 5,
                                        vy: -5 - Math.random() * 3,
                                        life: 40,
                                        color: '#ffd700',
                                        size: 4,
                                        text: 'üí∞'
                                    });
                                }
                                
                                // POWER-UP DROP (5% chance)
                                if (Math.random() < 0.05) {
                                    spawnPowerUp(enemy.x, enemy.y);
                                }
                                
                                // Plazma topu patlama
                                if (player.weapon.ability === 'explosion') {
                                    enemies.forEach(nearEnemy => {
                                        const edx = nearEnemy.x - enemy.x;
                                        const edy = nearEnemy.y - enemy.y;
                                        const edist = Math.sqrt(edx * edx + edy * edy);
                                        
                                        if (edist < 150 && nearEnemy !== enemy) {
                                            nearEnemy.health -= 50;
                                            createParticles(nearEnemy.x, nearEnemy.y, '#06b6d4', 10);
                                        }
                                    });
                                    
                                    screenShake = 10;
                                    
                                    // Patlama efekti
                                    for (let i = 0; i < 30; i++) {
                                        particles.push({
                                            x: enemy.x,
                                            y: enemy.y,
                                            vx: Math.cos(i / 30 * Math.PI * 2) * 10,
                                            vy: Math.sin(i / 30 * Math.PI * 2) * 10,
                                            life: 40,
                                            color: '#06b6d4',
                                            size: 5
                                        });
                                    }
                                }
                                
                                upgradeWeapon();
                            }
                        }
                    });
                } else {
                    // Oyuncuya √ßarpma kontrol√º
                    const dx = proj.x - player.x;
                    const dy = proj.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < player.size + proj.size) {
                        player.health -= proj.damage;
                        proj.life = 0;
                        createParticles(proj.x, proj.y, proj.color, 8);
                    }
                }
            });
            projectiles = projectiles.filter(p => p.life > 0);
            
            // Tehlikeler (spike'lar)
            hazards.forEach(hazard => {
                if (hazard.timer > 0) {
                    hazard.timer--;
                    if (hazard.timer <= 30) {
                        hazard.warningTimer--;
                    }
                } else {
                    hazard.active = true;
                    
                    // Oyuncuya hasar
                    const dx = hazard.x - player.x;
                    const dy = hazard.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < hazard.size + player.size) {
                        player.health -= hazard.damage * 0.5;
                    }
                }
            });
            
            // MINI-BOSS AI
            if (miniBoss && miniBoss.health > 0) {
                const dx = player.x - miniBoss.x;
                const dy = player.y - miniBoss.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Movement
                if (dist > 100) {
                    let moveSpeed = miniBoss.speed;
                    
                    // BERSERKER: Rage mode (speed boost below 50% HP)
                    if (miniBoss.type === 'berserker' && miniBoss.health < miniBoss.maxHealth * 0.5) {
                        moveSpeed *= 2.0;
                        miniBoss.rageActive = true;
                    }
                    
                    miniBoss.x += (dx / dist) * moveSpeed;
                    miniBoss.y += (dy / dist) * moveSpeed;
                }
                
                // SHIELDER: Aura Shield (give shield to nearby enemies)
                if (miniBoss.type === 'shielder') {
                    enemies.forEach(enemy => {
                        const edx = enemy.x - miniBoss.x;
                        const edy = enemy.y - miniBoss.y;
                        const edist = Math.sqrt(edx * edx + edy * edy);
                        
                        if (edist < miniBoss.abilityRange) {
                            enemy.shieldActive = 60; // 1 second shield
                        }
                    });
                    
                    // Teleport ability
                    if (miniBoss.teleportCooldown <= 0) {
                        miniBoss.teleportCooldown = 300;
                        
                        // Teleport to random location near player
                        const angle = Math.random() * Math.PI * 2;
                        const teleportDist = 200 + Math.random() * 100;
                        miniBoss.x = player.x + Math.cos(angle) * teleportDist;
                        miniBoss.y = player.y + Math.sin(angle) * teleportDist;
                        
                        // Keep in bounds
                        miniBoss.x = Math.max(50, Math.min(ARENA_SIZE - 50, miniBoss.x));
                        miniBoss.y = Math.max(50, Math.min(ARENA_SIZE - 50, miniBoss.y));
                        
                        // Teleport effect
                        createLevelUpEffect(miniBoss.x, miniBoss.y);
                        screenShake = 10;
                    }
                    miniBoss.teleportCooldown--;
                }
                
                // SUMMONER: Spawn minions
                if (miniBoss.type === 'summoner') {
                    if (miniBoss.summonCooldown <= 0 && miniBoss.currentSummons < miniBoss.maxSummons) {
                        miniBoss.summonCooldown = 240; // 4 seconds
                        miniBoss.currentSummons++;
                        
                        // Spawn small enemy
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDist = 60;
                        
                        enemies.push({
                            x: miniBoss.x + Math.cos(angle) * spawnDist,
                            y: miniBoss.y + Math.sin(angle) * spawnDist,
                            size: 15,
                            health: 30,
                            maxHealth: 30,
                            speed: 2.5,
                            damage: 10,
                            color: '#c084fc',
                            name: 'Summoned',
                            scoreValue: 20,
                            xpValue: 5,
                            isSummoned: true,
                            summoner: miniBoss
                        });
                        
                        createLevelUpEffect(miniBoss.x + Math.cos(angle) * spawnDist, miniBoss.y + Math.sin(angle) * spawnDist);
                    }
                    miniBoss.summonCooldown--;
                }
                
                // BERSERKER: Area damage when enraged
                if (miniBoss.type === 'berserker' && miniBoss.rageActive) {
                    if (dist < miniBoss.size + player.size + 100) {
                        // Area attack
                        if (!miniBoss.lastAreaAttack || Date.now() - miniBoss.lastAreaAttack > 2000) {
                            miniBoss.lastAreaAttack = Date.now();
                            
                            // Damage player if close
                            if (dist < 150) {
                                player.health -= miniBoss.areaDamage;
                                screenShake = 15;
                            }
                            
                            // Visual effect - shockwave
                            for (let i = 0; i < 30; i++) {
                                const angle = (i / 30) * Math.PI * 2;
                                particles.push({
                                    x: miniBoss.x,
                                    y: miniBoss.y,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    life: 20,
                                    color: '#ef4444',
                                    size: 6
                                });
                            }
                        }
                    }
                }
                
                // Contact damage
                if (dist < miniBoss.size + player.size) {
                    player.health -= miniBoss.damage * 0.1;
                }
                
                // Check if killed
                if (miniBoss.health <= 0) {
                    score += miniBoss.scoreValue;
                    gold += miniBoss.scoreValue;
                    player.xp += 200;
                    
                    // Epic death effect
                    for (let i = 0; i < 50; i++) {
                        particles.push({
                            x: miniBoss.x,
                            y: miniBoss.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 60,
                            color: miniBoss.color,
                            size: 8
                        });
                    }
                    
                    screenShake = 30;
                    showNotification(`üíÄ ${miniBoss.name} DEFEATED!\n+${miniBoss.scoreValue} Gold`, 4000);
                    
                    // Remove summoned enemies
                    if (miniBoss.type === 'summoner') {
                        enemies = enemies.filter(e => !e.isSummoned);
                    }
                    
                    miniBoss = null;
                    upgradeWeapon();
                }
            }
            
            // Boss AI
            if (boss) {
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Boss hareketi
                if (dist > 150) {
                    boss.x += (dx / dist) * boss.speed;
                    boss.y += (dy / dist) * boss.speed;
                }
                
                // Boss saldƒ±rƒ±larƒ±
                if (boss.attackCooldown <= 0) {
                    boss.attackCooldown = 60;
                    
                    // Dairesel mermi atƒ±≈üƒ±
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        projectiles.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            damage: 20,
                            size: 12,
                            color: '#dc2626',
                            life: 150
                        });
                    }
                }
                boss.attackCooldown--;
                
                // Boss'a yakƒ±n mesafe hasarƒ±
                if (dist < boss.size + player.size + 20) {
                    player.health -= boss.damage * 0.05;
                }
            }
            
            // Par√ßacƒ±klar (geli≈ütirilmi≈ü fizik)
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                
                // Gravity efekti
                if (p.gravity) {
                    p.vy += p.gravity;
                }
                
                // Alpha fade
                if (p.fadeRate && p.alpha !== undefined) {
                    p.alpha -= p.fadeRate;
                    if (p.alpha < 0) p.alpha = 0;
                }
                
                p.life--;
            });
            particles = particles.filter(p => p.life > 0);
            
            // Ambient particles update
            spawnAmbientParticles();
            ambientParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.rotate !== undefined) {
                    p.rotate += p.rotateSpeed;
                }
            });
            ambientParticles = ambientParticles.filter(p => p.life > 0);
            
            // Wave sistemi - Yeni mantƒ±k
            // Wave arasƒ± bekleme (ONLY when not paused)
            if (waveTransition && gameState === 'playing') {
                waveStartDelay--;
                if (waveStartDelay <= 0) {
                    waveTransition = false;
                    waveEnemiesRemaining = 0; // Reset
                }
            }
            
            if (gameState === 'playing') {
                // Wave ba≈ülangƒ±cƒ±
                if (!waveActive && !waveTransition) {
                    waveActive = true;
                    waveTransition = false;
                    
                    const composition = getWaveComposition(wave);
                    waveEnemiesRemaining = 0;
                    
                    // D√º≈üman sayƒ±sƒ±nƒ± hesapla
                    Object.values(composition).forEach(count => {
                        waveEnemiesRemaining += count;
                    });
                    
                    // D√º≈ümanlarƒ± spawn et
                    let spawnDelay = 0;
                    Object.keys(composition).forEach(type => {
                        const count = composition[type];
                        
                        for (let i = 0; i < count; i++) {
                            setTimeout(() => {
                                if (gameState === 'playing' && waveActive) {
                                    spawnEnemyOfType(ENEMY_TYPES[type]);
                                }
                            }, spawnDelay);
                            spawnDelay += 200; // Reduced from 500ms to 200ms for faster spawns
                        }
                    });
                    
                    showNotification(t('waveStart', wave, waveEnemiesRemaining), 3000);
                    
                    // MINI-BOSS SPAWN (Wave 5, 15, 25)
                    if (MINI_BOSS_WAVES.includes(wave)) {
                        setTimeout(() => {
                            spawnMiniBoss(wave);
                        }, 2000);
                    }
                }
                
                // T√ºm d√º≈ümanlar √∂l√ºnce sonraki wave (PAUSE CHECK ADDED)
                if (waveActive && enemies.length === 0 && waveEnemiesRemaining === 0 && gameState === 'playing') {
                    waveActive = false;
                    waveTransition = true;
                    waveStartDelay = 180;
                    
                    showNotification(t('waveCleared', wave, wave * 10), 3000);
                    player.xp += wave * 10;
                    
                    wave++;
                    document.getElementById('wave').textContent = wave;
                    
                    // MUTATION SYSTEM - Every 10 waves
                    if (wave % 10 === 1 && wave > 1) {
                        mutationLevel++;
                        calculateMutations();
                        
                        setTimeout(() => {
                            showDramaticAnnouncement(
                                'üß¨ MUTATION DETECTED!',
                                `Enemies evolved to Level ${mutationLevel}\n+${Math.round(enemyHPMultiplier * 100 - 100)}% HP | +${Math.round(enemySpeedMultiplier * 100 - 100)}% Speed`,
                                'üß¨',
                                '#ff00ff',
                                2000
                            );
                            screenShake = 40;
                        }, 2000);
                    }
                    
                    // INTERSTITIAL AD - Every 10 waves
                    if (wave > 1 && wave % 10 === 1) {
                        setTimeout(() => {
                            showInterstitialAd();
                        }, 1000);
                    }
                    
                    // ABILITY UNLOCK (Wave 4)
                    if (wave === 4 && !abilityUnlocked) {
                        abilityUnlocked = true;
                        const treeData = WEAPON_TREES[selectedWeaponTree];
                        const abilityDisplayName = currentLanguage === 'en' ? treeData.abilityName : treeData.abilityNameTr;
                        const abilityDisplayDesc = currentLanguage === 'en' ? treeData.abilityDesc : treeData.abilityDescTr;
                        setTimeout(() => {
                            showNotification(`‚ö° ABILITY UNLOCKED!\n${abilityDisplayName}\n${abilityDisplayDesc}`, 5000);
                            createLevelUpEffect(player.x, player.y);
                            screenShake = 20;
                        }, 2000);
                    }
                    
                    // Animasyon efekti
                    document.getElementById('wave').style.transform = 'scale(1.3)';
                    setTimeout(() => {
                        document.getElementById('wave').style.transform = 'scale(1)';
                    }, 300);
                    
                    // WAVE MODIFIER (Her 5 dalgada)
                    if (WAVE_MODIFIERS[wave]) {
                        const modifier = WAVE_MODIFIERS[wave];
                        setTimeout(() => {
                            showDramaticAnnouncement(
                                modifier.name,
                                modifier.description,
                                modifier.icon,
                                modifier.color,
                                2000
                            );
                            activeModifier = modifier;
                            modifierDuration = modifier.duration;
                            screenShake = 30;
                        }, 1500);
                    }
                    
                    // COSMETIC UNLOCKS
                    // Trail unlocks
                    Object.entries(COSMETICS.trails).forEach(([key, trail]) => {
                        if (trail.unlockWave === wave && !unlockedCosmetics.trails.includes(key)) {
                            unlockedCosmetics.trails.push(key);
                            setTimeout(() => {
                                showNotification(`üé® NEW TRAIL UNLOCKED!\n${trail.name}`, 4000);
                                createLevelUpEffect(player.x, player.y);
                            }, 3000);
                        }
                    });
                    
                    // Skin unlocks (wave-based)
                    Object.entries(COSMETICS.skins).forEach(([key, skin]) => {
                        if (skin.unlockWave === wave && !unlockedCosmetics.skins.includes(key)) {
                            unlockedCosmetics.skins.push(key);
                            setTimeout(() => {
                                showNotification(`üé® NEW SKIN UNLOCKED!\n${skin.name}`, 4000);
                                createLevelUpEffect(player.x, player.y);
                            }, 3500);
                        }
                        // Kill-based unlocks
                        if (skin.unlockKills && score >= skin.unlockKills && !unlockedCosmetics.skins.includes(key)) {
                            unlockedCosmetics.skins.push(key);
                            showNotification(`üé® NEW SKIN UNLOCKED!\n${skin.name}\n(${skin.unlockKills} kills!)`, 4000);
                            createLevelUpEffect(player.x, player.y);
                        }
                    });
                    
                    // MAƒûAZA A√á (Her 2 dalgada bir)
                    if (wave % 2 === 0) {
                        setTimeout(() => openShop(), 1000);
                    }
                    
                    // RANDOM EVENT (Her 3 dalgada bir, %50 ≈üans)
                    if (wave % 3 === 0 && Math.random() < 0.5) {
                        setTimeout(() => startRandomEvent(), 2000);
                    }
                    
                    // Her 5 dalgada bir tehlike spawn
                    if (wave % 5 === 0) {
                        spawnHazards();
                    }
                    
                    // Her 10 dalgada bir boss spawn
                    if (wave % 10 === 0 && !boss) {
                        spawnBoss();
                    }
                }
            }
            
            // √ús y√ºkseltme kontrol√º
            if (base && gameState === 'playing') {
                const dx = player.x - base.x;
                const dy = player.y - base.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Oyuncu √ºsse yakƒ±nsa ve y√ºkseltme m√ºsaitse
                if (dist < base.size + player.size + 30) {
                    baseUpgradeAvailable = true;
                    
                    // E tu≈üuna basƒ±lƒ±rsa y√ºkselt (Her 4 levelda bir)
                    if ((keys['e'] || keys['E']) && player.level >= base.level * 4 && base.level < 5) {
                        base.level++;
                        const newLevel = BASE_LEVELS[base.level];
                        
                        base.maxHealth = newLevel.maxHealth;
                        base.health = newLevel.maxHealth; // Tam can ile y√ºkselt
                        base.size = newLevel.size;
                        base.color = newLevel.color;
                        
                        // Y√ºkseltme efekti
                        for (let i = 0; i < 50; i++) {
                            particles.push({
                                x: base.x,
                                y: base.y,
                                vx: (Math.random() - 0.5) * 15,
                                vy: (Math.random() - 0.5) * 15,
                                life: 60,
                                color: newLevel.color
                            });
                        }
                        
                        const levelNames = ['', 'Temel √ús', 'Geli≈ümi≈ü √ús', 'Kale', 'Karakol', 'üëë MEGA KALE'];
                        showNotification(`üè∞ √úS LEVEL ${base.level}!\n${levelNames[base.level]}`, 4000);
                        
                        // Level 2'de Barracks unlock
                        if (base.level === 2) {
                            document.getElementById('barracksButton').style.display = 'block';
                            setTimeout(() => {
                                showNotification(`‚öîÔ∏è BARRACKS UNLOCKED!\nSpawn Jedi soldiers!`, 4000);
                            }, 1000);
                        }
                        
                        // Level 3+ saldƒ±rƒ± yeteneƒüi kazanƒ±r
                        if (base.level >= 3) {
                            base.attackRange = 250 + base.level * 50;
                            if (base.level === 3) {
                                showNotification('‚ö° √úS SAVUNMA Sƒ∞STEMƒ∞ AKTƒ∞F!\nD√º≈ümanlara ate≈ü edecek', 3000);
                            }
                        }
                        
                        // Yapƒ±larƒ± da y√ºkselt
                        buildings.forEach(building => {
                            if (building.type === 'tower') {
                                building.level = base.level;
                            }
                        });
                        
                        keys['e'] = false;
                        keys['E'] = false;
                    }
                } else {
                    baseUpgradeAvailable = false;
                }
            }
            
            // Dalga sistemi
            if (kills >= wave * 10) {
                wave++;
                document.getElementById('wave').textContent = wave;
                // Animasyon efekti
                document.getElementById('wave').style.transform = 'scale(1.3)';
                setTimeout(() => {
                    document.getElementById('wave').style.transform = 'scale(1)';
                }, 300);
                
                // Her 5 dalgada bir tehlike spawn
                if (wave % 5 === 0) {
                    spawnHazards();
                }
                
                // BOSS RUSH MODE veya normal boss spawn
                if (bossRushMode) {
                    // Boss Rush: Her dalgada boss!
                    if (!boss) {
                        spawnBoss();
                        showNotification('üëπ BOSS INCOMING!', 2000);
                    }
                } else {
                    // Normal: Her 10 dalgada bir boss spawn
                    if (wave % 10 === 0 && !boss) {
                        spawnBoss();
                    }
                }
            }
            
            // Level sistemi
            checkLevelUp();
            
            // UI g√ºncelle
            const scoreElement = document.getElementById('scoreValue');
            if (scoreElement.textContent !== score.toString()) {
                scoreElement.textContent = score;
            }
            
            // Level progress bar
            const progressPercent = (player.xp / player.xpToNextLevel) * 100;
            document.getElementById('levelProgressFill').style.width = progressPercent + '%';
            document.getElementById('levelProgressText').textContent = `${player.xp} / ${player.xpToNextLevel} XP`;
            
            document.getElementById('healthFill').style.width = (player.health / player.maxHealth * 100) + '%';
            
            // √ús yƒ±kƒ±ldƒ± mƒ±?
            if (base && base.health <= 0 && gameState !== 'gameover') {
                showGameOver('üè∞ √úS YIKILDI!');
            }
            
            // √ús canƒ± yava≈ü√ßa dolar (her 2 saniyede 1 can)
            if (base && base.health < base.maxHealth) {
                if (!base.regenTimer) base.regenTimer = 0;
                base.regenTimer++;
                
                // Her 120 frame'de (2 saniye) 1 can
                if (base.regenTimer >= 120) {
                    base.health += 1;
                    base.regenTimer = 0;
                    
                    if (base.health > base.maxHealth) {
                        base.health = base.maxHealth;
                    }
                }
            }
            
            // Power-up g√ºncelleme
            powerUps.forEach((powerUp, index) => {
                powerUp.lifetime--;
                powerUp.pulse = Math.sin(Date.now() / 200) * 5;
                
                if (powerUp.lifetime <= 0) {
                    powerUps.splice(index, 1);
                    return;
                }
                
                // Oyuncu toplama kontrol√º
                const dx = powerUp.x - player.x;
                const dy = powerUp.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + powerUp.size) {
                    collectPowerUp(powerUp);
                }
            });
            
            // Aktif power-up'larƒ± g√ºncelle
            let needsDisplayUpdate = false;
            for (let type in activePowerUps) {
                if (activePowerUps[type] > 0) {
                    activePowerUps[type]--;
                    needsDisplayUpdate = true;
                    
                    // Shield efekti
                    if (type === 'shield' && activePowerUps[type] > 0) {
                        // Her 10 frame'de bir shield par√ßacƒ±ƒüƒ±
                        if (activePowerUps[type] % 10 === 0) {
                            const angle = Math.random() * Math.PI * 2;
                            particles.push({
                                x: player.x + Math.cos(angle) * 50,
                                y: player.y + Math.sin(angle) * 50,
                                vx: 0,
                                vy: -1,
                                life: 20,
                                color: '#4444ff',
                                size: 6
                            });
                        }
                    }
                }
            }
            
            if (needsDisplayUpdate && Date.now() % 60 === 0) {
                updatePowerUpDisplay();
            }
            
            // Player speed power-up uygula
            if (activePowerUps.speed > 0) {
                player.speed = player.baseSpeed * POWERUP_TYPES.speed.multiplier;
            } else {
                player.speed = player.baseSpeed;
                if (player.weapon && player.weapon.ability === 'speed_boost') {
                    player.speed = player.baseSpeed * 1.2;
                }
            }
            
            // Random event g√ºncelle
            if (currentEvent) {
                currentEvent.timer++;
                
                // Lightning storm
                if (currentEvent.type === 'lightning' && currentEvent.timer % currentEvent.tickRate === 0) {
                    enemies.forEach(enemy => {
                        enemy.health -= currentEvent.damagePerTick;
                        
                        // Lightning efekti
                        particles.push({
                            x: enemy.x,
                            y: enemy.y - 50,
                            vx: 0,
                            vy: 10,
                            life: 10,
                            color: '#ffff00',
                            size: 8
                        });
                    });
                }
                
                // Meteor shower
                if (currentEvent.type === 'meteorShower' && currentEvent.timer % currentEvent.meteorInterval === 0) {
                    const x = player.x + (Math.random() - 0.5) * 800;
                    const y = player.y + (Math.random() - 0.5) * 800;
                    
                    // Meteor efekti
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x,
                            y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 30,
                            color: '#ff4500',
                            size: 8
                        });
                    }
                    
                    // Meteor hasarƒ±
                    enemies.forEach(enemy => {
                        const dx = enemy.x - x;
                        const dy = enemy.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 100) {
                            enemy.health -= 100;
                        }
                    });
                }
                
                // Event s√ºresi bitti
                if (currentEvent.duration > 0 && currentEvent.timer >= currentEvent.duration) {
                    currentEvent = null;
                }
            }
            
            // Oyuncu √∂ld√º m√º?
            if (player.health <= 0 && gameState !== 'gameover') {
                // Check for revive (from ad reward)
                if (player.hasRevive) {
                    player.hasRevive = false;
                    player.health = player.maxHealth;
                    player.invincible = 180; // 3 seconds invincibility
                    
                    // Epic revive effect
                    createLevelUpEffect(player.x, player.y);
                    for (let i = 0; i < 50; i++) {
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10,
                            life: 60,
                            color: '#00ff88',
                            size: 8
                        });
                    }
                    
                    screenShake = 30;
                    showNotification('üíö SECOND CHANCE!\nYou have been revived!', 4000);
                } else {
                    showGameOver('üíÄ √ñLD√úN√úZ!');
                }
            }
        }
        
        function draw() {
            // Kamera takibi
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            
            // Ekran sarsƒ±ntƒ±sƒ± efekti
            if (screenShake > 0) {
                camera.x += (Math.random() - 0.5) * screenShake;
                camera.y += (Math.random() - 0.5) * screenShake;
                screenShake *= 0.9;
                if (screenShake < 0.5) screenShake = 0;
            }
            
            // BIOME BACKGROUND
            const biome = BIOMES[currentBiome] || BIOMES['proxima']; // Fallback
            ctx.fillStyle = biome.groundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Sky overlay
            ctx.fillStyle = biome.skyColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Arena √ßizgisi (futuristik glow)
            ctx.strokeStyle = biome.accentColor;
            ctx.lineWidth = 3;
            ctx.shadowColor = biome.accentColor;
            ctx.shadowBlur = 10;
            ctx.strokeRect(-camera.x, -camera.y, ARENA_SIZE, ARENA_SIZE);
            ctx.shadowBlur = 0;
            
            // Grid (futuristik neon grid) - Yarƒ± saydam
            ctx.lineWidth = 2;
            
            // Ana grid √ßizgileri - Neon glow ile (DAHA SAYDAM)
            for (let i = 0; i < ARENA_SIZE; i += 100) {
                // Dikey √ßizgiler
                ctx.globalAlpha = 0.35; // Daha saydam (√∂nceki 0.7)
                ctx.strokeStyle = biome.accentColor;
                ctx.shadowColor = biome.accentColor;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.moveTo(i - camera.x, -camera.y);
                ctx.lineTo(i - camera.x, ARENA_SIZE - camera.y);
                ctx.stroke();
                
                // Yatay √ßizgiler
                ctx.beginPath();
                ctx.moveTo(-camera.x, i - camera.y);
                ctx.lineTo(ARENA_SIZE - camera.x, i - camera.y);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Grid intersection glow (her 200 birimde bir)
                if (i % 200 === 0) {
                    ctx.globalAlpha = 0.6; // Kesi≈üimler biraz daha belirgin
                    ctx.fillStyle = biome.accentColor;
                    ctx.shadowColor = biome.accentColor;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(i - camera.x, i - camera.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ring around intersection
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = biome.accentColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(i - camera.x, i - camera.y, 11, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            ctx.globalAlpha = 1;
            
            // Animated scan lines (iki y√∂nl√º - vertikal ve horizontal)
            const scanLineY = ((Date.now() / 30) % ARENA_SIZE);
            const scanLineX = ((Date.now() / 25) % ARENA_SIZE);
            
            // Vertical scan line
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = biome.accentColor;
            ctx.shadowColor = biome.accentColor;
            ctx.shadowBlur = 10;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-camera.x, scanLineY - camera.y);
            ctx.lineTo(ARENA_SIZE - camera.x, scanLineY - camera.y);
            ctx.stroke();
            
            // Horizontal scan line
            ctx.beginPath();
            ctx.moveTo(scanLineX - camera.x, -camera.y);
            ctx.lineTo(scanLineX - camera.x, ARENA_SIZE - camera.y);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // AMBIENT PARTICLES (background layer)
            ambientParticles.forEach(p => {
                const px = p.x - camera.x;
                const py = p.y - camera.y;
                
                // Twinkle efekti (yƒ±ldƒ±zlar i√ßin)
                if (p.twinkle) {
                    const alpha = 0.3 + Math.sin(Date.now() * 0.01 + p.x) * 0.3;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.rotate !== undefined) {
                    // Rotating ice crystals
                    ctx.globalAlpha = p.life / 200;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(p.rotate);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                    ctx.restore();
                } else {
                    // Normal particles (dust)
                    ctx.globalAlpha = p.life / 180;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(px - p.size/2, py - p.size/2, p.size, p.size);
                }
            });
            ctx.globalAlpha = 1;
            
            // Harita dekorasyonlarƒ± (aƒüa√ßlar, kayalar, vs)
            drawMapDecorations();
            
            // Dekorasyonlar
            decorations.forEach(deco => {
                if (deco.destroyed) return;
                
                const dx = deco.x - camera.x;
                const dy = deco.y - camera.y;
                
                if (deco.type === 'crystal') {
                    // Kristal
                    const pulse = Math.sin(Date.now() / 500 + deco.x) * 2;
                    
                    ctx.save();
                    ctx.translate(dx, dy);
                    ctx.rotate(deco.rotation);
                    
                    // Parlama
                    ctx.shadowColor = deco.color;
                    ctx.shadowBlur = 15 + pulse;
                    
                    ctx.fillStyle = deco.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -deco.size);
                    ctx.lineTo(deco.size * 0.3, 0);
                    ctx.lineTo(0, deco.size);
                    ctx.lineTo(-deco.size * 0.3, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ƒ∞√ß parlaklƒ±k
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.moveTo(0, -deco.size * 0.6);
                    ctx.lineTo(deco.size * 0.15, 0);
                    ctx.lineTo(0, deco.size * 0.6);
                    ctx.lineTo(-deco.size * 0.15, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                } else if (deco.type === 'pillar') {
                    // Antik s√ºtun
                    ctx.fillStyle = '#78716c';
                    
                    // G√∂lge
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(dx - deco.size/2 + 5, dy + deco.size/2, deco.size, 10);
                    
                    // Ana s√ºtun
                    const gradient = ctx.createLinearGradient(dx - deco.size/2, 0, dx + deco.size/2, 0);
                    gradient.addColorStop(0, '#57534e');
                    gradient.addColorStop(0.5, '#78716c');
                    gradient.addColorStop(1, '#57534e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(dx - deco.size/2, dy - deco.height/2, deco.size, deco.height);
                    
                    // √úst kƒ±sƒ±m (ba≈ülƒ±k)
                    ctx.fillStyle = '#a8a29e';
                    ctx.fillRect(dx - deco.size/2 - 5, dy - deco.height/2 - 5, deco.size + 10, 8);
                    
                    // Alt kƒ±sƒ±m (taban)
                    ctx.fillStyle = '#a8a29e';
                    ctx.fillRect(dx - deco.size/2 - 5, dy + deco.height/2 - 3, deco.size + 10, 8);
                    
                    // √áatlaklar
                    ctx.strokeStyle = '#44403c';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(dx, dy - deco.height/4);
                    ctx.lineTo(dx + 5, dy);
                    ctx.stroke();
                    
                } else if (deco.type === 'rock') {
                    // Kaya
                    ctx.fillStyle = '#57534e';
                    
                    // G√∂lge
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(dx, dy + deco.size * 0.3, deco.size * 0.9, deco.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ana kaya - d√ºzensiz ≈üekil
                    const sides = 6 + Math.floor(deco.size / 10);
                    ctx.fillStyle = '#78716c';
                    ctx.beginPath();
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const variation = 0.8 + Math.sin(i * 2.3) * 0.3;
                        const x = dx + Math.cos(angle) * deco.size * variation;
                        const y = dy + Math.sin(angle) * deco.size * variation * 0.8;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Highlight
                    ctx.fillStyle = '#a8a29e';
                    ctx.beginPath();
                    ctx.ellipse(dx - deco.size * 0.3, dy - deco.size * 0.2, deco.size * 0.3, deco.size * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Par√ßacƒ±klar (geli≈ütirilmi≈ü)
            particles.forEach(p => {
                if (p.text) {
                    // Hasar sayƒ±sƒ±
                    ctx.fillStyle = p.color;
                    ctx.font = 'bold 20px Arial';
                    ctx.globalAlpha = p.life / 40;
                    ctx.fillText(p.text, p.x - camera.x, p.y - camera.y);
                } else {
                    // Alpha hesaplama
                    let alpha = p.life / 30;
                    if (p.alpha !== undefined) {
                        alpha = p.alpha;
                    }
                    
                    // Boyut hesaplama
                    let size = p.size || (4 + (30 - p.life) / 10);
                    if (p.expand) {
                        size += (30 - p.life) * p.expand;
                    }
                    
                    ctx.globalAlpha = alpha;
                    
                    // Sparkle efekti (yƒ±ldƒ±z parƒ±ltƒ±sƒ±)
                    if (p.sparkle) {
                        ctx.fillStyle = p.color;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 10;
                        
                        // Yƒ±ldƒ±z ≈üekli
                        ctx.save();
                        ctx.translate(p.x - camera.x, p.y - camera.y);
                        ctx.rotate(p.life * 0.1);
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                            const radius = i % 2 === 0 ? size : size / 2;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        ctx.shadowBlur = 0;
                    } else {
                        // Normal par√ßacƒ±k
                        ctx.fillStyle = p.color;
                        ctx.fillRect(
                            p.x - camera.x - size/2, 
                            p.y - camera.y - size/2, 
                            size, size
                        );
                    }
                }
            });
            ctx.globalAlpha = 1;
            
            // Muzzle flash'ler (ate≈ü efektleri)
            muzzleFlashes.forEach(flash => {
                const fx = flash.x - camera.x;
                const fy = flash.y - camera.y;
                const alpha = flash.life / flash.maxLife;
                
                ctx.save();
                ctx.translate(fx, fy);
                ctx.rotate(flash.angle);
                
                // Ana parlama
                ctx.globalAlpha = alpha * 0.8;
                ctx.fillStyle = flash.color;
                ctx.shadowColor = flash.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(flash.size * 2, -flash.size * 0.6);
                ctx.lineTo(flash.size * 1.5, 0);
                ctx.lineTo(flash.size * 2, flash.size * 0.6);
                ctx.closePath();
                ctx.fill();
                
                // ƒ∞√ß parlama (beyaz)
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(flash.size * 1.2, -flash.size * 0.4);
                ctx.lineTo(flash.size * 0.8, 0);
                ctx.lineTo(flash.size * 1.2, flash.size * 0.4);
                ctx.closePath();
                ctx.fill();
                
                // Parƒ±ltƒ± dairesi
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillStyle = flash.color;
                ctx.beginPath();
                ctx.arc(0, 0, flash.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            ctx.globalAlpha = 1;
            
            // Mermiler
            projectiles.forEach(proj => {
                const px = proj.x - camera.x;
                const py = proj.y - camera.y;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CUSTOM WEAPON SKIN PROJECTILES
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                let customRendered = false;
                
                if (proj.weaponSkin) {
                    
                    // RED LASER (üî¥) - Continuous red beam
                    if (proj.weaponSkin === 'weapon_laser') {
                        customRendered = true;
                        const angle = Math.atan2(proj.vy, proj.vx);
                        const beamLength = 30;
                        const beamEnd = {
                            x: px + Math.cos(angle) * beamLength,
                            y: py + Math.sin(angle) * beamLength
                        };
                        
                        ctx.save();
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 15;
                        
                        // Outer glow
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.lineWidth = 12;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(beamEnd.x, beamEnd.y);
                        ctx.stroke();
                        
                        // Main beam
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(beamEnd.x, beamEnd.y);
                        ctx.stroke();
                        
                        // Core
                        ctx.strokeStyle = '#ffaaaa';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(beamEnd.x, beamEnd.y);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                    
                    // ARC CANNON (‚ö°) - Lightning bolt
                    else if (proj.weaponSkin === 'weapon_lightning') {
                        customRendered = true;
                        ctx.save();
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 20;
                        
                        // Lightning segments
                        const angle = Math.atan2(proj.vy, proj.vx);
                        const segments = 5;
                        const segmentLength = 8;
                        let currentX = px;
                        let currentY = py;
                        
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(currentX, currentY);
                        
                        for (let i = 0; i < segments; i++) {
                            const randomOffset = (Math.random() - 0.5) * 10;
                            const perpAngle = angle + Math.PI / 2;
                            currentX += Math.cos(angle) * segmentLength;
                            currentY += Math.sin(angle) * segmentLength;
                            currentX += Math.cos(perpAngle) * randomOffset;
                            currentY += Math.sin(perpAngle) * randomOffset;
                            
                            ctx.lineTo(currentX, currentY);
                        }
                        ctx.stroke();
                        
                        // White core
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Electric sparks
                        for (let i = 0; i < 3; i++) {
                            const sparkX = px + Math.cos(angle) * i * 10 + (Math.random() - 0.5) * 15;
                            const sparkY = py + Math.sin(angle) * i * 10 + (Math.random() - 0.5) * 15;
                            const sparkSize = 2 + Math.random() * 3;
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                    
                    // CRYO BLASTER (‚ùÑÔ∏è) - Ice shard
                    else if (proj.weaponSkin === 'weapon_frost') {
                        customRendered = true;
                        ctx.save();
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 15;
                        
                        const angle = Math.atan2(proj.vy, proj.vx);
                        
                        // Ice shard shape
                        const points = 6;
                        const innerRadius = proj.size * 0.6;
                        const outerRadius = proj.size * 1.5;
                        
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, outerRadius);
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.5, '#00ffff');
                        gradient.addColorStop(1, '#0099ff');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        
                        for (let i = 0; i < points; i++) {
                            const a = angle + (i / points) * Math.PI * 2;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const x = px + Math.cos(a) * radius;
                            const y = py + Math.sin(a) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ice crystals
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(px - 4, py);
                        ctx.lineTo(px + 4, py);
                        ctx.moveTo(px, py - 4);
                        ctx.lineTo(px, py + 4);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                    
                    // PRISMATIC RAY (üåà) - Rainbow orb
                    else if (proj.weaponSkin === 'weapon_rainbow') {
                        customRendered = true;
                        ctx.save();
                        
                        const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                        const time = Date.now() / 100;
                        const colorIndex = Math.floor(time) % rainbowColors.length;
                        const nextIndex = (colorIndex + 1) % rainbowColors.length;
                        const t = time % 1;
                        
                        // Outer rainbow glow (rotating)
                        for (let i = 0; i < rainbowColors.length; i++) {
                            const angle = (i / rainbowColors.length) * Math.PI * 2 + time;
                            const glowX = px + Math.cos(angle) * proj.size * 2;
                            const glowY = py + Math.sin(angle) * proj.size * 2;
                            
                            ctx.fillStyle = rainbowColors[i] + '40';
                            ctx.beginPath();
                            ctx.arc(glowX, glowY, proj.size * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Main orb with color transition
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, proj.size);
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.5, rainbowColors[colorIndex]);
                        gradient.addColorStop(1, rainbowColors[nextIndex]);
                        
                        ctx.fillStyle = gradient;
                        ctx.shadowColor = rainbowColors[colorIndex];
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(px, py, proj.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    // CELESTIAL BEAM (‚ú®) - Golden star
                    else if (proj.weaponSkin === 'weapon_celestial') {
                        customRendered = true;
                        ctx.save();
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 20;
                        
                        const time = Date.now() / 100;
                        const rotation = time;
                        
                        // Golden outer glow
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                        ctx.beginPath();
                        ctx.arc(px, py, proj.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 8-pointed star
                        const points = 8;
                        const outerRadius = proj.size * 1.5;
                        const innerRadius = proj.size * 0.7;
                        
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, outerRadius);
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.5, '#ffd700');
                        gradient.addColorStop(1, '#ffed4e');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        
                        for (let i = 0; i < points * 2; i++) {
                            const angle = rotation + (i / (points * 2)) * Math.PI * 2;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const x = px + Math.cos(angle) * radius;
                            const y = py + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    // SHADOW REAPER (üåë) - Dark void orb
                    else if (proj.weaponSkin === 'weapon_shadow') {
                        customRendered = true;
                        ctx.save();
                        ctx.shadowColor = '#8b00ff';
                        ctx.shadowBlur = 25;
                        
                        // Dark void outer ring
                        ctx.fillStyle = 'rgba(138, 0, 255, 0.4)';
                        ctx.beginPath();
                        ctx.arc(px, py, proj.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Main dark orb
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, proj.size);
                        gradient.addColorStop(0, '#000000');
                        gradient.addColorStop(0.5, '#4b0082');
                        gradient.addColorStop(1, '#8b00ff');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, proj.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Purple energy wisps
                        const time = Date.now() / 100;
                        for (let i = 0; i < 3; i++) {
                            const angle = time + (i / 3) * Math.PI * 2;
                            const wispX = px + Math.cos(angle) * proj.size * 1.5;
                            const wispY = py + Math.sin(angle) * proj.size * 1.5;
                            
                            ctx.fillStyle = 'rgba(138, 43, 226, 0.6)';
                            ctx.beginPath();
                            ctx.arc(wispX, wispY, proj.size * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                }
                
                // DEFAULT PROJECTILE RENDERING (if not custom)
                if (!customRendered) {
                
                // ƒ∞z efekti (trail)
                if (proj.fromTower || proj.fromBase) {
                    const trailLength = 5;
                    for (let i = 0; i < trailLength; i++) {
                        const trailAlpha = (1 - i / trailLength) * 0.5;
                        const trailSize = proj.size * (1 - i / trailLength * 0.5);
                        const trailX = px - (proj.vx / Math.abs(proj.vx + proj.vy)) * i * 5;
                        const trailY = py - (proj.vy / Math.abs(proj.vx + proj.vy)) * i * 5;
                        
                        ctx.globalAlpha = trailAlpha;
                        ctx.fillStyle = proj.color;
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                if (proj.laser) {
                    // Laser beam - geli≈ümi≈ü
                    ctx.shadowColor = proj.color;
                    ctx.shadowBlur = 15;
                    
                    // Dƒ±≈ü aura
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(px, py, proj.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Orta halka
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(px, py, proj.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ƒ∞√ß √ßekirdek
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(px, py, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                } else {
                    // Normal mermi - geli≈ümi≈ü
                    ctx.shadowColor = proj.color;
                    ctx.shadowBlur = 10;
                    
                    // Dƒ±≈ü parlaklƒ±k
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(px, py, proj.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ana mermi
                    ctx.globalAlpha = 1;
                    const gradient = ctx.createRadialGradient(px - proj.size * 0.3, py - proj.size * 0.3, 0, px, py, proj.size);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, proj.color);
                    gradient.addColorStop(1, proj.color + '80');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(px, py, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
                
                } // END customRendered check
            });
            
            // Hazards (spike'lar)
            hazards.forEach(hazard => {
                const hx = hazard.x - camera.x;
                const hy = hazard.y - camera.y;
                
                if (!hazard.active && hazard.timer <= 30) {
                    // Uyarƒ±
                    ctx.strokeStyle = 'rgba(255, 0, 0, ' + (1 - hazard.warningTimer / 30) + ')';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(hx, hy, hazard.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(hx, hy, hazard.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (hazard.active) {
                    // Aktif spike
                    ctx.fillStyle = '#dc2626';
                    ctx.shadowColor = '#dc2626';
                    ctx.shadowBlur = 10;
                    
                    // Spike ≈üekli
                    ctx.beginPath();
                    ctx.moveTo(hx, hy - hazard.size);
                    ctx.lineTo(hx + hazard.size * 0.3, hy + hazard.size * 0.5);
                    ctx.lineTo(hx - hazard.size * 0.3, hy + hazard.size * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(hx - hazard.size * 0.7, hy - hazard.size * 0.3);
                    ctx.lineTo(hx, hy + hazard.size * 0.8);
                    ctx.lineTo(hx - hazard.size * 0.3, hy);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(hx + hazard.size * 0.7, hy - hazard.size * 0.3);
                    ctx.lineTo(hx, hy + hazard.size * 0.8);
                    ctx.lineTo(hx + hazard.size * 0.3, hy);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            });
            
            // D√º≈ümanlar
            enemies.forEach(enemy => {
                const ex = enemy.x - camera.x;
                const ey = enemy.y - camera.y;
                const renderSize = enemy.size * enemySizeMod; // Apply modifier
                
                // G√∂lge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(ex, ey + renderSize, renderSize * 0.8, renderSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (enemy.name === 'Scout Drone') {
                    // Scout Drone - k√º√ß√ºk ke≈üif dronu
                    const time = Date.now() / 1000;
                    const hover = Math.sin(time * 3 + enemy.x) * 3;
                    
                    ctx.save();
                    ctx.translate(ex, ey + hover);
                    
                    // Ana g√∂vde
                    const bodyGradient = ctx.createRadialGradient(0, -3, 0, 0, 0, enemy.size);
                    bodyGradient.addColorStop(0, '#22d3ee');
                    bodyGradient.addColorStop(0.7, '#06b6d4');
                    bodyGradient.addColorStop(1, '#0891b2');
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pervaneler/rotor
                    ctx.strokeStyle = '#67e8f9';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    const rotorAngle = time * 10;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + rotorAngle;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * enemy.size * 1.2, Math.sin(angle) * enemy.size * 1.2);
                        ctx.stroke();
                    }
                    
                    // Merkez sens√∂r
                    ctx.fillStyle = '#0e7490';
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Tarayƒ±cƒ± ƒ±≈üƒ±k
                    const scanGlow = 0.5 + Math.sin(time * 5) * 0.5;
                    ctx.fillStyle = `rgba(34, 211, 238, ${scanGlow})`;
                    ctx.shadowColor = '#22d3ee';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // LED ƒ±≈üƒ±klar
                    ctx.fillStyle = '#67e8f9';
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * enemy.size * 0.6, Math.sin(angle) * enemy.size * 0.6, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                } else if (enemy.name === 'Combat Bot') {
                    // Combat Bot - sava≈ü robotu
                    const time = Date.now() / 1000;
                    
                    // G√∂vde
                    const bodyGradient = ctx.createLinearGradient(ex, ey - enemy.size, ex, ey + enemy.size);
                    bodyGradient.addColorStop(0, '#fbbf24');
                    bodyGradient.addColorStop(0.5, '#f59e0b');
                    bodyGradient.addColorStop(1, '#d97706');
                    ctx.fillStyle = bodyGradient;
                    ctx.fillRect(ex - enemy.size * 0.7, ey - enemy.size * 0.8, enemy.size * 1.4, enemy.size * 1.6);
                    
                    // Omuz silahlar
                    ctx.fillStyle = '#78716c';
                    ctx.fillRect(ex - enemy.size - 5, ey - enemy.size * 0.5, 10, 15);
                    ctx.fillRect(ex + enemy.size - 5, ey - enemy.size * 0.5, 10, 15);
                    
                    // Silah u√ßlarƒ±
                    ctx.fillStyle = '#dc2626';
                    ctx.beginPath();
                    ctx.arc(ex - enemy.size, ey - enemy.size * 0.4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ex + enemy.size, ey - enemy.size * 0.4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Kafa
                    ctx.fillStyle = '#292524';
                    ctx.fillRect(ex - enemy.size * 0.5, ey - enemy.size - 5, enemy.size, enemy.size * 0.6);
                    
                    // Visor/g√∂z
                    ctx.fillStyle = '#ef4444';
                    ctx.shadowColor = '#ef4444';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(ex - enemy.size * 0.4, ey - enemy.size * 0.7, enemy.size * 0.8, 6);
                    ctx.shadowBlur = 0;
                    
                    // Parlayan nokta
                    const eyeScan = (time * 3 + enemy.x) % 1;
                    ctx.fillStyle = '#fca5a5';
                    ctx.beginPath();
                    ctx.arc(ex - enemy.size * 0.4 + eyeScan * enemy.size * 0.8, ey - enemy.size * 0.7 + 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Zƒ±rh √ßizgileri
                    ctx.strokeStyle = '#44403c';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(ex - enemy.size * 0.6, ey);
                    ctx.lineTo(ex + enemy.size * 0.6, ey);
                    ctx.stroke();
                    
                    // Enerji g√∂stergesi
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(ex - enemy.size * 0.3, ey + enemy.size * 0.3);
                    ctx.lineTo(ex, ey + enemy.size * 0.5);
                    ctx.lineTo(ex + enemy.size * 0.3, ey + enemy.size * 0.3);
                    ctx.stroke();
                    
                } else if (enemy.name === 'Heavy Mech') {
                    // Heavy Mech - aƒüƒ±r sava≈ü makineasƒ±
                    const time = Date.now() / 1000;
                    
                    // Ana g√∂vde - tanksƒ±
                    const bodyGradient = ctx.createRadialGradient(ex, ey - 5, 0, ex, ey, enemy.size * 1.2);
                    bodyGradient.addColorStop(0, '#f87171');
                    bodyGradient.addColorStop(0.6, '#ef4444');
                    bodyGradient.addColorStop(1, '#991b1b');
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Zƒ±rh plakalarƒ±
                    ctx.strokeStyle = '#7c2d12';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size - 3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Turret/kule
                    ctx.fillStyle = '#450a0a';
                    ctx.beginPath();
                    ctx.arc(ex, ey - 8, enemy.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // B√ºy√ºk top
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    ctx.save();
                    ctx.translate(ex, ey - 8);
                    ctx.rotate(angle);
                    ctx.fillStyle = '#292524';
                    ctx.fillRect(0, -4, enemy.size, 8);
                    ctx.fillStyle = '#dc2626';
                    ctx.shadowColor = '#dc2626';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(enemy.size, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Paletler
                    ctx.fillStyle = '#57534e';
                    ctx.fillRect(ex - enemy.size - 5, ey + enemy.size * 0.5, enemy.size * 2 + 10, 8);
                    
                    // Egzoz dumanƒ±
                    if (Math.random() > 0.8) {
                        particles.push({
                            x: enemy.x - enemy.size,
                            y: enemy.y + enemy.size * 0.5,
                            vx: -2,
                            vy: -1,
                            life: 30,
                            color: '#78716c'
                        });
                    }
                    
                    // Uyarƒ± ƒ±≈üƒ±klarƒ±
                    const blink = Math.floor(time * 4) % 2;
                    if (blink === 0) {
                        ctx.fillStyle = '#fbbf24';
                        ctx.shadowColor = '#fbbf24';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(ex - enemy.size * 0.5, ey - 15, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(ex + enemy.size * 0.5, ey - 15, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                } else if (enemy.name === 'Elite Unit') {
                    // Elite Unit - geli≈ümi≈ü sava≈ü √ºnitesi
                    const time = Date.now() / 1000;
                    const energyPulse = Math.sin(time * 4) * 3;
                    
                    // Enerji kalkanƒ±
                    ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#8b5cf6';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size + 10 + energyPulse, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size + 15 + energyPulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Ana g√∂vde
                    const bodyGradient = ctx.createRadialGradient(ex, ey - 10, 0, ex, ey, enemy.size);
                    bodyGradient.addColorStop(0, '#c084fc');
                    bodyGradient.addColorStop(0.5, '#8b5cf6');
                    bodyGradient.addColorStop(1, '#6d28d9');
                    ctx.fillStyle = bodyGradient;
                    
                    // Hexagon ≈üekli
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                        const x = ex + Math.cos(angle) * enemy.size;
                        const y = ey + Math.sin(angle) * enemy.size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Merkez √ßekirdek
                    ctx.fillStyle = '#1e1b4b';
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Parlayan √ßekirdek
                    ctx.fillStyle = '#e0e7ff';
                    ctx.shadowColor = '#c084fc';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // D√∂nen enerji halkalarƒ±
                    ctx.strokeStyle = '#a78bfa';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const ringAngle = time * (2 + i) + i * Math.PI / 3;
                        ctx.beginPath();
                        ctx.arc(ex + Math.cos(ringAngle) * enemy.size * 0.7, 
                               ey + Math.sin(ringAngle) * enemy.size * 0.7, 
                               5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Enerji ƒ±≈üƒ±nlarƒ±
                    const beamCount = 6;
                    for (let i = 0; i < beamCount; i++) {
                        const angle = (i / beamCount) * Math.PI * 2 + time * 2;
                        const beamLength = enemy.size + 10;
                        ctx.strokeStyle = `rgba(167, 139, 250, ${0.3 + Math.sin(time * 3 + i) * 0.3})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ex, ey);
                        ctx.lineTo(ex + Math.cos(angle) * beamLength, ey + Math.sin(angle) * beamLength);
                        ctx.stroke();
                    }
                    
                    // Enerji par√ßacƒ±klarƒ±
                    if (Math.random() > 0.6) {
                        particles.push({
                            x: enemy.x + (Math.random() - 0.5) * 50,
                            y: enemy.y + (Math.random() - 0.5) * 50,
                            vx: 0,
                            vy: -2,
                            life: 40,
                            color: '#a78bfa'
                        });
                    }
                }
                
                // Can barƒ±
                const barWidth = enemy.size * 2.5;
                const barHeight = 6;
                const barY = ey - enemy.size - 20;
                
                // Can barƒ± arka plan
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(ex - barWidth/2 - 1, barY - 1, barWidth + 2, barHeight + 2);
                
                // Can barƒ± √ßer√ßeve
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(ex - barWidth/2, barY, barWidth, barHeight);
                
                // Can barƒ± dolgu
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(ex - barWidth/2, barY, barWidth, barHeight);
                
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
                ctx.fillRect(ex - barWidth/2, barY, barWidth * healthPercent, barHeight);
                
                // Kalkan g√∂stergesi (Tank i√ßin)
                if (enemy.shieldActive && enemy.shieldActive > 0) {
                    ctx.strokeStyle = '#60a5fa';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#60a5fa';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // "SHIELD" yazƒ±sƒ±
                    ctx.fillStyle = '#60a5fa';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('SHIELD', ex, barY - 10);
                    ctx.textAlign = 'left';
                }
                
                // Sprint g√∂stergesi (Runner i√ßin)
                if (enemy.sprintActive && enemy.sprintActive > 0) {
                    const sprintTrailCount = 3;
                    for (let i = 0; i < sprintTrailCount; i++) {
                        ctx.globalAlpha = 0.3 - i * 0.1;
                        ctx.fillStyle = enemy.color;
                        ctx.beginPath();
                        ctx.arc(ex - i * 10, ey, enemy.size * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // THREAT INDICATOR
                if (showThreatIndicators && enemy.threatLevel) {
                    const threatColor = getThreatColor(enemy.threatLevel);
                    ctx.strokeStyle = threatColor;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(ex, ey - enemy.size - 15, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = threatColor;
                    ctx.fill();
                    
                    // Threat level number
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(enemy.threatLevel, ex, ey - enemy.size - 15);
                    ctx.globalAlpha = 1;
                }
                
                // PRIORITY TARGET HIGHLIGHT
                if (currentPriorityTarget === enemy) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Arrow above target
                    ctx.fillStyle = '#ff00ff';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ñº', ex, ey - enemy.size - 35);
                }
                
                // MUTATION VISUAL
                if (enemy.mutated && enemy.mutationLevel > 0) {
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    
                    // Mutation aura (purple glow)
                    ctx.save();
                    ctx.globalAlpha = 0.3 * pulse;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20 + enemy.mutationLevel * 5;
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ex, ey, enemy.size + 5 + pulse * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                    
                    // Mutation level badge
                    if (enemy.mutationLevel >= 3) {
                        ctx.save();
                        ctx.fillStyle = '#ff00ff';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ff00ff';
                        ctx.shadowBlur = 10;
                        ctx.fillText('üß¨', ex + enemy.size + 10, ey - enemy.size);
                        ctx.restore();
                    }
                }
            });
            
            // √ús
            if (base) {
                const bx = base.x - camera.x;
                const by = base.y - camera.y;
                const time = Date.now() / 1000;
                
                // G√∂lge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(bx, by + base.size, base.size * 1.2, base.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Enerji kalkanƒ± (d√º≈ü√ºk canda kƒ±rmƒ±zƒ±)
                const healthPercent = base.health / base.maxHealth;
                const shieldColor = healthPercent > 0.5 ? base.color : healthPercent > 0.25 ? '#ffa500' : '#ff0000';
                const pulse = Math.sin(time * 2) * 3;
                
                ctx.strokeStyle = shieldColor + '40';
                ctx.lineWidth = 4 + base.level;
                ctx.shadowColor = shieldColor;
                ctx.shadowBlur = 15 + pulse + base.level * 2;
                ctx.beginPath();
                ctx.arc(bx, by, base.size + 10 + pulse, 0, Math.PI * 2);
                ctx.stroke();
                
                // Level 3+ i√ßin ikinci kalkan katmanƒ±
                if (base.level >= 3) {
                    ctx.beginPath();
                    ctx.arc(bx, by, base.size + 20 + pulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                
                // Ana yapƒ± - futuristik √ºs
                const baseGradient = ctx.createRadialGradient(bx, by - 10, 0, bx, by, base.size);
                if (base.level === 5) {
                    baseGradient.addColorStop(0, '#fef08a');
                    baseGradient.addColorStop(0.5, '#fbbf24');
                    baseGradient.addColorStop(1, '#f59e0b');
                } else {
                    baseGradient.addColorStop(0, '#bfdbfe');
                    baseGradient.addColorStop(0.5, base.color);
                    baseGradient.addColorStop(1, base.level >= 3 ? '#1e3a8a' : '#1e40af');
                }
                ctx.fillStyle = baseGradient;
                
                // Hexagon ≈üekli (level 4+ i√ßin octagon)
                const sides = base.level >= 4 ? 8 : 6;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const x = bx + Math.cos(angle) * base.size;
                    const y = by + Math.sin(angle) * base.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Zƒ±rh √ßizgileri (daha fazla level = daha fazla √ßizgi)
                ctx.strokeStyle = base.level === 5 ? '#92400e' : '#1e3a8a';
                ctx.lineWidth = 4;
                for (let i = 0; i < base.level + 1; i++) {
                    ctx.beginPath();
                    for (let j = 0; j < sides; j++) {
                        const angle = (j / sides) * Math.PI * 2 - Math.PI / 2;
                        const radius = base.size - i * 12;
                        const x = bx + Math.cos(angle) * radius;
                        const y = by + Math.sin(angle) * radius;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                // Merkez √ßekirdek
                ctx.fillStyle = base.level === 5 ? '#92400e' : '#1e3a8a';
                ctx.beginPath();
                ctx.arc(bx, by, base.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                // Parlayan √ßekirdek (level 5'te daha parlak)
                ctx.fillStyle = shieldColor;
                ctx.shadowColor = shieldColor;
                ctx.shadowBlur = 20 + base.level * 5;
                ctx.beginPath();
                ctx.arc(bx, by, base.size * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // D√∂nen enerji noktalarƒ± (daha fazla level = daha fazla nokta)
                const orbCount = 4 + base.level;
                for (let i = 0; i < orbCount; i++) {
                    const angle = (i / orbCount) * Math.PI * 2 + time * (1 + base.level * 0.2);
                    const orbX = bx + Math.cos(angle) * (base.size * 0.75);
                    const orbY = by + Math.sin(angle) * (base.size * 0.75);
                    
                    ctx.fillStyle = shieldColor;
                    ctx.shadowColor = shieldColor;
                    ctx.shadowBlur = 10 + base.level * 2;
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, 4 + base.level, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // Level yazƒ±sƒ± (√ºstte)
                const levelY = by - base.size - 50;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bx - 50, levelY - 25, 100, 30);
                
                ctx.strokeStyle = base.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(bx - 50, levelY - 25, 100, 30);
                
                ctx.fillStyle = base.level === 5 ? '#ffd700' : '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${base.level}`, bx, levelY - 5);
                
                // Can barƒ± (level yazƒ±sƒ±nƒ±n altƒ±nda)
                const barWidth = base.size * 2.5;
                const barHeight = 12;
                const barY = levelY + 10;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(bx - barWidth/2 - 2, barY - 2, barWidth + 4, barHeight + 4);
                
                ctx.strokeStyle = base.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(bx - barWidth/2, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#1e3a8a';
                ctx.fillRect(bx - barWidth/2, barY, barWidth, barHeight);
                
                const healthGradient = ctx.createLinearGradient(bx - barWidth/2, 0, bx + barWidth/2, 0);
                healthGradient.addColorStop(0, shieldColor);
                healthGradient.addColorStop(1, healthPercent > 0.5 ? '#00ffdd' : healthPercent > 0.25 ? '#ffcc00' : '#ff6666');
                ctx.fillStyle = healthGradient;
                ctx.fillRect(bx - barWidth/2, barY, barWidth * healthPercent, barHeight);
                
                // Can miktarƒ±
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px Arial';
                ctx.fillText(`${Math.floor(base.health)}/${base.maxHealth}`, bx, barY + 9);
                ctx.textAlign = 'left';
                
                // Upgrade butonu (oyuncu yakƒ±nsa ve upgrade m√ºsaitse)
                if (baseUpgradeAvailable && player.level >= base.level * 4 && base.level < 5) {
                    const buttonY = by + base.size + 30;
                    const buttonWidth = 140;
                    const buttonHeight = 40;
                    
                    // Parlayan buton
                    const glowSize = Math.sin(time * 5) * 3;
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 15 + glowSize;
                    ctx.fillRect(bx - buttonWidth/2, buttonY, buttonWidth, buttonHeight);
                    ctx.shadowBlur = 0;
                    
                    ctx.strokeStyle = '#00ffdd';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(bx - buttonWidth/2, buttonY, buttonWidth, buttonHeight);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚¨ÜÔ∏è Y√úKSELT', bx, buttonY + 18);
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText('(E)', bx, buttonY + 32);
                    ctx.textAlign = 'left';
                } else if (baseUpgradeAvailable && base.level < 5) {
                    // Hen√ºz yeterli level deƒüil
                    const buttonY = by + base.size + 30;
                    ctx.fillStyle = '#666666';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Level ${base.level * 4} Gerekli`, bx, buttonY + 15);
                    ctx.textAlign = 'left';
                } else if (baseUpgradeAvailable && base.level >= 5) {
                    // Max level
                    const buttonY = by + base.size + 30;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üëë MAX LEVEL', bx, buttonY + 15);
                    ctx.textAlign = 'left';
                }
            }
            
            // Draw synergy connections FIRST (so they're behind buildings)
            drawBuildingSynergies();
            
            // Yapƒ±lar
            buildings.forEach(building => {
                const bx = building.x - camera.x;
                const by = building.y - camera.y;
                const time = Date.now() / 1000;
                
                if (building.type === 'tower') {
                    // Kule - √ústten bakƒ±≈ü tasarƒ±mƒ±
                    const towerColors = ['#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#fbbf24'];
                    const towerColor = towerColors[building.level - 1] || '#f59e0b';
                    
                    // G√∂lge
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(bx, by + 5, building.size * 0.9, building.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Kule platformu (ta≈ü zemin)
                    ctx.fillStyle = '#78716c';
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#57534e';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size - 3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Ana kule g√∂vdesi (daire)
                    const gradient = ctx.createRadialGradient(bx - 5, by - 5, 0, bx, by, building.size * 0.7);
                    gradient.addColorStop(0, towerColor);
                    gradient.addColorStop(1, towerColor + '80');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Zƒ±rh halkalarƒ± (level sayƒ±sƒ± kadar)
                    ctx.strokeStyle = towerColor;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < building.level; i++) {
                        ctx.beginPath();
                        ctx.arc(bx, by, building.size * 0.7 - i * 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // D√∂nen top (en yakƒ±n d√º≈ümana bakƒ±yor)
                    let turretAngle = 0;
                    const towerRange = 300 + building.level * 50;
                    let nearestEnemy = null;
                    let nearestDist = towerRange;
                    
                    enemies.forEach(enemy => {
                        const dx = enemy.x - building.x;
                        const dy = enemy.y - building.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = enemy;
                        }
                    });
                    
                    if (nearestEnemy) {
                        turretAngle = Math.atan2(nearestEnemy.y - building.y, nearestEnemy.x - building.x);
                    }
                    
                    // Top namlular (level arttƒ±k√ßa daha fazla)
                    const barrelCount = Math.min(building.level, 3);
                    for (let i = 0; i < barrelCount; i++) {
                        ctx.save();
                        ctx.translate(bx, by);
                        ctx.rotate(turretAngle + (i - (barrelCount-1)/2) * 0.2);
                        
                        // Namlu
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(building.size * 0.3, -4, building.size * 0.4, 8);
                        
                        // Namlu ucu parƒ±ltƒ±sƒ±
                        if (building.attackCooldown > 170) {
                            ctx.fillStyle = towerColor;
                            ctx.shadowColor = towerColor;
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(building.size * 0.7, 0, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.restore();
                    }
                    
                    // Merkez d√∂nen platform
                    ctx.fillStyle = '#334155';
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#1e293b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Merkez enerji √ßekirdeƒüi
                    ctx.fillStyle = towerColor;
                    ctx.shadowColor = towerColor;
                    ctx.shadowBlur = 10 + Math.sin(time * 5) * 3;
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Enerji g√∂stergeleri (k√∂≈üelerde)
                    const indicatorCount = 4 + building.level;
                    for (let i = 0; i < indicatorCount; i++) {
                        const angle = (i / indicatorCount) * Math.PI * 2 + time * 2;
                        const ix = bx + Math.cos(angle) * building.size * 0.85;
                        const iy = by + Math.sin(angle) * building.size * 0.85;
                        
                        ctx.fillStyle = towerColor;
                        ctx.shadowColor = towerColor;
                        ctx.shadowBlur = 5;
                        ctx.beginPath();
                        ctx.arc(ix, iy, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Saldƒ±rƒ± menzili g√∂stergesi (saldƒ±rƒ± sƒ±rasƒ±nda)
                    if (building.attackCooldown > 170) {
                        ctx.strokeStyle = towerColor + '30';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bx, by, towerRange, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                } else if (building.type === 'wall') {
                    // Futuristik Duvar
                    const wallW = BUILDING_TYPES.wall.width;
                    const wallH = BUILDING_TYPES.wall.height;
                    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
                    
                    // Ana yapƒ± (metalik)
                    const gradient = ctx.createLinearGradient(bx - wallW/2, by - wallH, bx + wallW/2, by);
                    gradient.addColorStop(0, '#2d3748');
                    gradient.addColorStop(0.5, '#4a5568');
                    gradient.addColorStop(1, '#1a202c');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(bx - wallW/2, by - wallH, wallW, wallH);
                    
                    // √áer√ßeve
                    ctx.strokeStyle = '#00d9ff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(bx - wallW/2, by - wallH, wallW, wallH);
                    
                    // Enerji √ßizgileri (dikey)
                    ctx.strokeStyle = `rgba(0, 217, 255, ${pulse})`;
                    ctx.lineWidth = 2;
                    for (let i = 1; i < 4; i++) {
                        const lineX = bx - wallW/2 + (wallW / 4) * i;
                        ctx.beginPath();
                        ctx.moveTo(lineX, by - wallH);
                        ctx.lineTo(lineX, by);
                        ctx.stroke();
                    }
                    
                    // Enerji bariyer (parlayan)
                    ctx.fillStyle = `rgba(0, 255, 255, ${pulse * 0.2})`;
                    ctx.fillRect(bx - wallW/2 + 5, by - wallH + 5, wallW - 10, wallH - 10);
                    
                    // I≈üƒ±k noktalarƒ±
                    ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(
                            bx - wallW/2 + 10 + i * (wallW/3),
                            by - wallH/2,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                    
                } else if (building.type === 'farm') {
                    // √áiftlik - Base level ile b√ºy√ºr
                    const farmPulse = Math.sin(time * 2) * 2;
                    const farmScale = base ? (1 + (base.level - 1) * 0.15) : 1; // Her level %15 b√ºy√ºme
                    const farmSize = building.size * farmScale;
                    
                    // G√∂lge
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(bx, by + farmSize/2, farmSize * 0.8, farmSize * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // √áiftlik binasƒ±
                    const farmColor = base && base.level >= 3 ? '#a16207' : '#92400e'; // Level 3+ gold tone
                    ctx.fillStyle = farmColor;
                    ctx.fillRect(bx - farmSize * 0.5, by - farmSize * 0.5, farmSize, farmSize * 0.5);
                    
                    // √áatƒ± - base level'a g√∂re renk
                    const roofColor = base && base.level >= 4 ? '#dc2626' : '#b91c1c';
                    ctx.fillStyle = roofColor;
                    ctx.beginPath();
                    ctx.moveTo(bx - farmSize * 0.6, by - farmSize * 0.5);
                    ctx.lineTo(bx, by - farmSize);
                    ctx.lineTo(bx + farmSize * 0.6, by - farmSize * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Altƒ±n parƒ±ltƒ± (XP √ºretiyor g√∂stergesi) - level'a g√∂re daha b√ºy√ºk
                    const glowIntensity = base ? (10 + farmPulse + base.level * 3) : (10 + farmPulse);
                    ctx.strokeStyle = '#fbbf24' + (base && base.level >= 3 ? '80' : '60');
                    ctx.lineWidth = base ? (3 + base.level * 0.5) : 3;
                    ctx.shadowColor = '#fbbf24';
                    ctx.shadowBlur = glowIntensity;
                    ctx.beginPath();
                    ctx.arc(bx, by - farmSize * 0.25, farmSize * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Buƒüday sembolleri - level'a g√∂re daha fazla
                    const wheatCount = base ? Math.min(3 + base.level, 8) : 3;
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = `${12 + (base ? base.level * 2 : 0)}px Arial`;
                    for (let i = 0; i < wheatCount; i++) {
                        const angle = (i / wheatCount) * Math.PI * 2 + time;
                        const wx = bx + Math.cos(angle) * (farmSize * 0.4);
                        const wy = by - farmSize * 0.25 + Math.sin(angle) * (farmSize * 0.4);
                        ctx.fillText('üåæ', wx - 8, wy + 8);
                    }
                    
                    // Level 5 √∂zel efekt - rainbow glow
                    if (base && base.level === 5) {
                        const rainbowHue = (Date.now() / 20) % 360;
                        ctx.strokeStyle = `hsla(${rainbowHue}, 100%, 50%, 0.3)`;
                        ctx.lineWidth = 4;
                        ctx.shadowColor = `hsl(${rainbowHue}, 100%, 50%)`;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(bx, by - farmSize * 0.25, farmSize * 0.75, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                } else if (building.type === 'barracks') {
                    // Barracks (Kƒ±≈üla) - Jedi Training Center
                    const barracksPulse = Math.sin(time * 3) * 3;
                    
                    // G√∂lge
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(bx, by + building.size/2, building.size * 0.9, building.size * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Ana yapƒ± - metal platform
                    ctx.fillStyle = '#374151';
                    ctx.fillRect(bx - building.size * 0.6, by - building.size * 0.4, building.size * 1.2, building.size * 0.8);
                    
                    // Enerji kalkanƒ±
                    ctx.strokeStyle = '#3b82f6' + '80';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#3b82f6';
                    ctx.shadowBlur = 15 + barracksPulse;
                    ctx.beginPath();
                    ctx.arc(bx, by, building.size * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Training holograms
                    for (let i = 0; i < 2; i++) {
                        const hx = bx + (i === 0 ? -15 : 15);
                        ctx.fillStyle = '#00ffdd' + '40';
                        ctx.beginPath();
                        ctx.arc(hx, by, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Spawn indicator
                    if (building.spawnCooldown && building.spawnCooldown < 120) {
                        const spawnProgress = 1 - (building.spawnCooldown / BUILDING_TYPES.barracks.spawnInterval);
                        ctx.strokeStyle = '#00ff88';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(bx, by, building.size * 0.4, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * spawnProgress);
                        ctx.stroke();
                    }
                    
                    // Crossed lightsabers icon
                    ctx.save();
                    ctx.translate(bx, by);
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 10;
                    
                    // Lightsaber 1
                    ctx.beginPath();
                    ctx.moveTo(-15, 10);
                    ctx.lineTo(15, -10);
                    ctx.stroke();
                    
                    // Lightsaber 2
                    ctx.beginPath();
                    ctx.moveTo(-15, -10);
                    ctx.lineTo(15, 10);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                // Can barƒ± (sadece hasar aldƒ±ysa)
                if (building.health < building.maxHealth) {
                    const barWidth = building.size * 1.8;
                    const barHeight = 6;
                    const barY = by - building.size - 15; // √ústten bakƒ±≈ü i√ßin ayarlandƒ±
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(bx - barWidth/2, barY, barWidth, barHeight);
                    
                    const healthPercent = building.health / building.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
                    ctx.fillRect(bx - barWidth/2, barY, barWidth * healthPercent, barHeight);
                }
            });
            
            // MINI-BOSS
            if (miniBoss) {
                const mbx = miniBoss.x - camera.x;
                const mby = miniBoss.y - camera.y;
                const time = Date.now() / 1000;
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(mbx, mby + miniBoss.size, miniBoss.size * 1.2, miniBoss.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (miniBoss.type === 'shielder') {
                    // SHIELDER - Blue shield themed
                    const pulse = Math.sin(time * 3) * 5;
                    
                    // Main body
                    const gradient = ctx.createRadialGradient(mbx, mby, 0, mbx, mby, miniBoss.size);
                    gradient.addColorStop(0, '#60a5fa');
                    gradient.addColorStop(0.5, '#3b82f6');
                    gradient.addColorStop(1, '#1e40af');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(mbx, mby, miniBoss.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shield layers
                    ctx.strokeStyle = '#60a5fa' + '80';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#60a5fa';
                    ctx.shadowBlur = 15 + pulse;
                    for (let i = 1; i <= 3; i++) {
                        ctx.beginPath();
                        ctx.arc(mbx, mby, miniBoss.size + i * 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 0;
                    
                } else if (miniBoss.type === 'summoner') {
                    // SUMMONER - Purple mystical themed
                    const float = Math.sin(time * 2) * 5;
                    
                    // Main body with mystical aura
                    const gradient = ctx.createRadialGradient(mbx, mby + float, 0, mbx, mby + float, miniBoss.size);
                    gradient.addColorStop(0, '#e9d5ff');
                    gradient.addColorStop(0.5, '#a855f7');
                    gradient.addColorStop(1, '#7e22ce');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(mbx, mby + float, miniBoss.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Orbiting summon circles
                    for (let i = 0; i < miniBoss.maxSummons; i++) {
                        const angle = (i / miniBoss.maxSummons) * Math.PI * 2 + time;
                        const ox = mbx + Math.cos(angle) * (miniBoss.size + 20);
                        const oy = mby + Math.sin(angle) * (miniBoss.size + 20) + float;
                        
                        ctx.fillStyle = i < miniBoss.currentSummons ? '#c084fc' : '#a855f7' + '40';
                        ctx.beginPath();
                        ctx.arc(ox, oy, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                } else if (miniBoss.type === 'berserker') {
                    // BERSERKER - Red rage themed
                    const shake = miniBoss.rageActive ? Math.sin(time * 20) * 3 : 0;
                    
                    // Main body
                    const gradient = ctx.createRadialGradient(mbx + shake, mby, 0, mbx + shake, mby, miniBoss.size);
                    if (miniBoss.rageActive) {
                        gradient.addColorStop(0, '#fecaca');
                        gradient.addColorStop(0.5, '#ef4444');
                        gradient.addColorStop(1, '#991b1b');
                    } else {
                        gradient.addColorStop(0, '#fca5a5');
                        gradient.addColorStop(0.5, '#dc2626');
                        gradient.addColorStop(1, '#7f1d1d');
                    }
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(mbx + shake, mby, miniBoss.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rage aura
                    if (miniBoss.rageActive) {
                        const ragePulse = Math.sin(time * 5) * 8;
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 6;
                        ctx.shadowColor = '#ef4444';
                        ctx.shadowBlur = 20 + ragePulse;
                        ctx.beginPath();
                        ctx.arc(mbx + shake, mby, miniBoss.size + 15 + ragePulse, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Spikes
                    ctx.fillStyle = '#7f1d1d';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const sx = mbx + Math.cos(angle) * miniBoss.size;
                        const sy = mby + Math.sin(angle) * miniBoss.size;
                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(mbx + Math.cos(angle) * (miniBoss.size + 10), mby + Math.sin(angle) * (miniBoss.size + 10));
                        ctx.lineTo(mbx + Math.cos(angle + 0.2) * miniBoss.size, mby + Math.sin(angle + 0.2) * miniBoss.size);
                        ctx.fill();
                    }
                }
                
                // Name tag
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                ctx.fillText(miniBoss.name, mbx, mby - miniBoss.size - 40);
                ctx.shadowBlur = 0;
                
                // Health bar
                const barWidth = miniBoss.size * 2;
                const barHeight = 8;
                const healthPercent = miniBoss.health / miniBoss.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(mbx - barWidth/2, mby - miniBoss.size - 25, barWidth, barHeight);
                
                const healthColor = healthPercent > 0.5 ? miniBoss.color : healthPercent > 0.25 ? '#f59e0b' : '#dc2626';
                ctx.fillStyle = healthColor;
                ctx.fillRect(mbx - barWidth/2, mby - miniBoss.size - 25, barWidth * healthPercent, barHeight);
                
                // Health text
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText(`${Math.floor(miniBoss.health)}/${miniBoss.maxHealth}`, mbx, mby - miniBoss.size - 10);
            }
            
            // Boss
            if (boss) {
                const bx = boss.x - camera.x;
                const by = boss.y - camera.y;
                const time = Date.now() / 1000;
                
                // G√∂lge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.ellipse(bx, by + boss.size + 10, boss.size * 1.2, boss.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Enerji halkalarƒ±
                const pulse = Math.sin(time * 3) * 5;
                ctx.strokeStyle = 'rgba(220, 38, 38, 0.5)';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#dc2626';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(bx, by, boss.size + 15 + pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(bx, by, boss.size + 25 + pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Ana g√∂vde
                const bossGradient = ctx.createRadialGradient(bx, by - 10, 0, bx, by, boss.size);
                bossGradient.addColorStop(0, '#fca5a5');
                bossGradient.addColorStop(0.5, '#ef4444');
                bossGradient.addColorStop(1, '#991b1b');
                ctx.fillStyle = bossGradient;
                ctx.beginPath();
                ctx.arc(bx, by, boss.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Zƒ±rh plakalarƒ±
                ctx.strokeStyle = '#7f1d1d';
                ctx.lineWidth = 5;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(bx, by, boss.size - i * 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // D√∂nen toplar
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + time * 2;
                    const orbX = bx + Math.cos(angle) * (boss.size + 20);
                    const orbY = by + Math.sin(angle) * (boss.size + 20);
                    
                    ctx.fillStyle = '#dc2626';
                    ctx.shadowColor = '#dc2626';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                // G√∂z
                ctx.fillStyle = '#450a0a';
                ctx.beginPath();
                ctx.arc(bx, by, boss.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fef08a';
                ctx.shadowColor = '#fef08a';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(bx, by, boss.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Boss Can barƒ± (b√ºy√ºk)
                const bossBarWidth = 300;
                const bossBarHeight = 20;
                const bossBarX = canvas.width / 2 - bossBarWidth / 2;
                const bossBarY = 80;
                
                // Arka plan
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bossBarX - 5, bossBarY - 5, bossBarWidth + 10, bossBarHeight + 10);
                
                // √áer√ßeve
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.strokeRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);
                
                // Can
                ctx.fillStyle = '#7f1d1d';
                ctx.fillRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);
                
                const bossHealthPercent = boss.health / boss.maxHealth;
                const bossHealthGradient = ctx.createLinearGradient(bossBarX, 0, bossBarX + bossBarWidth, 0);
                bossHealthGradient.addColorStop(0, '#dc2626');
                bossHealthGradient.addColorStop(1, '#f87171');
                ctx.fillStyle = bossHealthGradient;
                ctx.fillRect(bossBarX, bossBarY, bossBarWidth * bossHealthPercent, bossBarHeight);
                
                // Boss ismi
                ctx.fillStyle = '#fef08a';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', canvas.width / 2, bossBarY - 10);
                ctx.textAlign = 'left';
            }
            
            // Oyuncu
            const px = player.x - camera.x;
            const py = player.y - camera.y;
            
            // Idle animasyon - nefes alma
            const breathe = Math.sin(player.idleFrame * 0.05) * 1.5;
            const bodySize = (25 + breathe) * playerSizeMod; // Modifier applied
            
            // G√∂lge
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(px, py + bodySize + 3, bodySize * 0.8, bodySize * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player with equipped skin
            drawPlayerWithSkin(ctx, px, py, bodySize, player.idleFrame);
            
            
            // Reload barƒ±
            if (player.reloading && player.weapon) {
                const reloadBarWidth = 60;
                const reloadBarHeight = 8;
                const reloadBarY = py - 35;
                
                // Arka plan
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(px - reloadBarWidth/2, reloadBarY, reloadBarWidth, reloadBarHeight);
                
                // Dolgu
                const reloadPercent = player.reloadProgress / player.weapon.reloadTime;
                const barGradient = ctx.createLinearGradient(px - reloadBarWidth/2, 0, px + reloadBarWidth/2, 0);
                barGradient.addColorStop(0, '#3b82f6');
                barGradient.addColorStop(1, '#60a5fa');
                ctx.fillStyle = barGradient;
                ctx.fillRect(px - reloadBarWidth/2, reloadBarY, reloadBarWidth * reloadPercent, reloadBarHeight);
                
                // √áer√ßeve
                ctx.strokeStyle = '#1e40af';
                ctx.lineWidth = 2;
                ctx.strokeRect(px - reloadBarWidth/2, reloadBarY, reloadBarWidth, reloadBarHeight);
                
                // "RELOAD" yazƒ±sƒ±
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('RELOAD', px, reloadBarY - 5);
                ctx.textAlign = 'left';
            }
            
            // COMBO DISPLAY
            if (comboCount > 1) {
                const comboY = py - 65; // Above ability bar
                
                // Combo text with glow
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
                
                // Color based on combo level
                let comboColor = '#ffffff';
                if (comboCount >= 50) comboColor = '#ff00ff'; // Legendary
                else if (comboCount >= 20) comboColor = '#ff0000'; // Ultra
                else if (comboCount >= 10) comboColor = '#ffaa00'; // Mega
                else if (comboCount >= 5) comboColor = '#ffd700'; // Fire
                
                ctx.fillStyle = comboColor;
                ctx.fillText(`${comboCount}x COMBO`, px, comboY);
                ctx.shadowBlur = 0;
                
                // Combo timer bar
                const comboBarWidth = 60;
                const comboBarHeight = 4;
                const comboTimerPercent = comboTimer / COMBO_TIMEOUT;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(px - comboBarWidth/2, comboY + 5, comboBarWidth, comboBarHeight);
                
                ctx.fillStyle = comboColor;
                ctx.fillRect(px - comboBarWidth/2, comboY + 5, comboBarWidth * comboTimerPercent, comboBarHeight);
            }
            
            // ABILITY COOLDOWN BAR
            if (abilityUnlocked && abilityCooldown > 0) {
                const abilityBarWidth = 70;
                const abilityBarHeight = 10;
                const abilityBarY = py - 50; // Reload'dan yukarƒ±da
                
                // Arka plan
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(px - abilityBarWidth/2, abilityBarY, abilityBarWidth, abilityBarHeight);
                
                // Cooldown progress (ters)
                const cooldownPercent = 1 - (abilityCooldown / abilityMaxCooldown);
                const abilityGradient = ctx.createLinearGradient(px - abilityBarWidth/2, 0, px + abilityBarWidth/2, 0);
                
                // Aƒüaca g√∂re renk
                if (selectedWeaponTree === 'melee') {
                    abilityGradient.addColorStop(0, '#00ffdd');
                    abilityGradient.addColorStop(1, '#00ccaa');
                } else if (selectedWeaponTree === 'ranged') {
                    abilityGradient.addColorStop(0, '#ff4444');
                    abilityGradient.addColorStop(1, '#cc0000');
                } else if (selectedWeaponTree === 'hybrid') {
                    abilityGradient.addColorStop(0, '#ffd700');
                    abilityGradient.addColorStop(1, '#ffaa00');
                }
                
                ctx.fillStyle = abilityGradient;
                ctx.fillRect(px - abilityBarWidth/2, abilityBarY, abilityBarWidth * cooldownPercent, abilityBarHeight);
                
                // √áer√ßeve
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(px - abilityBarWidth/2, abilityBarY, abilityBarWidth, abilityBarHeight);
                
                // Ability name
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 3;
                ctx.fillText(abilityName.toUpperCase(), px, abilityBarY - 5);
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }
            
            // Dash cooldown g√∂stergesi
            if (player.weapon && player.weapon.ability === 'dash' && player.dashCooldown > 0) {
                const dashCooldownPercent = player.dashCooldown / 120;
                ctx.fillStyle = `rgba(255, 69, 0, ${dashCooldownPercent * 0.5})`;
                ctx.strokeStyle = '#ff4500';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(px, py, 35, -Math.PI / 2, -Math.PI / 2 + (1 - dashCooldownPercent) * Math.PI * 2);
                ctx.stroke();
            }
            
            // SOLDIERS (Jedi Warriors)
            soldiers.forEach(soldier => {
                const sx = soldier.x - camera.x;
                const sy = soldier.y - camera.y;
                
                // G√∂lge
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(sx, sy + soldier.size, soldier.size * 0.6, soldier.size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Jedi robe (body) - Elite'ler daha parlak
                const robeGradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, soldier.size);
                if (soldier.elite) {
                    // Elite Jedi - Golden/White robe
                    robeGradient.addColorStop(0, '#f3f4f6');
                    robeGradient.addColorStop(0.5, '#d1d5db');
                    robeGradient.addColorStop(1, '#9ca3af');
                } else {
                    // Normal Jedi - Dark robe
                    robeGradient.addColorStop(0, '#4a5568');
                    robeGradient.addColorStop(1, '#1f2937');
                }
                ctx.fillStyle = robeGradient;
                ctx.beginPath();
                ctx.arc(sx, sy, soldier.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Elite aura
                if (soldier.elite) {
                    const auraPulse = Math.sin(Date.now() / 200) * 3;
                    ctx.strokeStyle = soldier.lightsaberColor + '40';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = soldier.lightsaberColor;
                    ctx.shadowBlur = 15 + auraPulse;
                    ctx.beginPath();
                    ctx.arc(sx, sy, soldier.size + 5 + auraPulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Hood
                ctx.fillStyle = soldier.elite ? '#6b7280' : '#111827';
                ctx.beginPath();
                ctx.arc(sx, sy - 5, soldier.size * 0.7, 0, Math.PI, true);
                ctx.fill();
                
                // Face (barely visible)
                ctx.fillStyle = '#d4a574';
                ctx.beginPath();
                ctx.arc(sx, sy, soldier.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // LIGHTSABER - Elite'ler double-bladed
                const swordLength = soldier.elite ? 50 : 40;
                const swordX = sx + Math.cos(soldier.lightsaberAngle) * swordLength;
                const swordY = sy + Math.sin(soldier.lightsaberAngle) * swordLength;
                
                // Main blade
                ctx.shadowColor = soldier.lightsaberColor;
                ctx.shadowBlur = soldier.elite ? 20 : 15;
                ctx.strokeStyle = soldier.lightsaberColor;
                ctx.lineWidth = soldier.elite ? 8 : 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(sx + Math.cos(soldier.lightsaberAngle) * 10, sy + Math.sin(soldier.lightsaberAngle) * 10);
                ctx.lineTo(swordX, swordY);
                ctx.stroke();
                
                // Elite: Second blade (opposite side)
                if (soldier.elite) {
                    const swordX2 = sx - Math.cos(soldier.lightsaberAngle) * swordLength;
                    const swordY2 = sy - Math.sin(soldier.lightsaberAngle) * swordLength;
                    ctx.beginPath();
                    ctx.moveTo(sx - Math.cos(soldier.lightsaberAngle) * 10, sy - Math.sin(soldier.lightsaberAngle) * 10);
                    ctx.lineTo(swordX2, swordY2);
                    ctx.stroke();
                }
                
                // Inner bright core
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = soldier.elite ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(sx + Math.cos(soldier.lightsaberAngle) * 10, sy + Math.sin(soldier.lightsaberAngle) * 10);
                ctx.lineTo(swordX, swordY);
                ctx.stroke();
                
                // Elite: Second blade core
                if (soldier.elite) {
                    const swordX2 = sx - Math.cos(soldier.lightsaberAngle) * swordLength;
                    const swordY2 = sy - Math.sin(soldier.lightsaberAngle) * swordLength;
                    ctx.beginPath();
                    ctx.moveTo(sx - Math.cos(soldier.lightsaberAngle) * 10, sy - Math.sin(soldier.lightsaberAngle) * 10);
                    ctx.lineTo(swordX2, swordY2);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                
                // Lightsaber hilt
                ctx.fillStyle = soldier.elite ? '#d4af37' : '#78716c'; // Gold for elite
                ctx.beginPath();
                ctx.arc(sx + Math.cos(soldier.lightsaberAngle) * 5, sy + Math.sin(soldier.lightsaberAngle) * 5, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Health bar
                if (soldier.health < soldier.maxHealth) {
                    const barWidth = 30;
                    const barHeight = 4;
                    const healthPercent = soldier.health / soldier.maxHealth;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(sx - barWidth/2, sy - soldier.size - 10, barWidth, barHeight);
                    
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff88' : healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
                    ctx.fillRect(sx - barWidth/2, sy - soldier.size - 10, barWidth * healthPercent, barHeight);
                }
            });
            
            // Bildirimler (ekranƒ±n √ºst ortasƒ±nda)
            notifications.forEach((notif, index) => {
                const notifY = 150 + index * 80;
                const notifAlpha = Math.min(1, notif.life / 30);
                
                ctx.save();
                ctx.globalAlpha = notifAlpha;
                
                // Arka plan
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(canvas.width / 2 - 200, notifY, 400, 60);
                
                // √áer√ßeve
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 3;
                ctx.strokeRect(canvas.width / 2 - 200, notifY, 400, 60);
                
                // Parƒ±ltƒ± efekti
                const glowSize = Math.sin(Date.now() / 200) * 5;
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 10 + glowSize;
                ctx.strokeRect(canvas.width / 2 - 200, notifY, 400, 60);
                ctx.shadowBlur = 0;
                
                // Metin
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                
                const lines = notif.text.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, canvas.width / 2, notifY + 25 + i * 22);
                });
                
                ctx.textAlign = 'left';
                ctx.restore();
            });
            
            // Power-up'larƒ± √ßiz
            powerUps.forEach(powerUp => {
                const px = powerUp.x - camera.x;
                const py = powerUp.y - camera.y;
                const type = POWERUP_TYPES[powerUp.type];
                
                // Pulse animasyon
                const pulseSize = powerUp.size + powerUp.pulse;
                
                // Glow efekti
                ctx.save();
                ctx.shadowColor = type.color;
                ctx.shadowBlur = 20;
                
                // Daire arka plan
                ctx.fillStyle = type.color + '40';
                ctx.beginPath();
                ctx.arc(px, py, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Icon
                ctx.shadowBlur = 10;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(type.icon, px, py);
                
                // Lifetime bar
                const lifetimePercent = powerUp.lifetime / 600;
                const barWidth = 40;
                const barHeight = 4;
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(px - barWidth / 2, py + pulseSize + 10, barWidth, barHeight);
                ctx.fillStyle = lifetimePercent > 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(px - barWidth / 2, py + pulseSize + 10, barWidth * lifetimePercent, barHeight);
                
                ctx.restore();
            });
            
            // Silah
            if ((player.attacking || player.attackFrame > 0) && player.weapon) {
                const swingProgress = 1 - (player.attackFrame / 15);
                const swingAngle = player.attackAngle + Math.sin(swingProgress * Math.PI) * 0.8 - 0.4;
                
                // Player position for weapon rendering
                const px = player.x - camera.x;
                const py = player.y - camera.y;
                
                // Draw progress for ranged weapons
                const drawProgress = Math.min(1, player.attackFrame / 10);
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // WEAPON SKIN RENDERING SYSTEM (applies to ALL weapon types)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                var weaponRendered = false;
                const weaponName = player.weapon.name; // Declare here for all weapon types
                const weaponSkin = equippedItems.weapon || 'default';
                const isWeaponSkin = weaponSkin.startsWith('weapon_');
                
                console.log('Weapon Skin Check:', { weaponSkin, isWeaponSkin, weaponRendered });
                
                // Render weapon skins FIRST (for all weapon types)
                if (isWeaponSkin) {
                
                    // RED LASER (üî¥) - Futuristic laser pistol
                    if (weaponSkin === 'weapon_laser') {
                        weaponRendered = true;
                        console.log('RED LASER RENDERING!');
                        
                        const barrelLength = 55;
                        
                        // NAMLU (exactly like default gun but RED)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        gradient.addColorStop(0, '#444');
                        gradient.addColorStop(1, '#ff0000');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 9;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        ctx.stroke();
                        
                        // KABZA (grip)
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#2a2a2a';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 22,
                            py + Math.sin(gripAngle) * 22
                        );
                        ctx.stroke();
                        
                        // TETIK (trigger)
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(
                            px + Math.cos(gripAngle) * 10,
                            py + Math.sin(gripAngle) * 10,
                            3, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // MUZZLE FLASH (red laser glow)
                        if (player.attackFrame > 12) {
                            const muzzleX = px + Math.cos(swingAngle) * barrelLength;
                            const muzzleY = py + Math.sin(swingAngle) * barrelLength;
                            
                            ctx.fillStyle = '#ff0000';
                            ctx.shadowColor = '#ff0000';
                            ctx.shadowBlur = 20;
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // ARC CANNON (‚ö°) - Tesla coil weapon
                    else if (weaponSkin === 'weapon_lightning') {
                        weaponRendered = true;
                        
                        const barrelLength = 50;
                        
                        // Main barrel (gradient gray to orange)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        gradient.addColorStop(0, '#2a2a2a');
                        gradient.addColorStop(1, '#ff8800');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 11;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        ctx.stroke();
                        
                        // Copper coil rings
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 5; i++) {
                            const t = 0.3 + (i / 5) * 0.5;
                            const coilX = px + Math.cos(swingAngle) * barrelLength * t;
                            const coilY = py + Math.sin(swingAngle) * barrelLength * t;
                            ctx.beginPath();
                            ctx.arc(coilX, coilY, 5, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        // Grip
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 20,
                            py + Math.sin(gripAngle) * 20
                        );
                        ctx.stroke();
                        
                        // Electric spark muzzle flash
                        if (player.attackFrame > 12) {
                            const muzzleX = px + Math.cos(swingAngle) * barrelLength;
                            const muzzleY = py + Math.sin(swingAngle) * barrelLength;
                            
                            // Lightning bolts
                            ctx.strokeStyle = '#00ffff';
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 15;
                            ctx.lineWidth = 2;
                            
                            for (let i = 0; i < 3; i++) {
                                const angle = swingAngle + (Math.random() - 0.5) * 0.5;
                                ctx.beginPath();
                                ctx.moveTo(muzzleX, muzzleY);
                                ctx.lineTo(
                                    muzzleX + Math.cos(angle) * 15,
                                    muzzleY + Math.sin(angle) * 15
                                );
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                        }
                        
                        
                    }
                    
                    // PLASMA RIFLE (üî´) - Energy rifle with glowing core
                    else if (weaponSkin === 'weapon_plasma') {
                        weaponRendered = true;
                        
                        const rifleLength = 65;
                        
                        // NAMLU (barrel) - cyan/blue gradient
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * rifleLength,
                            py + Math.sin(swingAngle) * rifleLength
                        );
                        gradient.addColorStop(0, '#2a3a4a');
                        gradient.addColorStop(1, '#00ffff');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 10;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * rifleLength,
                            py + Math.sin(swingAngle) * rifleLength
                        );
                        ctx.stroke();
                        
                        // STOCK (dip√ßik)
                        const stockAngle = swingAngle + Math.PI;
                        ctx.strokeStyle = '#1a2a3a';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(stockAngle) * 15,
                            py + Math.sin(stockAngle) * 15
                        );
                        ctx.stroke();
                        
                        // GRIP
                        const gripAngle = swingAngle - Math.PI / 2.5;
                        ctx.strokeStyle = '#0a1a2a';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 18,
                            py + Math.sin(gripAngle) * 18
                        );
                        ctx.stroke();
                        
                        // MUZZLE FLASH (plasma glow)
                        if (player.attackFrame > 10) {
                            const muzzleX = px + Math.cos(swingAngle) * rifleLength;
                            const muzzleY = py + Math.sin(swingAngle) * rifleLength;
                            
                            ctx.fillStyle = '#00ffff';
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 25;
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 12, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                        
                        
                    }
                    
                    // INFERNO GUN (üî•) - Flamethrower
                    else if (weaponSkin === 'weapon_flame') {
                        weaponRendered = true;
                        
                        const barrelLength = 52;
                        
                        // Main barrel (dark red to orange gradient)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        gradient.addColorStop(0, '#4a0000');
                        gradient.addColorStop(1, '#ff4400');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 12;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        ctx.stroke();
                        
                        // Fuel tank (thick circle at handle)
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.arc(px, py, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Grip/handle
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#2a0000';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 18,
                            py + Math.sin(gripAngle) * 18
                        );
                        ctx.stroke();
                        
                        // FIRE BLAST - animated flames
                        if (player.attackFrame > 10) {
                            const muzzleX = px + Math.cos(swingAngle) * barrelLength;
                            const muzzleY = py + Math.sin(swingAngle) * barrelLength;
                            
                            ctx.shadowColor = '#ff4400';
                            ctx.shadowBlur = 20;
                            
                            // Multiple fire particles
                            for (let i = 0; i < 6; i++) {
                                const spread = (Math.random() - 0.5) * 0.4;
                                const dist = 10 + Math.random() * 15;
                                const fireX = muzzleX + Math.cos(swingAngle + spread) * dist;
                                const fireY = muzzleY + Math.sin(swingAngle + spread) * dist;
                                const size = 4 + Math.random() * 5;
                                const color = i % 2 === 0 ? '#ff4400' : '#ffaa00';
                                
                                ctx.fillStyle = color;
                                ctx.beginPath();
                                ctx.arc(fireX, fireY, size, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.shadowBlur = 0;
                        }
                        
                        
                    }
                    
                    // VOID CANNON (üåå) - Dark matter weapon
                    else if (weaponSkin === 'weapon_void') {
                        weaponRendered = true;
                        
                        const barrelLength = 58;
                        
                        // Main barrel (black to purple gradient)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        gradient.addColorStop(0, '#1a0a2a');
                        gradient.addColorStop(0.5, '#4b0082');
                        gradient.addColorStop(1, '#8b00ff');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 13;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        ctx.stroke();
                        
                        // Purple energy rings (animated)
                        const time = Date.now() / 500;
                        ctx.strokeStyle = '#8b00ff';
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 4; i++) {
                            const t = 0.3 + (i / 4) * 0.5;
                            const ringX = px + Math.cos(swingAngle) * barrelLength * t;
                            const ringY = py + Math.sin(swingAngle) * barrelLength * t;
                            const phase = (time + i * 0.5) % 1;
                            ctx.globalAlpha = 0.5 + Math.sin(phase * Math.PI * 2) * 0.3;
                            ctx.beginPath();
                            ctx.arc(ringX, ringY, 6, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        
                        // Grip
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#0a0a0a';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 20,
                            py + Math.sin(gripAngle) * 20
                        );
                        ctx.stroke();
                        
                        // VOID BLAST - dark matter explosion
                        if (player.attackFrame > 12) {
                            const muzzleX = px + Math.cos(swingAngle) * barrelLength;
                            const muzzleY = py + Math.sin(swingAngle) * barrelLength;
                            
                            ctx.shadowColor = '#8b00ff';
                            ctx.shadowBlur = 25;
                            ctx.fillStyle = '#8b00ff';
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 15, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Dark tendrils
                            for (let i = 0; i < 4; i++) {
                                const angle = (i / 4) * Math.PI * 2 + time;
                                const tx = muzzleX + Math.cos(angle) * 20;
                                const ty = muzzleY + Math.sin(angle) * 20;
                                ctx.strokeStyle = '#4b0082';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(muzzleX, muzzleY);
                                ctx.lineTo(tx, ty);
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                        }
                        
                        
                    }
                    
                    // CELESTIAL BEAM (‚ú®) - Premium Gold Weapon
                    else if (weaponSkin === 'weapon_celestial') {
                        weaponRendered = true;
                        
                        const staffLength = 62;
                        
                        // GOLDEN STAFF (premium gradient)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * staffLength,
                            py + Math.sin(swingAngle) * staffLength
                        );
                        gradient.addColorStop(0, '#8B7500');
                        gradient.addColorStop(0.5, '#FFD700');
                        gradient.addColorStop(1, '#FFA500');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 12;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * staffLength,
                            py + Math.sin(swingAngle) * staffLength
                        );
                        ctx.stroke();
                        
                        // DIVINE AURA (glowing halo)
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 25;
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.4)';
                        ctx.lineWidth = 18;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * staffLength,
                            py + Math.sin(swingAngle) * staffLength
                        );
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // ROTATING HOLY STARS (premium effect)
                        const time = Date.now() / 350;
                        for (let i = 0; i < 6; i++) {
                            const t = 0.2 + (i / 6) * 0.7;
                            const starX = px + Math.cos(swingAngle) * staffLength * t;
                            const starY = py + Math.sin(swingAngle) * staffLength * t;
                            const rotation = time + i * Math.PI / 3;
                            
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 12;
                            
                            // 4-pointed star
                            for (let j = 0; j < 4; j++) {
                                const angle = rotation + j * Math.PI / 2;
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = 2.5;
                                ctx.beginPath();
                                ctx.moveTo(starX, starY);
                                ctx.lineTo(
                                    starX + Math.cos(angle) * 5,
                                    starY + Math.sin(angle) * 5
                                );
                                ctx.stroke();
                            }
                        }
                        ctx.shadowBlur = 0;
                        
                        // GRIP (ornate handle)
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#8B7500';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 18,
                            py + Math.sin(gripAngle) * 18
                        );
                        ctx.stroke();
                        
                        // DIVINE BLAST (holy explosion)
                        if (player.attackFrame > 10) {
                            const muzzleX = px + Math.cos(swingAngle) * staffLength;
                            const muzzleY = py + Math.sin(swingAngle) * staffLength;
                            
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 35;
                            
                            // Core burst
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 14, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Holy rays (8 directions)
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                ctx.strokeStyle = '#FFD700';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(muzzleX, muzzleY);
                                ctx.lineTo(
                                    muzzleX + Math.cos(angle) * 22,
                                    muzzleY + Math.sin(angle) * 22
                                );
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // SHADOW REAPER (üåë) - Premium Dark Weapon
                    else if (weaponSkin === 'weapon_shadow') {
                        weaponRendered = true;
                        
                        const scytheLength = 58;
                        
                        // DARK STAFF (black to purple gradient)
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * scytheLength,
                            py + Math.sin(swingAngle) * scytheLength
                        );
                        gradient.addColorStop(0, '#0a0a0a');
                        gradient.addColorStop(0.6, '#1a1a1a');
                        gradient.addColorStop(1, '#2a2a2a');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 11;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * scytheLength,
                            py + Math.sin(swingAngle) * scytheLength
                        );
                        ctx.stroke();
                        
                        // DARK AURA (purple shadow energy)
                        ctx.shadowColor = '#8b00ff';
                        ctx.shadowBlur = 25;
                        ctx.strokeStyle = 'rgba(138, 0, 255, 0.6)';
                        ctx.lineWidth = 16;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * scytheLength,
                            py + Math.sin(swingAngle) * scytheLength
                        );
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // CURVED SCYTHE BLADE (at tip)
                        const tipX = px + Math.cos(swingAngle) * scytheLength;
                        const tipY = py + Math.sin(swingAngle) * scytheLength;
                        const perpAngle = swingAngle + Math.PI / 2;
                        
                        ctx.shadowColor = '#8b00ff';
                        ctx.shadowBlur = 20;
                        ctx.strokeStyle = '#4b0082';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(tipX, tipY);
                        ctx.quadraticCurveTo(
                            tipX + Math.cos(perpAngle) * 15,
                            tipY + Math.sin(perpAngle) * 15,
                            tipX + Math.cos(perpAngle) * 25 + Math.cos(swingAngle) * 5,
                            tipY + Math.sin(perpAngle) * 25 + Math.sin(swingAngle) * 5
                        );
                        ctx.stroke();
                        
                        // Blade edge glow
                        ctx.strokeStyle = '#9400d3';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // DARK PARTICLES (floating shadows)
                        const time = Date.now() / 400;
                        for (let i = 0; i < 5; i++) {
                            const t = 0.3 + (i / 5) * 0.5;
                            const particleX = px + Math.cos(swingAngle) * scytheLength * t;
                            const particleY = py + Math.sin(swingAngle) * scytheLength * t;
                            const offset = Math.sin(time + i) * 8;
                            
                            ctx.fillStyle = 'rgba(75, 0, 130, 0.5)';
                            ctx.beginPath();
                            ctx.arc(
                                particleX + Math.cos(perpAngle) * offset,
                                particleY + Math.sin(perpAngle) * offset,
                                3, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        
                        // DEATH BLAST (dark explosion)
                        if (player.attackFrame > 12) {
                            ctx.shadowColor = '#8b00ff';
                            ctx.shadowBlur = 30;
                            
                            // Core void
                            ctx.fillStyle = '#000000';
                            ctx.beginPath();
                            ctx.arc(tipX, tipY, 16, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Purple tendrils (8 directions)
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2 + time;
                                ctx.strokeStyle = '#8b00ff';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(tipX, tipY);
                                ctx.lineTo(
                                    tipX + Math.cos(angle) * 24,
                                    tipY + Math.sin(angle) * 24
                                );
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // PRISMATIC RAY (üåà) - Rainbow Weapon
                    else if (weaponSkin === 'weapon_rainbow') {
                        weaponRendered = true;
                        const weaponLength = 60;
                        
                        // RAINBOW GRADIENT BEAM (multicolor)
                        const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
                        const segments = rainbowColors.length;
                        
                        // Main rainbow beam
                        for (let i = 0; i < segments; i++) {
                            const t1 = i / segments;
                            const t2 = (i + 1) / segments;
                            const x1 = px + Math.cos(swingAngle) * weaponLength * t1;
                            const y1 = py + Math.sin(swingAngle) * weaponLength * t1;
                            const x2 = px + Math.cos(swingAngle) * weaponLength * t2;
                            const y2 = py + Math.sin(swingAngle) * weaponLength * t2;
                            
                            ctx.strokeStyle = rainbowColors[i];
                            ctx.lineWidth = 12;
                            ctx.shadowColor = rainbowColors[i];
                            ctx.shadowBlur = 20;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                        
                        // Outer glow (wider)
                        for (let i = 0; i < segments; i++) {
                            const t1 = i / segments;
                            const t2 = (i + 1) / segments;
                            const x1 = px + Math.cos(swingAngle) * weaponLength * t1;
                            const y1 = py + Math.sin(swingAngle) * weaponLength * t1;
                            const x2 = px + Math.cos(swingAngle) * weaponLength * t2;
                            const y2 = py + Math.sin(swingAngle) * weaponLength * t2;
                            
                            ctx.strokeStyle = rainbowColors[i];
                            ctx.globalAlpha = 0.3;
                            ctx.lineWidth = 18;
                            ctx.shadowBlur = 25;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        
                        // ANIMATED SPARKLE TRAIL (moving particles)
                        const time = Date.now() / 150;
                        for (let i = 0; i < 8; i++) {
                            const t = (i / 8 + time) % 1;
                            const sparkleX = px + Math.cos(swingAngle) * weaponLength * t;
                            const sparkleY = py + Math.sin(swingAngle) * weaponLength * t;
                            const colorIndex = Math.floor(t * rainbowColors.length);
                            const sparkleSize = 3 + Math.sin(time * 2 + i) * 2;
                            
                            ctx.fillStyle = rainbowColors[colorIndex];
                            ctx.shadowColor = rainbowColors[colorIndex];
                            ctx.shadowBlur = 15;
                            ctx.beginPath();
                            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // GRIP
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.shadowBlur = 0;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 18,
                            py + Math.sin(gripAngle) * 18
                        );
                        ctx.stroke();
                        
                        // RAINBOW BURST
                        if (player.attackFrame > 12) {
                            const muzzleX = px + Math.cos(swingAngle) * weaponLength;
                            const muzzleY = py + Math.sin(swingAngle) * weaponLength;
                            
                            // Core burst (white)
                            ctx.fillStyle = '#ffffff';
                            ctx.shadowColor = '#ffffff';
                            ctx.shadowBlur = 30;
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 14, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Rainbow rays
                            for (let i = 0; i < 7; i++) {
                                const angle = (i / 7) * Math.PI * 2;
                                ctx.strokeStyle = rainbowColors[i];
                                ctx.shadowColor = rainbowColors[i];
                                ctx.shadowBlur = 20;
                                ctx.lineWidth = 4;
                                ctx.beginPath();
                                ctx.moveTo(muzzleX, muzzleY);
                                ctx.lineTo(
                                    muzzleX + Math.cos(angle) * 25,
                                    muzzleY + Math.sin(angle) * 25
                                );
                                ctx.stroke();
                            }
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    // CRYO BLASTER (‚ùÑÔ∏è) - Ice Weapon
                    else if (weaponSkin === 'weapon_frost') {
                        weaponRendered = true;
                        
                        const barrelLength = 54;
                        const tipX = px + Math.cos(swingAngle) * barrelLength;
                        const tipY = py + Math.sin(swingAngle) * barrelLength;
                        const perpAngle = swingAngle + Math.PI / 2;
                        
                        // ICE TANK/CANISTER (at handle)
                        ctx.strokeStyle = '#0066cc';
                        ctx.lineWidth = 14;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px + Math.cos(perpAngle) * 7, py + Math.sin(perpAngle) * 7);
                        ctx.lineTo(px - Math.cos(perpAngle) * 7, py - Math.sin(perpAngle) * 7);
                        ctx.stroke();
                        
                        // Frost inside tank (lighter blue)
                        ctx.strokeStyle = '#66b3ff';
                        ctx.lineWidth = 10;
                        ctx.beginPath();
                        ctx.moveTo(px + Math.cos(perpAngle) * 7, py + Math.sin(perpAngle) * 7);
                        ctx.lineTo(px - Math.cos(perpAngle) * 7, py - Math.sin(perpAngle) * 7);
                        ctx.stroke();
                        
                        // MAIN BARREL (gradient blue)
                        const gradient = ctx.createLinearGradient(px, py, tipX, tipY);
                        gradient.addColorStop(0, '#336699');
                        gradient.addColorStop(1, '#00ccff');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 11;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(tipX, tipY);
                        ctx.stroke();
                        
                        // FREEZE NOZZLE (cone shape - wider at tip)
                        ctx.strokeStyle = '#66b3ff';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(px + Math.cos(swingAngle) * (barrelLength * 0.6), 
                                   py + Math.sin(swingAngle) * (barrelLength * 0.6));
                        ctx.quadraticCurveTo(
                            px + Math.cos(swingAngle) * (barrelLength * 0.8) + Math.cos(perpAngle) * 6,
                            py + Math.sin(swingAngle) * (barrelLength * 0.8) + Math.sin(perpAngle) * 6,
                            tipX + Math.cos(perpAngle) * 12,
                            tipY + Math.sin(perpAngle) * 12
                        );
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(px + Math.cos(swingAngle) * (barrelLength * 0.6), 
                                   py + Math.sin(swingAngle) * (barrelLength * 0.6));
                        ctx.quadraticCurveTo(
                            px + Math.cos(swingAngle) * (barrelLength * 0.8) - Math.cos(perpAngle) * 6,
                            py + Math.sin(swingAngle) * (barrelLength * 0.8) - Math.sin(perpAngle) * 6,
                            tipX - Math.cos(perpAngle) * 12,
                            tipY - Math.sin(perpAngle) * 12
                        );
                        ctx.stroke();
                        
                        // ICE CRYSTALS (radial pattern at muzzle)
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 18;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const cx = tipX + Math.cos(angle) * 14;
                            const cy = tipY + Math.sin(angle) * 14;
                            
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(tipX, tipY);
                            ctx.lineTo(cx, cy);
                            ctx.stroke();
                            
                            // Ice shard tips
                            ctx.fillStyle = '#00ffff';
                            ctx.beginPath();
                            ctx.arc(cx, cy, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // GRIP
                        ctx.shadowBlur = 0;
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#003366';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 18,
                            py + Math.sin(gripAngle) * 18
                        );
                        ctx.stroke();
                        
                        // FREEZE BLAST (frost spray)
                        if (player.attackFrame > 10) {
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 25;
                            
                            // Core frost burst
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(tipX, tipY, 13, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Frost particles (spreading cone)
                            for (let i = 0; i < 10; i++) {
                                const spread = (Math.random() - 0.5) * 0.5;
                                const dist = 10 + Math.random() * 18;
                                const frostX = tipX + Math.cos(swingAngle + spread) * dist;
                                const frostY = tipY + Math.sin(swingAngle + spread) * dist;
                                
                                ctx.fillStyle = i % 2 === 0 ? '#00ffff' : '#ffffff';
                                ctx.beginPath();
                                ctx.arc(frostX, frostY, 2 + Math.random() * 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                    } // END isWeaponSkin check
                    
                    // DEFAULT WEAPON RENDERING (only if no skin rendered)
                    else if (!weaponRendered) {
                    console.log('DEFAULT WEAPON RENDERING - weaponName:', weaponName);
                    
                    // YAY (Av Yayƒ±, √áelik Yay)
                    if (weaponName && (weaponName.includes('Yay') || weaponName.includes('üèπ'))) {
                        const bowLength = 50;
                        const bowCenterX = px + Math.cos(swingAngle) * 20;
                        const bowCenterY = py + Math.sin(swingAngle) * 20;
                        
                        const perpAngle = swingAngle + Math.PI / 2;
                        const topX = bowCenterX + Math.cos(perpAngle) * bowLength / 2;
                        const topY = bowCenterY + Math.sin(perpAngle) * bowLength / 2;
                        const bottomX = bowCenterX - Math.cos(perpAngle) * bowLength / 2;
                        const bottomY = bowCenterY - Math.sin(perpAngle) * bowLength / 2;
                        
                        // Yay g√∂vdesi (kavisli)
                        ctx.strokeStyle = player.weapon.color;
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(topX, topY);
                        ctx.quadraticCurveTo(
                            bowCenterX + Math.cos(swingAngle) * 15,
                            bowCenterY + Math.sin(swingAngle) * 15,
                            bowCenterX, bowCenterY
                        );
                        ctx.quadraticCurveTo(
                            bowCenterX + Math.cos(swingAngle) * 15,
                            bowCenterY + Math.sin(swingAngle) * 15,
                            bottomX, bottomY
                        );
                        ctx.stroke();
                        
                        // Tutacak
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(bowCenterX - Math.cos(perpAngle) * 6, 
                                  bowCenterY - Math.sin(perpAngle) * 6);
                        ctx.lineTo(bowCenterX + Math.cos(perpAngle) * 6,
                                  bowCenterY + Math.sin(perpAngle) * 6);
                        ctx.stroke();
                        
                        // Kiri≈ü
                        const stringPullback = drawProgress * 25;
                        const stringX = bowCenterX - Math.cos(swingAngle) * stringPullback;
                        const stringY = bowCenterY - Math.sin(swingAngle) * stringPullback;
                        
                        ctx.strokeStyle = '#f5f5dc';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(topX, topY);
                        ctx.lineTo(stringX, stringY);
                        ctx.lineTo(bottomX, bottomY);
                        ctx.stroke();
                        
                        // Ok
                        if (drawProgress > 0.1) {
                            const arrowTipX = stringX + Math.cos(swingAngle) * 30;
                            const arrowTipY = stringY + Math.sin(swingAngle) * 30;
                            
                            ctx.strokeStyle = '#CD853F';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(stringX, stringY);
                            ctx.lineTo(arrowTipX, arrowTipY);
                            ctx.stroke();
                            
                            // Ok ba≈üƒ±
                            ctx.fillStyle = '#C0C0C0';
                            ctx.beginPath();
                            ctx.moveTo(arrowTipX + Math.cos(swingAngle) * 8, arrowTipY + Math.sin(swingAngle) * 8);
                            ctx.lineTo(arrowTipX + Math.cos(swingAngle + 2.8) * 6, arrowTipY + Math.sin(swingAngle + 2.8) * 6);
                            ctx.lineTo(arrowTipX, arrowTipY);
                            ctx.lineTo(arrowTipX + Math.cos(swingAngle - 2.8) * 6, arrowTipY + Math.sin(swingAngle - 2.8) * 6);
                            ctx.fill();
                        }
                    }
                    // ARBALET
                    else if (weaponName && (weaponName.includes('Arbalet') || weaponName.includes('üéØ'))) {
                        const stockLength = 45;
                        const crossbowWidth = 55;
                        
                        // G√∂vde
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 9;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * stockLength,
                            py + Math.sin(swingAngle) * stockLength
                        );
                        ctx.stroke();
                        
                        // √áapraz yay
                        const bowX = px + Math.cos(swingAngle) * (stockLength - 5);
                        const bowY = py + Math.sin(swingAngle) * (stockLength - 5);
                        const perpAngle = swingAngle + Math.PI / 2;
                        
                        ctx.strokeStyle = player.weapon.color;
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(
                            bowX + Math.cos(perpAngle) * crossbowWidth / 2,
                            bowY + Math.sin(perpAngle) * crossbowWidth / 2
                        );
                        ctx.lineTo(
                            bowX - Math.cos(perpAngle) * crossbowWidth / 2,
                            bowY - Math.sin(perpAngle) * crossbowWidth / 2
                        );
                        ctx.stroke();
                        
                        // Kiri≈ü
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(
                            bowX + Math.cos(perpAngle) * crossbowWidth / 2,
                            bowY + Math.sin(perpAngle) * crossbowWidth / 2
                        );
                        ctx.lineTo(
                            bowX - Math.cos(perpAngle) * crossbowWidth / 2,
                            bowY - Math.sin(perpAngle) * crossbowWidth / 2
                        );
                        ctx.stroke();
                        
                        // Bolt
                        if (drawProgress > 0) {
                            const boltX = bowX + Math.cos(swingAngle) * 40;
                            const boltY = bowY + Math.sin(swingAngle) * 40;
                            
                            ctx.strokeStyle = '#696969';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.moveTo(bowX, bowY);
                            ctx.lineTo(boltX, boltY);
                            ctx.stroke();
                        }
                        
                        // Tetik
                        ctx.fillStyle = '#C0C0C0';
                        ctx.fillRect(
                            px + Math.cos(swingAngle) * 15 - 3,
                            py + Math.sin(swingAngle) * 15 - 3,
                            6, 6
                        );
                    }
                    // ATE≈ûLƒ∞ Sƒ∞LAH
                    else if (weaponName && weaponName.includes('Ate≈üli')) {
                        const barrelLength = 55;
                        
                        // Namlu
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        gradient.addColorStop(0, '#444');
                        gradient.addColorStop(1, player.weapon.color);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 9;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * barrelLength,
                            py + Math.sin(swingAngle) * barrelLength
                        );
                        ctx.stroke();
                        
                        // Kabza
                        const gripAngle = swingAngle - Math.PI / 3;
                        ctx.strokeStyle = '#654321';
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(gripAngle) * 22,
                            py + Math.sin(gripAngle) * 22
                        );
                        ctx.stroke();
                        
                        // Tetik
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(
                            px + Math.cos(gripAngle) * 10,
                            py + Math.sin(gripAngle) * 10,
                            3, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Ate≈ü
                        if (player.attackFrame > 12) {
                            const muzzleX = px + Math.cos(swingAngle) * barrelLength;
                            const muzzleY = py + Math.sin(swingAngle) * barrelLength;
                            
                            ctx.fillStyle = '#FFA500';
                            ctx.shadowColor = '#FF4500';
                            ctx.shadowBlur = 20;
                            ctx.beginPath();
                            ctx.arc(muzzleX, muzzleY, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                    // LAZER T√úFEƒûƒ∞ / PLAZMA
                    else {
                        const rifleLength = 65;
                        
                        // G√∂vde
                        const gradient = ctx.createLinearGradient(px, py,
                            px + Math.cos(swingAngle) * rifleLength,
                            py + Math.sin(swingAngle) * rifleLength
                        );
                        gradient.addColorStop(0, '#1a1a2e');
                        gradient.addColorStop(0.5, '#16213e');
                        gradient.addColorStop(1, player.weapon.color);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 11;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(swingAngle) * rifleLength,
                            py + Math.sin(swingAngle) * rifleLength
                        );
                        ctx.stroke();
                        
                        // Enerji halkalarƒ±
                        for (let i = 0; i < 3; i++) {
                            const ringPos = 20 + i * 18;
                            ctx.strokeStyle = player.weapon.color;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath();
                            ctx.arc(
                                px + Math.cos(swingAngle) * ringPos,
                                py + Math.sin(swingAngle) * ringPos,
                                6, 0, Math.PI * 2
                            );
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        
                        // Namlu ucu
                        const muzzleX = px + Math.cos(swingAngle) * rifleLength;
                        const muzzleY = py + Math.sin(swingAngle) * rifleLength;
                        
                        ctx.fillStyle = player.weapon.color;
                        ctx.shadowColor = player.weapon.color;
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(muzzleX, muzzleY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Laser beam
                        if (player.attackFrame > 10) {
                            ctx.strokeStyle = player.weapon.color;
                            ctx.lineWidth = 4;
                            ctx.globalAlpha = 0.8;
                            ctx.shadowColor = player.weapon.color;
                            ctx.shadowBlur = 25;
                            ctx.beginPath();
                            ctx.moveTo(muzzleX, muzzleY);
                            ctx.lineTo(
                                muzzleX + Math.cos(swingAngle) * 120,
                                muzzleY + Math.sin(swingAngle) * 120
                            );
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                            ctx.shadowBlur = 0;
                        }
                    }
                    
                } else {
                    // MELEE Sƒ∞LAHLAR (KILI√á, BALTA, vs) - +20% boyut
                    const sizeBoost = 1.2; // %20 artƒ±≈ü
                    const handleLength = 15 * sizeBoost;
                    const effectiveRange = player.weapon.range * sizeBoost;
                    const bladeLength = effectiveRange - handleLength;
                    
                    const handleX = px + Math.cos(swingAngle) * handleLength;
                    const handleY = py + Math.sin(swingAngle) * handleLength;
                    const tipX = px + Math.cos(swingAngle) * effectiveRange;
                    const tipY = py + Math.sin(swingAngle) * effectiveRange;
                
                    // Silah izi (trail effect)
                    if (player.attackFrame > 0) {
                        for (let i = 0; i < 5; i++) {
                            const trailProgress = (i + 1) / 5;
                            const trailAngle = swingAngle - trailProgress * 0.3;
                            const trailTipX = px + Math.cos(trailAngle) * player.weapon.range;
                            const trailTipY = py + Math.sin(trailAngle) * player.weapon.range;
                            
                            ctx.strokeStyle = player.weapon.color + Math.floor((1 - trailProgress) * 80).toString(16).padStart(2, '0');
                            ctx.lineWidth = 8 * (1 - trailProgress);
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(trailTipX, trailTipY);
                            ctx.stroke();
                        }
                    }
                    
                    // Silah sapƒ± (handle)
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(handleX, handleY);
                    ctx.stroke();
                    
                    // Sap detayƒ±
                    ctx.strokeStyle = '#8B6914';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px + Math.cos(swingAngle) * 5, py + Math.sin(swingAngle) * 5);
                    ctx.lineTo(handleX, handleY);
                    ctx.stroke();
                    
                    // Silah bƒ±√ßaƒüƒ± (blade)
                    const bladeGradient = ctx.createLinearGradient(handleX, handleY, tipX, tipY);
                    bladeGradient.addColorStop(0, player.weapon.color);
                    
                    if (player.weapon.name === 'Ate≈ü Kƒ±lƒ±cƒ±') {
                        bladeGradient.addColorStop(0.5, '#FF8C00');
                        bladeGradient.addColorStop(1, '#FFD700');
                    } else if (player.weapon.name === '√áelik Kƒ±lƒ±√ß') {
                        bladeGradient.addColorStop(0.5, '#E8E8E8');
                        bladeGradient.addColorStop(1, '#FFFFFF');
                    } else if (player.weapon.name === 'Demir Kƒ±lƒ±√ß') {
                        bladeGradient.addColorStop(0.5, '#909090');
                        bladeGradient.addColorStop(1, '#B0B0B0');
                    } else {
                        bladeGradient.addColorStop(0.5, '#A0522D');
                        bladeGradient.addColorStop(1, '#CD853F');
                    }
                    
                    ctx.strokeStyle = bladeGradient;
                    ctx.lineWidth = 10;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(handleX, handleY);
                    ctx.lineTo(tipX, tipY);
                    ctx.stroke();
                    
                    // Bƒ±√ßak kenarƒ± (blade edge highlight)
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    const offsetX = Math.cos(swingAngle + Math.PI / 2) * 3;
                    const offsetY = Math.sin(swingAngle + Math.PI / 2) * 3;
                    ctx.beginPath();
                    ctx.moveTo(handleX + offsetX, handleY + offsetY);
                    ctx.lineTo(tipX + offsetX, tipY + offsetY);
                    ctx.stroke();
                    
                    // Ate≈ü kƒ±lƒ±cƒ± √∂zel efekt
                    if (player.weapon.name === 'Ate≈ü Kƒ±lƒ±cƒ±') {
                        // Ate≈ü par√ßacƒ±klarƒ±
                        if (Math.random() > 0.6) {
                            const fireX = handleX + (tipX - handleX) * Math.random();
                            const fireY = handleY + (tipY - handleY) * Math.random();
                            particles.push({
                                x: fireX + camera.x,
                                y: fireY + camera.y,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -Math.random() * 3,
                                life: 20,
                                color: Math.random() > 0.5 ? '#FF4500' : '#FFD700'
                            });
                        }
                        
                        // Parlama efekti
                        ctx.shadowColor = '#FF4500';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(handleX, handleY);
                        ctx.lineTo(tipX, tipY);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Koruma (guard)
                    ctx.fillStyle = player.weapon.color;
                    ctx.beginPath();
                    ctx.arc(handleX, handleY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = player.weapon.color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(handleX + Math.cos(swingAngle + Math.PI/2) * 10, 
                              handleY + Math.sin(swingAngle + Math.PI/2) * 10);
                    ctx.lineTo(handleX - Math.cos(swingAngle + Math.PI/2) * 10, 
                              handleY - Math.sin(swingAngle + Math.PI/2) * 10);
                    ctx.stroke();
                    
                    // Saldƒ±rƒ± dalgasƒ± efekti
                    if (player.attackFrame > 10) {
                        const waveSize = (15 - player.attackFrame) * 5;
                        ctx.strokeStyle = player.weapon.color + '40';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(tipX, tipY, waveSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } // Melee silahlar sonu + END if (!weaponRendered)
                
                ctx.shadowBlur = 0; // Shadow'u sƒ±fƒ±rla
            } // END ranged/hybrid weapons
        } // END player.attacking + draw()
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Oyunu ba≈ülat
        loadLeaderboard(); // Leaderboard'u y√ºkle
        loadPlayerProfile(); // Player profile y√ºkle
        loadBaseCustomization(); // Base customization y√ºkle
        
        // Dil g√ºncelle (varsayƒ±lan ƒ∞ngilizce)
        updateLanguage();
        
        // Profile display g√ºncelle
        if (playerProfile.name) {
            document.getElementById('playerNameDisplay').textContent = playerProfile.name;
        }
        document.getElementById('highScoreDisplay').textContent = playerProfile.highScore;
        
        // Main menu stats g√ºncelle
        updateMainMenuStats();
        
        // Initialize weekly challenges
        initializeWeeklyChallenges();
        updateWeeklyChallengesDisplay();
        
        // Initialize playtime display
        totalPlaytimeMinutes = parseInt(localStorage.getItem('plasmaTotalPlaytime') || 0);
        updatePlaytimeDisplay();
        
        // Load purchased items and equipped items
        loadPurchasedItems();
        loadEquippedItems();
        loadBattlePassData();
        updateBattlePassCard(); // Update battle pass card display
        
        // Initialize global leaderboard
        setTimeout(() => {
            loadGlobalLeaderboard();
            setupRealtimeLeaderboard();
            console.log('üåç Global leaderboard system initialized');
        }, 2000);
        
        // DEBUG: Test global leaderboard with sample data
        window.addTestScores = async function() {
            console.log('üìù Adding test scores to global leaderboard...');
            
            const testScores = [
                { name: 'ProGamer', score: 15000, wave: 50, kills: 1500 },
                { name: 'SkillMaster', score: 14500, wave: 48, kills: 1450 },
                { name: 'PlayerOne', score: 14000, wave: 47, kills: 1400 },
                { name: 'Champion', score: 13500, wave: 45, kills: 1350 },
                { name: 'BeastMode', score: 13000, wave: 44, kills: 1300 },
                { name: 'NinjaPro', score: 12500, wave: 42, kills: 1250 },
                { name: 'EliteGamer', score: 12000, wave: 40, kills: 1200 },
                { name: 'MegaPlayer', score: 11500, wave: 38, kills: 1150 },
                { name: 'SuperStar', score: 11000, wave: 37, kills: 1100 },
                { name: 'TopPlayer', score: 10500, wave: 35, kills: 1050 }
            ];
            
            for (let i = 0; i < testScores.length; i++) {
                const test = testScores[i];
                await submitToGlobalLeaderboard(test.name, test.score, test.wave, test.kills);
                console.log(`‚úÖ Test score ${i + 1}/${testScores.length}: ${test.name} - ${test.score}`);
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms between submissions
            }
            
            console.log('üéâ All test scores added! Check the leaderboard!');
            
            // Reload to show updated data
            setTimeout(() => {
                loadGlobalLeaderboard();
            }, 1000);
        };
        
        // Make it easy to access
        console.log('üí° TIP: Type "addTestScores()" in console to add test data to global leaderboard');
        
        // Animated background generate
        generateMenuBackground();
        
        // Main menu'yu g√∂ster
        document.getElementById('mainMenu').classList.remove('hidden');
        
        gameLoop();
    </script>
</body>
</html>
